{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar JsonLdError = require('./JsonLdError');\n\nvar _require = require('./types'),\n    _isArray = _require.isArray,\n    _isObject = _require.isObject,\n    _isEmptyObject = _require.isEmptyObject,\n    _isString = _require.isString,\n    _isUndefined = _require.isUndefined;\n\nvar _require2 = require('./graphTypes'),\n    _isList = _require2.isList,\n    _isValue = _require2.isValue,\n    _isGraph = _require2.isGraph;\n\nvar _require3 = require('./context'),\n    _expandIri = _require3.expandIri,\n    _getContextValue = _require3.getContextValue,\n    _isKeyword = _require3.isKeyword,\n    _processContext = _require3.process,\n    _processingMode = _require3.processingMode;\n\nvar _require4 = require('./url'),\n    _isAbsoluteIri = _require4.isAbsolute;\n\nvar _require5 = require('./util'),\n    _addValue = _require5.addValue,\n    _asArray = _require5.asArray,\n    _getValues = _require5.getValues,\n    _validateTypeValue = _require5.validateTypeValue;\n\nvar api = {};\nmodule.exports = api;\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n *\n * @return a Promise that resolves to the expanded value.\n */\n\napi.expand = function (_ref) {\n  var activeCtx = _ref.activeCtx,\n      _ref$activeProperty = _ref.activeProperty,\n      activeProperty = _ref$activeProperty === void 0 ? null : _ref$activeProperty,\n      element = _ref.element,\n      _ref$options = _ref.options,\n      options = _ref$options === void 0 ? {} : _ref$options,\n      _ref$insideList = _ref.insideList,\n      insideList = _ref$insideList === void 0 ? false : _ref$insideList,\n      _ref$insideIndex = _ref.insideIndex,\n      insideIndex = _ref$insideIndex === void 0 ? false : _ref$insideIndex,\n      _ref$typeScopedContex = _ref.typeScopedContext,\n      typeScopedContext = _ref$typeScopedContex === void 0 ? null : _ref$typeScopedContex,\n      _ref$expansionMap = _ref.expansionMap,\n      expansionMap = _ref$expansionMap === void 0 ? function () {\n    return undefined;\n  } : _ref$expansionMap;\n\n  // nothing to expand\n  if (element === null || element === undefined) {\n    return null;\n  } // disable framing if activeProperty is @default\n\n\n  if (activeProperty === '@default') {\n    options = Object.assign({}, options, {\n      isFrame: false\n    });\n  }\n\n  if (!_isArray(element) && !_isObject(element)) {\n    // drop free-floating scalars that are not in lists unless custom mapped\n    if (!insideList && (activeProperty === null || _expandIri(activeCtx, activeProperty, {\n      vocab: true\n    }, options) === '@graph')) {\n      // TODO: use `await` to support async\n      var mapped = expansionMap({\n        unmappedValue: element,\n        activeCtx: activeCtx,\n        activeProperty: activeProperty,\n        options: options,\n        insideList: insideList\n      });\n\n      if (mapped === undefined) {\n        return null;\n      }\n\n      return mapped;\n    } // expand element according to value expansion rules\n\n\n    return _expandValue({\n      activeCtx: activeCtx,\n      activeProperty: activeProperty,\n      value: element,\n      options: options\n    });\n  } // recursively expand array\n\n\n  if (_isArray(element)) {\n    var _rval = [];\n    var container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n    insideList = insideList || container.includes('@list');\n\n    for (var i = 0; i < element.length; ++i) {\n      // expand element\n      var e = api.expand({\n        activeCtx: activeCtx,\n        activeProperty: activeProperty,\n        element: element[i],\n        options: options,\n        expansionMap: expansionMap,\n        insideIndex: insideIndex,\n        typeScopedContext: typeScopedContext\n      });\n\n      if (insideList && _isArray(e)) {\n        e = {\n          '@list': e\n        };\n      }\n\n      if (e === null) {\n        // TODO: add `await` for async support\n        e = expansionMap({\n          unmappedValue: element[i],\n          activeCtx: activeCtx,\n          activeProperty: activeProperty,\n          parent: element,\n          index: i,\n          options: options,\n          expandedParent: _rval,\n          insideList: insideList\n        });\n\n        if (e === undefined) {\n          continue;\n        }\n      }\n\n      if (_isArray(e)) {\n        _rval = _rval.concat(e);\n      } else {\n        _rval.push(e);\n      }\n    }\n\n    return _rval;\n  } // recursively expand object:\n  // first, expand the active property\n\n\n  var expandedActiveProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options); // second, determine if any type-scoped context should be reverted; it\n  // should only be reverted when the following are all true:\n  // 1. `element` is not a value or subject reference\n  // 2. `insideIndex` is false\n\n\n  typeScopedContext = typeScopedContext || (activeCtx.previousContext ? activeCtx : null);\n  var keys = Object.keys(element).sort();\n  var mustRevert = !insideIndex;\n\n  if (mustRevert && typeScopedContext && keys.length <= 2 && !keys.includes('@context')) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var key = _step.value;\n\n        var expandedProperty = _expandIri(typeScopedContext, key, {\n          vocab: true\n        }, options);\n\n        if (expandedProperty === '@value') {\n          // value found, ensure type-scoped context is used to expand it\n          mustRevert = false;\n          activeCtx = typeScopedContext;\n          break;\n        }\n\n        if (expandedProperty === '@id' && keys.length === 1) {\n          // subject reference found, do not revert\n          mustRevert = false;\n          break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  if (mustRevert) {\n    // revert type scoped context\n    activeCtx = activeCtx.revertTypeScopedContext();\n  } // if element has a context, process it\n\n\n  if ('@context' in element) {\n    activeCtx = _processContext({\n      activeCtx: activeCtx,\n      localCtx: element['@context'],\n      options: options\n    });\n  } // look for scoped contexts on `@type`\n\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _key = _step2.value;\n\n      var _expandedProperty = _expandIri(activeCtx, _key, {\n        vocab: true\n      }, options);\n\n      if (_expandedProperty === '@type') {\n        // set scoped contexts from @type\n        // avoid sorting if possible\n        var value = element[_key];\n\n        var _types = Array.isArray(value) ? value.length > 1 ? value.slice().sort() : value : [value];\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = _types[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var type = _step3.value;\n\n            var ctx = _getContextValue(activeCtx.previousContext || activeCtx, type, '@context');\n\n            if (!_isUndefined(ctx)) {\n              activeCtx = _processContext({\n                activeCtx: activeCtx,\n                localCtx: ctx,\n                options: options,\n                isTypeScopedContext: true\n              });\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    } // process each key and value in element, ignoring @nest content\n\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var rval = {};\n\n  _expandObject({\n    activeCtx: activeCtx,\n    activeProperty: activeProperty,\n    expandedActiveProperty: expandedActiveProperty,\n    element: element,\n    expandedParent: rval,\n    options: options,\n    insideList: insideList,\n    typeScopedContext: typeScopedContext,\n    expansionMap: expansionMap\n  }); // get property count on expanded output\n\n\n  keys = Object.keys(rval);\n  var count = keys.length;\n\n  if ('@value' in rval) {\n    // @value must only have @language or @type\n    if ('@type' in rval && '@language' in rval) {\n      throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" may not ' + 'contain both \"@type\" and \"@language\".', 'jsonld.SyntaxError', {\n        code: 'invalid value object',\n        element: rval\n      });\n    }\n\n    var validCount = count - 1;\n\n    if ('@type' in rval) {\n      validCount -= 1;\n    }\n\n    if ('@index' in rval) {\n      validCount -= 1;\n    }\n\n    if ('@language' in rval) {\n      validCount -= 1;\n    }\n\n    if (validCount !== 0) {\n      throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" may only ' + 'have an \"@index\" property and at most one other property ' + 'which can be \"@type\" or \"@language\".', 'jsonld.SyntaxError', {\n        code: 'invalid value object',\n        element: rval\n      });\n    }\n\n    var values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n\n    var types = _getValues(rval, '@type'); // drop null @values unless custom mapped\n\n\n    if (values.length === 0) {\n      // TODO: use `await` to support async\n      var _mapped = expansionMap({\n        unmappedValue: rval,\n        activeCtx: activeCtx,\n        activeProperty: activeProperty,\n        element: element,\n        options: options,\n        insideList: insideList\n      });\n\n      if (_mapped !== undefined) {\n        rval = _mapped;\n      } else {\n        rval = null;\n      }\n    } else if (!values.every(function (v) {\n      return _isString(v) || _isEmptyObject(v);\n    }) && '@language' in rval) {\n      // if @language is present, @value must be a string\n      throw new JsonLdError('Invalid JSON-LD syntax; only strings may be language-tagged.', 'jsonld.SyntaxError', {\n        code: 'invalid language-tagged value',\n        element: rval\n      });\n    } else if (_processingMode(activeCtx, 1.1) && types.includes('@json') && types.length === 1) {// Any value of @value is okay if @type: @json\n    } else if (!types.every(function (t) {\n      return _isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) || _isEmptyObject(t);\n    })) {\n      throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' + 'must have an absolute IRI for the value of \"@type\".', 'jsonld.SyntaxError', {\n        code: 'invalid typed value',\n        element: rval\n      });\n    }\n  } else if ('@type' in rval && !_isArray(rval['@type'])) {\n    // convert @type to an array\n    rval['@type'] = [rval['@type']];\n  } else if ('@set' in rval || '@list' in rval) {\n    // handle @set and @list\n    if (count > 1 && !(count === 2 && '@index' in rval)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; if an element has the property \"@set\" ' + 'or \"@list\", then it can have at most one other property that is ' + '\"@index\".', 'jsonld.SyntaxError', {\n        code: 'invalid set or list object',\n        element: rval\n      });\n    } // optimize away @set\n\n\n    if ('@set' in rval) {\n      rval = rval['@set'];\n      keys = Object.keys(rval);\n      count = keys.length;\n    }\n  } else if (count === 1 && '@language' in rval) {\n    // drop objects with only @language unless custom mapped\n    // TODO: use `await` to support async\n    var _mapped2 = expansionMap(rval, {\n      unmappedValue: rval,\n      activeCtx: activeCtx,\n      activeProperty: activeProperty,\n      element: element,\n      options: options,\n      insideList: insideList\n    });\n\n    if (_mapped2 !== undefined) {\n      rval = _mapped2;\n    } else {\n      rval = null;\n    }\n  } // drop certain top-level objects that do not occur in lists, unless custom\n  // mapped\n\n\n  if (_isObject(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === '@graph')) {\n    // drop empty object, top-level @value/@list, or object with only @id\n    if (count === 0 || '@value' in rval || '@list' in rval || count === 1 && '@id' in rval) {\n      // TODO: use `await` to support async\n      var _mapped3 = expansionMap({\n        unmappedValue: rval,\n        activeCtx: activeCtx,\n        activeProperty: activeProperty,\n        element: element,\n        options: options,\n        insideList: insideList\n      });\n\n      if (_mapped3 !== undefined) {\n        rval = _mapped3;\n      } else {\n        rval = null;\n      }\n    }\n  }\n\n  return rval;\n};\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n */\n\n\nfunction _expandObject(_ref2) {\n  var activeCtx = _ref2.activeCtx,\n      activeProperty = _ref2.activeProperty,\n      expandedActiveProperty = _ref2.expandedActiveProperty,\n      element = _ref2.element,\n      expandedParent = _ref2.expandedParent,\n      _ref2$options = _ref2.options,\n      options = _ref2$options === void 0 ? {} : _ref2$options,\n      insideList = _ref2.insideList,\n      expansionMap = _ref2.expansionMap;\n  var keys = Object.keys(element).sort();\n  var nests = [];\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = keys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var key = _step4.value;\n      var _value = element[key];\n      var expandedValue = void 0; // skip @context\n\n      if (key === '@context') {\n        continue;\n      } // expand property\n\n\n      var expandedProperty = _expandIri(activeCtx, key, {\n        vocab: true\n      }, options); // drop non-absolute IRI keys that aren't keywords unless custom mapped\n\n\n      if (expandedProperty === null || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {\n        // TODO: use `await` to support async\n        expandedProperty = expansionMap({\n          unmappedProperty: key,\n          activeCtx: activeCtx,\n          activeProperty: activeProperty,\n          parent: element,\n          options: options,\n          insideList: insideList,\n          value: _value,\n          expandedParent: expandedParent\n        });\n\n        if (expandedProperty === undefined) {\n          continue;\n        }\n      }\n\n      if (_isKeyword(expandedProperty)) {\n        if (expandedActiveProperty === '@reverse') {\n          throw new JsonLdError('Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' + 'property.', 'jsonld.SyntaxError', {\n            code: 'invalid reverse property map',\n            value: _value\n          });\n        }\n\n        if (expandedProperty in expandedParent) {\n          throw new JsonLdError('Invalid JSON-LD syntax; colliding keywords detected.', 'jsonld.SyntaxError', {\n            code: 'colliding keywords',\n            keyword: expandedProperty\n          });\n        }\n      } // syntax error if @id is not a string\n\n\n      if (expandedProperty === '@id') {\n        if (!_isString(_value)) {\n          if (!options.isFrame) {\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value must a string.', 'jsonld.SyntaxError', {\n              code: 'invalid @id value',\n              value: _value\n            });\n          }\n\n          if (_isObject(_value)) {\n            // empty object is a wildcard\n            if (!_isEmptyObject(_value)) {\n              throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n                code: 'invalid @id value',\n                value: _value\n              });\n            }\n          } else if (_isArray(_value)) {\n            if (!_value.every(function (v) {\n              return _isString(v);\n            })) {\n              throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n                code: 'invalid @id value',\n                value: _value\n              });\n            }\n          } else {\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n              code: 'invalid @id value',\n              value: _value\n            });\n          }\n        }\n\n        _addValue(expandedParent, '@id', _asArray(_value).map(function (v) {\n          return _isString(v) ? _expandIri(activeCtx, v, {\n            base: true\n          }, options) : v;\n        }), {\n          propertyIsArray: options.isFrame\n        });\n\n        continue;\n      }\n\n      if (expandedProperty === '@type') {\n        _validateTypeValue(_value);\n\n        _addValue(expandedParent, '@type', _asArray(_value).map(function (v) {\n          return _isString(v) ? _expandIri(activeCtx.previousContext || activeCtx, v, {\n            base: true,\n            vocab: true\n          }, options) : v;\n        }), {\n          propertyIsArray: options.isFrame\n        });\n\n        continue;\n      } // @graph must be an array or an object\n\n\n      if (expandedProperty === '@graph' && !(_isObject(_value) || _isArray(_value))) {\n        throw new JsonLdError('Invalid JSON-LD syntax; \"@graph\" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {\n          code: 'invalid @graph value',\n          value: _value\n        });\n      }\n\n      if (expandedProperty === '@value') {\n        _addValue(expandedParent, '@value', _value, {\n          propertyIsArray: options.isFrame\n        });\n\n        continue;\n      } // @language must be a string\n\n\n      if (expandedProperty === '@language') {\n        if (_value === null) {\n          // drop null @language values, they expand as if they didn't exist\n          continue;\n        }\n\n        if (!_isString(_value) && !options.isFrame) {\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@language\" value must be a string.', 'jsonld.SyntaxError', {\n            code: 'invalid language-tagged string',\n            value: _value\n          });\n        } // ensure language value is lowercase\n\n\n        _value = _asArray(_value).map(function (v) {\n          return _isString(v) ? v.toLowerCase() : v;\n        });\n\n        _addValue(expandedParent, '@language', _value, {\n          propertyIsArray: options.isFrame\n        });\n\n        continue;\n      } // @index must be a string\n\n\n      if (expandedProperty === '@index') {\n        if (!_isString(_value)) {\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@index\" value must be a string.', 'jsonld.SyntaxError', {\n            code: 'invalid @index value',\n            value: _value\n          });\n        }\n\n        _addValue(expandedParent, '@index', _value);\n\n        continue;\n      } // @reverse must be an object\n\n\n      if (expandedProperty === '@reverse') {\n        if (!_isObject(_value)) {\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must be an object.', 'jsonld.SyntaxError', {\n            code: 'invalid @reverse value',\n            value: _value\n          });\n        }\n\n        expandedValue = api.expand({\n          activeCtx: activeCtx,\n          activeProperty: '@reverse',\n          element: _value,\n          options: options,\n          expansionMap: expansionMap\n        }); // properties double-reversed\n\n        if ('@reverse' in expandedValue) {\n          for (var property in expandedValue['@reverse']) {\n            _addValue(expandedParent, property, expandedValue['@reverse'][property], {\n              propertyIsArray: true\n            });\n          }\n        } // FIXME: can this be merged with code below to simplify?\n        // merge in all reversed properties\n\n\n        var reverseMap = expandedParent['@reverse'] || null;\n\n        for (var _property in expandedValue) {\n          if (_property === '@reverse') {\n            continue;\n          }\n\n          if (reverseMap === null) {\n            reverseMap = expandedParent['@reverse'] = {};\n          }\n\n          _addValue(reverseMap, _property, [], {\n            propertyIsArray: true\n          });\n\n          var items = expandedValue[_property];\n\n          for (var ii = 0; ii < items.length; ++ii) {\n            var item = items[ii];\n\n            if (_isValue(item) || _isList(item)) {\n              throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {\n                code: 'invalid reverse property value',\n                value: expandedValue\n              });\n            }\n\n            _addValue(reverseMap, _property, item, {\n              propertyIsArray: true\n            });\n          }\n        }\n\n        continue;\n      } // nested keys\n\n\n      if (expandedProperty === '@nest') {\n        nests.push(key);\n        continue;\n      } // use potential scoped context for key\n\n\n      var termCtx = activeCtx;\n\n      var ctx = _getContextValue(activeCtx, key, '@context');\n\n      if (!_isUndefined(ctx)) {\n        // Note: spec's `from term` var is named `isPropertyTermScopedContext`\n        termCtx = _processContext({\n          activeCtx: activeCtx,\n          localCtx: ctx,\n          isPropertyTermScopedContext: true,\n          options: options\n        });\n      }\n\n      var container = _getContextValue(termCtx, key, '@container') || [];\n\n      if (container.includes('@language') && _isObject(_value)) {\n        // handle language map container (skip if value is not an object)\n        expandedValue = _expandLanguageMap(termCtx, _value, options);\n      } else if (container.includes('@index') && _isObject(_value)) {\n        // handle index container (skip if value is not an object)\n        var asGraph = container.includes('@graph');\n        expandedValue = _expandIndexMap({\n          activeCtx: termCtx,\n          options: options,\n          activeProperty: key,\n          value: _value,\n          expansionMap: expansionMap,\n          asGraph: asGraph,\n          indexKey: '@index'\n        });\n      } else if (container.includes('@id') && _isObject(_value)) {\n        // handle id container (skip if value is not an object)\n        var _asGraph = container.includes('@graph');\n\n        expandedValue = _expandIndexMap({\n          activeCtx: termCtx,\n          options: options,\n          activeProperty: key,\n          value: _value,\n          expansionMap: expansionMap,\n          asGraph: _asGraph,\n          indexKey: '@id'\n        });\n      } else if (container.includes('@type') && _isObject(_value)) {\n        // handle type container (skip if value is not an object)\n        expandedValue = _expandIndexMap({\n          // since container is `@type`, revert type scoped context when expanding\n          activeCtx: termCtx.revertTypeScopedContext(),\n          options: options,\n          activeProperty: key,\n          value: _value,\n          expansionMap: expansionMap,\n          asGraph: false,\n          indexKey: '@type'\n        });\n      } else {\n        // recurse into @list or @set\n        var isList = expandedProperty === '@list';\n\n        if (isList || expandedProperty === '@set') {\n          var nextActiveProperty = activeProperty;\n\n          if (isList && expandedActiveProperty === '@graph') {\n            nextActiveProperty = null;\n          }\n\n          expandedValue = api.expand({\n            activeCtx: termCtx,\n            activeProperty: nextActiveProperty,\n            element: _value,\n            options: options,\n            insideList: isList,\n            expansionMap: expansionMap\n          });\n        } else if (_getContextValue(activeCtx, key, '@type') === '@json') {\n          expandedValue = {\n            '@type': '@json',\n            '@value': _value\n          };\n        } else {\n          // recursively expand value with key as new active property\n          expandedValue = api.expand({\n            activeCtx: termCtx,\n            activeProperty: key,\n            element: _value,\n            options: options,\n            insideList: false,\n            expansionMap: expansionMap\n          });\n        }\n      } // drop null values if property is not @value\n\n\n      if (expandedValue === null && expandedProperty !== '@value') {\n        // TODO: use `await` to support async\n        expandedValue = expansionMap({\n          unmappedValue: _value,\n          expandedProperty: expandedProperty,\n          activeCtx: termCtx,\n          activeProperty: activeProperty,\n          parent: element,\n          options: options,\n          insideList: insideList,\n          key: key,\n          expandedParent: expandedParent\n        });\n\n        if (expandedValue === undefined) {\n          continue;\n        }\n      } // convert expanded value to @list if container specifies it\n\n\n      if (expandedProperty !== '@list' && !_isList(expandedValue) && container.includes('@list')) {\n        // ensure expanded value in @list is an array\n        expandedValue = {\n          '@list': _asArray(expandedValue)\n        };\n      } // convert expanded value to @graph if container specifies it\n      // and value is not, itself, a graph\n      // index cases handled above\n\n\n      if (container.includes('@graph') && !container.some(function (key) {\n        return key === '@id' || key === '@index';\n      })) {\n        // ensure expanded values are arrays\n        expandedValue = _asArray(expandedValue).map(function (v) {\n          return _isGraph(v) ? v : {\n            '@graph': _asArray(v)\n          };\n        });\n      } // FIXME: can this be merged with code above to simplify?\n      // merge in reverse properties\n\n\n      if (termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {\n        var _reverseMap = expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n\n        expandedValue = _asArray(expandedValue);\n\n        for (var _ii = 0; _ii < expandedValue.length; ++_ii) {\n          var _item = expandedValue[_ii];\n\n          if (_isValue(_item) || _isList(_item)) {\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {\n              code: 'invalid reverse property value',\n              value: expandedValue\n            });\n          }\n\n          _addValue(_reverseMap, expandedProperty, _item, {\n            propertyIsArray: true\n          });\n        }\n\n        continue;\n      } // add value for property\n      // use an array except for certain keywords\n\n\n      var useArray = !['@index', '@id', '@type', '@value', '@language'].includes(expandedProperty);\n\n      _addValue(expandedParent, expandedProperty, expandedValue, {\n        propertyIsArray: useArray\n      });\n    } // @value must not be an object or an array (unless framing) or if @type is\n    // @json\n\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  if ('@value' in element) {\n    var value = element['@value'];\n\n    if (element['@type'] === '@json' && _processingMode(activeCtx, 1.1)) {// allow any value, to be verified when the object is fully expanded and\n      // the @type is @json.\n    } else if ((_isObject(value) || _isArray(value)) && !options.isFrame) {\n      throw new JsonLdError('Invalid JSON-LD syntax; \"@value\" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {\n        code: 'invalid value object value',\n        value: value\n      });\n    }\n  } // expand each nested key\n\n\n  for (var _i = 0, _nests = nests; _i < _nests.length; _i++) {\n    var _key2 = _nests[_i];\n    var nestedValues = _isArray(element[_key2]) ? element[_key2] : [element[_key2]];\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = nestedValues[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var nv = _step5.value;\n\n        if (!_isObject(nv) || Object.keys(nv).some(function (k) {\n          return _expandIri(activeCtx, k, {\n            vocab: true\n          }, options) === '@value';\n        })) {\n          throw new JsonLdError('Invalid JSON-LD syntax; nested value must be a node object.', 'jsonld.SyntaxError', {\n            code: 'invalid @nest value',\n            value: nv\n          });\n        }\n\n        _expandObject({\n          activeCtx: activeCtx,\n          activeProperty: activeProperty,\n          expandedActiveProperty: expandedActiveProperty,\n          element: nv,\n          expandedParent: expandedParent,\n          options: options,\n          insideList: insideList,\n          expansionMap: expansionMap\n        });\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n  }\n}\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\n\n\nfunction _expandValue(_ref3) {\n  var activeCtx = _ref3.activeCtx,\n      activeProperty = _ref3.activeProperty,\n      value = _ref3.value,\n      options = _ref3.options;\n\n  // nothing to expand\n  if (value === null || value === undefined) {\n    return null;\n  } // special-case expand @id and @type (skips '@id' expansion)\n\n\n  var expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n\n  if (expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {\n      base: true\n    }, options);\n  } else if (expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {\n      vocab: true,\n      base: true\n    }, options);\n  } // get type definition from context\n\n\n  var type = _getContextValue(activeCtx, activeProperty, '@type'); // do @id expansion (automatic for @graph)\n\n\n  if ((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {\n        base: true\n      }, options)\n    };\n  } // do @id expansion w/vocab\n\n\n  if (type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {\n        vocab: true,\n        base: true\n      }, options)\n    };\n  } // do not expand keyword values\n\n\n  if (_isKeyword(expandedProperty)) {\n    return value;\n  }\n\n  var rval = {};\n\n  if (type && !['@id', '@vocab'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if (_isString(value)) {\n    // check for language tagging for strings\n    var language = _getContextValue(activeCtx, activeProperty, '@language');\n\n    if (language !== null) {\n      rval['@language'] = language;\n    }\n  } // do conversion of values that aren't basic JSON types to strings\n\n\n  if (!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n\n  rval['@value'] = value;\n  return rval;\n}\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\n\n\nfunction _expandLanguageMap(activeCtx, languageMap, options) {\n  var rval = [];\n  var keys = Object.keys(languageMap).sort();\n  var _iteratorNormalCompletion6 = true;\n  var _didIteratorError6 = false;\n  var _iteratorError6 = undefined;\n\n  try {\n    for (var _iterator6 = keys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n      var key = _step6.value;\n\n      var expandedKey = _expandIri(activeCtx, key, {\n        vocab: true\n      }, options);\n\n      var val = languageMap[key];\n\n      if (!_isArray(val)) {\n        val = [val];\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = val[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var item = _step7.value;\n\n          if (item === null) {\n            // null values are allowed (8.5) but ignored (3.1)\n            continue;\n          }\n\n          if (!_isString(item)) {\n            throw new JsonLdError('Invalid JSON-LD syntax; language map values must be strings.', 'jsonld.SyntaxError', {\n              code: 'invalid language map value',\n              languageMap: languageMap\n            });\n          }\n\n          var _val = {\n            '@value': item\n          };\n\n          if (expandedKey !== '@none') {\n            _val['@language'] = key.toLowerCase();\n          }\n\n          rval.push(_val);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError6 = true;\n    _iteratorError6 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n        _iterator6.return();\n      }\n    } finally {\n      if (_didIteratorError6) {\n        throw _iteratorError6;\n      }\n    }\n  }\n\n  return rval;\n}\n\nfunction _expandIndexMap(_ref4) {\n  var activeCtx = _ref4.activeCtx,\n      options = _ref4.options,\n      activeProperty = _ref4.activeProperty,\n      value = _ref4.value,\n      expansionMap = _ref4.expansionMap,\n      asGraph = _ref4.asGraph,\n      indexKey = _ref4.indexKey;\n  var rval = [];\n  var keys = Object.keys(value).sort();\n  var isTypeIndex = indexKey === '@type';\n  var _iteratorNormalCompletion8 = true;\n  var _didIteratorError8 = false;\n  var _iteratorError8 = undefined;\n\n  try {\n    for (var _iterator8 = keys[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n      var key = _step8.value;\n\n      // if indexKey is @type, there may be a context defined for it\n      if (isTypeIndex) {\n        var ctx = _getContextValue(activeCtx, key, '@context');\n\n        if (!_isUndefined(ctx)) {\n          activeCtx = _processContext({\n            activeCtx: activeCtx,\n            localCtx: ctx,\n            isTypeScopedContext: true,\n            options: options\n          });\n        }\n      }\n\n      var val = value[key];\n\n      if (!_isArray(val)) {\n        val = [val];\n      } // expand for @type, but also for @none\n\n\n      var expandedKey = _expandIri(activeCtx, key, {\n        vocab: true\n      }, options);\n\n      if (indexKey === '@id') {\n        // expand document relative\n        key = _expandIri(activeCtx, key, {\n          base: true\n        }, options);\n      } else if (isTypeIndex) {\n        key = expandedKey;\n      }\n\n      val = api.expand({\n        activeCtx: activeCtx,\n        activeProperty: activeProperty,\n        element: val,\n        options: options,\n        insideList: false,\n        insideIndex: true,\n        expansionMap: expansionMap\n      });\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = val[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var item = _step9.value;\n\n          // If this is also a @graph container, turn items into graphs\n          if (asGraph && !_isGraph(item)) {\n            item = {\n              '@graph': [item]\n            };\n          }\n\n          if (indexKey === '@type') {\n            if (expandedKey === '@none') {// ignore @none\n            } else if (item['@type']) {\n              item['@type'] = [key].concat(item['@type']);\n            } else {\n              item['@type'] = [key];\n            }\n          } else if (expandedKey !== '@none' && !(indexKey in item)) {\n            item[indexKey] = key;\n          }\n\n          rval.push(item);\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError8 = true;\n    _iteratorError8 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n        _iterator8.return();\n      }\n    } finally {\n      if (_didIteratorError8) {\n        throw _iteratorError8;\n      }\n    }\n  }\n\n  return rval;\n}","map":{"version":3,"sources":["C:/Users/Guillaume/Code/e-commerce/admin/node_modules/jsonld/lib/expand.js"],"names":["JsonLdError","require","_isArray","isArray","_isObject","isObject","_isEmptyObject","isEmptyObject","_isString","isString","_isUndefined","isUndefined","_isList","isList","_isValue","isValue","_isGraph","isGraph","_expandIri","expandIri","_getContextValue","getContextValue","_isKeyword","isKeyword","_processContext","process","_processingMode","processingMode","_isAbsoluteIri","isAbsolute","_addValue","addValue","_asArray","asArray","_getValues","getValues","_validateTypeValue","validateTypeValue","api","module","exports","expand","activeCtx","activeProperty","element","options","insideList","insideIndex","typeScopedContext","expansionMap","undefined","Object","assign","isFrame","vocab","mapped","unmappedValue","_expandValue","value","rval","container","includes","i","length","e","parent","index","expandedParent","concat","push","expandedActiveProperty","previousContext","keys","sort","mustRevert","key","expandedProperty","revertTypeScopedContext","localCtx","types","Array","slice","type","ctx","isTypeScopedContext","_expandObject","count","code","validCount","values","every","v","t","indexOf","keepFreeFloatingNodes","nests","expandedValue","unmappedProperty","keyword","map","base","propertyIsArray","toLowerCase","property","reverseMap","items","ii","item","termCtx","isPropertyTermScopedContext","_expandLanguageMap","asGraph","_expandIndexMap","indexKey","nextActiveProperty","some","mappings","has","get","reverse","useArray","nestedValues","nv","k","language","toString","languageMap","expandedKey","val","isTypeIndex"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isEmptyObject: _isEmptyObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  getValues: _getValues,\n  validateTypeValue: _validateTypeValue\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n *\n * @return a Promise that resolves to the expanded value.\n */\napi.expand = ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  insideList = false,\n  insideIndex = false,\n  typeScopedContext = null,\n  expansionMap = () => undefined\n}) => {\n  // nothing to expand\n  if(element === null || element === undefined) {\n    return null;\n  }\n\n  // disable framing if activeProperty is @default\n  if(activeProperty === '@default') {\n    options = Object.assign({}, options, {isFrame: false});\n  }\n\n  if(!_isArray(element) && !_isObject(element)) {\n    // drop free-floating scalars that are not in lists unless custom mapped\n    if(!insideList && (activeProperty === null ||\n      _expandIri(activeCtx, activeProperty, {vocab: true},\n        options) === '@graph')) {\n      // TODO: use `await` to support async\n      const mapped = expansionMap({\n        unmappedValue: element,\n        activeCtx,\n        activeProperty,\n        options,\n        insideList\n      });\n      if(mapped === undefined) {\n        return null;\n      }\n      return mapped;\n    }\n\n    // expand element according to value expansion rules\n    return _expandValue({activeCtx, activeProperty, value: element, options});\n  }\n\n  // recursively expand array\n  if(_isArray(element)) {\n    let rval = [];\n    const container = _getContextValue(\n      activeCtx, activeProperty, '@container') || [];\n    insideList = insideList || container.includes('@list');\n    for(let i = 0; i < element.length; ++i) {\n      // expand element\n      let e = api.expand({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        expansionMap,\n        insideIndex,\n        typeScopedContext\n      });\n      if(insideList && _isArray(e)) {\n        e = {'@list': e};\n      }\n\n      if(e === null) {\n        // TODO: add `await` for async support\n        e = expansionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options,\n          expandedParent: rval,\n          insideList\n        });\n        if(e === undefined) {\n          continue;\n        }\n      }\n\n      if(_isArray(e)) {\n        rval = rval.concat(e);\n      } else {\n        rval.push(e);\n      }\n    }\n    return rval;\n  }\n\n  // recursively expand object:\n\n  // first, expand the active property\n  const expandedActiveProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n\n  // second, determine if any type-scoped context should be reverted; it\n  // should only be reverted when the following are all true:\n  // 1. `element` is not a value or subject reference\n  // 2. `insideIndex` is false\n  typeScopedContext = typeScopedContext ||\n    (activeCtx.previousContext ? activeCtx : null);\n  let keys = Object.keys(element).sort();\n  let mustRevert = !insideIndex;\n  if(mustRevert && typeScopedContext && keys.length <= 2 &&\n    !keys.includes('@context')) {\n    for(const key of keys) {\n      const expandedProperty = _expandIri(\n        typeScopedContext, key, {vocab: true}, options);\n      if(expandedProperty === '@value') {\n        // value found, ensure type-scoped context is used to expand it\n        mustRevert = false;\n        activeCtx = typeScopedContext;\n        break;\n      }\n      if(expandedProperty === '@id' && keys.length === 1) {\n        // subject reference found, do not revert\n        mustRevert = false;\n        break;\n      }\n    }\n  }\n\n  if(mustRevert) {\n    // revert type scoped context\n    activeCtx = activeCtx.revertTypeScopedContext();\n  }\n\n  // if element has a context, process it\n  if('@context' in element) {\n    activeCtx = _processContext(\n      {activeCtx, localCtx: element['@context'], options});\n  }\n\n  // look for scoped contexts on `@type`\n  for(const key of keys) {\n    const expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n    if(expandedProperty === '@type') {\n      // set scoped contexts from @type\n      // avoid sorting if possible\n      const value = element[key];\n      const types =\n        Array.isArray(value) ?\n          (value.length > 1 ? value.slice().sort() : value) : [value];\n      for(const type of types) {\n        const ctx = _getContextValue(\n          activeCtx.previousContext || activeCtx, type, '@context');\n        if(!_isUndefined(ctx)) {\n          activeCtx = _processContext({\n            activeCtx,\n            localCtx: ctx,\n            options,\n            isTypeScopedContext: true\n          });\n        }\n      }\n    }\n  }\n\n  // process each key and value in element, ignoring @nest content\n  let rval = {};\n  _expandObject({\n    activeCtx,\n    activeProperty,\n    expandedActiveProperty,\n    element,\n    expandedParent: rval,\n    options,\n    insideList,\n    typeScopedContext,\n    expansionMap});\n\n  // get property count on expanded output\n  keys = Object.keys(rval);\n  let count = keys.length;\n\n  if('@value' in rval) {\n    // @value must only have @language or @type\n    if('@type' in rval && '@language' in rval) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may not ' +\n        'contain both \"@type\" and \"@language\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    let validCount = count - 1;\n    if('@type' in rval) {\n      validCount -= 1;\n    }\n    if('@index' in rval) {\n      validCount -= 1;\n    }\n    if('@language' in rval) {\n      validCount -= 1;\n    }\n    if(validCount !== 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may only ' +\n        'have an \"@index\" property and at most one other property ' +\n        'which can be \"@type\" or \"@language\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    const values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n    const types = _getValues(rval, '@type');\n\n    // drop null @values unless custom mapped\n    if(values.length === 0) {\n      // TODO: use `await` to support async\n      const mapped = expansionMap({\n        unmappedValue: rval,\n        activeCtx,\n        activeProperty,\n        element,\n        options,\n        insideList\n      });\n      if(mapped !== undefined) {\n        rval = mapped;\n      } else {\n        rval = null;\n      }\n    } else if(!values.every(v => (_isString(v) || _isEmptyObject(v))) &&\n      '@language' in rval) {\n      // if @language is present, @value must be a string\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; only strings may be language-tagged.',\n        'jsonld.SyntaxError',\n        {code: 'invalid language-tagged value', element: rval});\n    } else if(_processingMode(activeCtx, 1.1) && types.includes('@json') &&\n      types.length === 1) {\n      // Any value of @value is okay if @type: @json\n    } else if(!types.every(t =>\n      (_isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) ||\n      _isEmptyObject(t)))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' +\n        'must have an absolute IRI for the value of \"@type\".',\n        'jsonld.SyntaxError', {code: 'invalid typed value', element: rval});\n    }\n  } else if('@type' in rval && !_isArray(rval['@type'])) {\n    // convert @type to an array\n    rval['@type'] = [rval['@type']];\n  } else if('@set' in rval || '@list' in rval) {\n    // handle @set and @list\n    if(count > 1 && !(count === 2 && '@index' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; if an element has the property \"@set\" ' +\n        'or \"@list\", then it can have at most one other property that is ' +\n        '\"@index\".', 'jsonld.SyntaxError',\n        {code: 'invalid set or list object', element: rval});\n    }\n    // optimize away @set\n    if('@set' in rval) {\n      rval = rval['@set'];\n      keys = Object.keys(rval);\n      count = keys.length;\n    }\n  } else if(count === 1 && '@language' in rval) {\n    // drop objects with only @language unless custom mapped\n    // TODO: use `await` to support async\n    const mapped = expansionMap(rval, {\n      unmappedValue: rval,\n      activeCtx,\n      activeProperty,\n      element,\n      options,\n      insideList\n    });\n    if(mapped !== undefined) {\n      rval = mapped;\n    } else {\n      rval = null;\n    }\n  }\n\n  // drop certain top-level objects that do not occur in lists, unless custom\n  // mapped\n  if(_isObject(rval) &&\n    !options.keepFreeFloatingNodes && !insideList &&\n    (activeProperty === null || expandedActiveProperty === '@graph')) {\n    // drop empty object, top-level @value/@list, or object with only @id\n    if(count === 0 || '@value' in rval || '@list' in rval ||\n      (count === 1 && '@id' in rval)) {\n      // TODO: use `await` to support async\n      const mapped = expansionMap({\n        unmappedValue: rval,\n        activeCtx,\n        activeProperty,\n        element,\n        options,\n        insideList\n      });\n      if(mapped !== undefined) {\n        rval = mapped;\n      } else {\n        rval = null;\n      }\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n */\nfunction _expandObject({\n  activeCtx,\n  activeProperty,\n  expandedActiveProperty,\n  element,\n  expandedParent,\n  options = {},\n  insideList,\n  expansionMap\n}) {\n  const keys = Object.keys(element).sort();\n  const nests = [];\n  for(const key of keys) {\n    let value = element[key];\n    let expandedValue;\n\n    // skip @context\n    if(key === '@context') {\n      continue;\n    }\n\n    // expand property\n    let expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n\n    // drop non-absolute IRI keys that aren't keywords unless custom mapped\n    if(expandedProperty === null ||\n      !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {\n      // TODO: use `await` to support async\n      expandedProperty = expansionMap({\n        unmappedProperty: key,\n        activeCtx,\n        activeProperty,\n        parent: element,\n        options,\n        insideList,\n        value,\n        expandedParent\n      });\n      if(expandedProperty === undefined) {\n        continue;\n      }\n    }\n\n    if(_isKeyword(expandedProperty)) {\n      if(expandedActiveProperty === '@reverse') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' +\n          'property.', 'jsonld.SyntaxError',\n          {code: 'invalid reverse property map', value});\n      }\n      if(expandedProperty in expandedParent) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; colliding keywords detected.',\n          'jsonld.SyntaxError',\n          {code: 'colliding keywords', keyword: expandedProperty});\n      }\n    }\n\n    // syntax error if @id is not a string\n    if(expandedProperty === '@id') {\n      if(!_isString(value)) {\n        if(!options.isFrame) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value must a string.',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n        if(_isObject(value)) {\n          // empty object is a wildcard\n          if(!_isEmptyObject(value)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else if(_isArray(value)) {\n          if(!value.every(v => _isString(v))) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n            'of strings, if framing',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@id',\n        _asArray(value).map(v =>\n          _isString(v) ? _expandIri(activeCtx, v, {base: true}, options) : v),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    if(expandedProperty === '@type') {\n      _validateTypeValue(value);\n      _addValue(\n        expandedParent, '@type',\n        _asArray(value).map(v =>\n          _isString(v) ?\n            _expandIri(activeCtx.previousContext || activeCtx, v,\n              {base: true, vocab: true}, options) : v),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @graph must be an array or an object\n    if(expandedProperty === '@graph' &&\n      !(_isObject(value) || _isArray(value))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@graph\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError', {code: 'invalid @graph value', value});\n    }\n\n    if(expandedProperty === '@value') {\n      _addValue(\n        expandedParent, '@value', value, {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @language must be a string\n    if(expandedProperty === '@language') {\n      if(value === null) {\n        // drop null @language values, they expand as if they didn't exist\n        continue;\n      }\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@language\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language-tagged string', value});\n      }\n      // ensure language value is lowercase\n      value = _asArray(value).map(v => _isString(v) ? v.toLowerCase() : v);\n\n      _addValue(\n        expandedParent, '@language', value, {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @index must be a string\n    if(expandedProperty === '@index') {\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@index\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @index value', value});\n      }\n      _addValue(expandedParent, '@index', value);\n      continue;\n    }\n\n    // @reverse must be an object\n    if(expandedProperty === '@reverse') {\n      if(!_isObject(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@reverse\" value must be an object.',\n          'jsonld.SyntaxError', {code: 'invalid @reverse value', value});\n      }\n\n      expandedValue = api.expand({\n        activeCtx,\n        activeProperty:\n        '@reverse',\n        element: value,\n        options,\n        expansionMap\n      });\n      // properties double-reversed\n      if('@reverse' in expandedValue) {\n        for(const property in expandedValue['@reverse']) {\n          _addValue(\n            expandedParent, property, expandedValue['@reverse'][property],\n            {propertyIsArray: true});\n        }\n      }\n\n      // FIXME: can this be merged with code below to simplify?\n      // merge in all reversed properties\n      let reverseMap = expandedParent['@reverse'] || null;\n      for(const property in expandedValue) {\n        if(property === '@reverse') {\n          continue;\n        }\n        if(reverseMap === null) {\n          reverseMap = expandedParent['@reverse'] = {};\n        }\n        _addValue(reverseMap, property, [], {propertyIsArray: true});\n        const items = expandedValue[property];\n        for(let ii = 0; ii < items.length; ++ii) {\n          const item = items[ii];\n          if(_isValue(item) || _isList(item)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n              '@value or an @list.', 'jsonld.SyntaxError',\n              {code: 'invalid reverse property value', value: expandedValue});\n          }\n          _addValue(reverseMap, property, item, {propertyIsArray: true});\n        }\n      }\n\n      continue;\n    }\n\n    // nested keys\n    if(expandedProperty === '@nest') {\n      nests.push(key);\n      continue;\n    }\n\n    // use potential scoped context for key\n    let termCtx = activeCtx;\n    const ctx = _getContextValue(activeCtx, key, '@context');\n    if(!_isUndefined(ctx)) {\n      // Note: spec's `from term` var is named `isPropertyTermScopedContext`\n      termCtx = _processContext({\n        activeCtx,\n        localCtx: ctx,\n        isPropertyTermScopedContext: true,\n        options\n      });\n    }\n\n    const container = _getContextValue(termCtx, key, '@container') || [];\n\n    if(container.includes('@language') && _isObject(value)) {\n      // handle language map container (skip if value is not an object)\n      expandedValue = _expandLanguageMap(termCtx, value, options);\n    } else if(container.includes('@index') && _isObject(value)) {\n      // handle index container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      expandedValue = _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph,\n        indexKey: '@index'\n      });\n    } else if(container.includes('@id') && _isObject(value)) {\n      // handle id container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      expandedValue = _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph,\n        indexKey: '@id'\n      });\n    } else if(container.includes('@type') && _isObject(value)) {\n      // handle type container (skip if value is not an object)\n      expandedValue = _expandIndexMap({\n        // since container is `@type`, revert type scoped context when expanding\n        activeCtx: termCtx.revertTypeScopedContext(),\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph: false,\n        indexKey: '@type'\n      });\n    } else {\n      // recurse into @list or @set\n      const isList = (expandedProperty === '@list');\n      if(isList || expandedProperty === '@set') {\n        let nextActiveProperty = activeProperty;\n        if(isList && expandedActiveProperty === '@graph') {\n          nextActiveProperty = null;\n        }\n        expandedValue = api.expand({\n          activeCtx: termCtx,\n          activeProperty: nextActiveProperty,\n          element: value,\n          options,\n          insideList: isList,\n          expansionMap\n        });\n      } else if(\n        _getContextValue(activeCtx, key, '@type') === '@json') {\n        expandedValue = {\n          '@type': '@json',\n          '@value': value\n        };\n      } else {\n        // recursively expand value with key as new active property\n        expandedValue = api.expand({\n          activeCtx: termCtx,\n          activeProperty: key,\n          element: value,\n          options,\n          insideList: false,\n          expansionMap\n        });\n      }\n    }\n\n    // drop null values if property is not @value\n    if(expandedValue === null && expandedProperty !== '@value') {\n      // TODO: use `await` to support async\n      expandedValue = expansionMap({\n        unmappedValue: value,\n        expandedProperty,\n        activeCtx: termCtx,\n        activeProperty,\n        parent: element,\n        options,\n        insideList,\n        key,\n        expandedParent\n      });\n      if(expandedValue === undefined) {\n        continue;\n      }\n    }\n\n    // convert expanded value to @list if container specifies it\n    if(expandedProperty !== '@list' && !_isList(expandedValue) &&\n      container.includes('@list')) {\n      // ensure expanded value in @list is an array\n      expandedValue = {'@list': _asArray(expandedValue)};\n    }\n\n    // convert expanded value to @graph if container specifies it\n    // and value is not, itself, a graph\n    // index cases handled above\n    if(container.includes('@graph') &&\n      !container.some(key => key === '@id' || key === '@index')) {\n      // ensure expanded values are arrays\n      expandedValue = _asArray(expandedValue)\n        .map(v => _isGraph(v) ? v : {'@graph': _asArray(v)});\n    }\n\n    // FIXME: can this be merged with code above to simplify?\n    // merge in reverse properties\n    if(termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {\n      const reverseMap =\n        expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n      expandedValue = _asArray(expandedValue);\n      for(let ii = 0; ii < expandedValue.length; ++ii) {\n        const item = expandedValue[ii];\n        if(_isValue(item) || _isList(item)) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n            '@value or an @list.', 'jsonld.SyntaxError',\n            {code: 'invalid reverse property value', value: expandedValue});\n        }\n        _addValue(reverseMap, expandedProperty, item, {propertyIsArray: true});\n      }\n      continue;\n    }\n\n    // add value for property\n    // use an array except for certain keywords\n    const useArray =\n      !['@index', '@id', '@type', '@value', '@language']\n        .includes(expandedProperty);\n    _addValue(expandedParent, expandedProperty, expandedValue, {\n      propertyIsArray: useArray\n    });\n  }\n\n  // @value must not be an object or an array (unless framing) or if @type is\n  // @json\n  if('@value' in element) {\n    const value = element['@value'];\n    if(element['@type'] === '@json' && _processingMode(activeCtx, 1.1)) {\n      // allow any value, to be verified when the object is fully expanded and\n      // the @type is @json.\n    } else if((_isObject(value) || _isArray(value)) && !options.isFrame) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@value\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError',\n        {code: 'invalid value object value', value});\n    }\n  }\n\n  // expand each nested key\n  for(const key of nests) {\n    const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];\n    for(const nv of nestedValues) {\n      if(!_isObject(nv) || Object.keys(nv).some(k =>\n        _expandIri(activeCtx, k, {vocab: true}, options) === '@value')) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; nested value must be a node object.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @nest value', value: nv});\n      }\n      _expandObject({\n        activeCtx,\n        activeProperty,\n        expandedActiveProperty,\n        element: nv,\n        expandedParent,\n        options,\n        insideList,\n        expansionMap});\n    }\n  }\n}\n\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandValue({activeCtx, activeProperty, value, options}) {\n  // nothing to expand\n  if(value === null || value === undefined) {\n    return null;\n  }\n\n  // special-case expand @id and @type (skips '@id' expansion)\n  const expandedProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n  if(expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {base: true}, options);\n  } else if(expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {vocab: true, base: true}, options);\n  }\n\n  // get type definition from context\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  // do @id expansion (automatic for @graph)\n  if((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    return {'@id': _expandIri(activeCtx, value, {base: true}, options)};\n  }\n  // do @id expansion w/vocab\n  if(type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {vocab: true, base: true}, options)\n    };\n  }\n\n  // do not expand keyword values\n  if(_isKeyword(expandedProperty)) {\n    return value;\n  }\n\n  const rval = {};\n\n  if(type && !['@id', '@vocab'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if(_isString(value)) {\n    // check for language tagging for strings\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    if(language !== null) {\n      rval['@language'] = language;\n    }\n  }\n  // do conversion of values that aren't basic JSON types to strings\n  if(!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n  rval['@value'] = value;\n\n  return rval;\n}\n\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\nfunction _expandLanguageMap(activeCtx, languageMap, options) {\n  const rval = [];\n  const keys = Object.keys(languageMap).sort();\n  for(const key of keys) {\n    const expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    let val = languageMap[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n    for(const item of val) {\n      if(item === null) {\n        // null values are allowed (8.5) but ignored (3.1)\n        continue;\n      }\n      if(!_isString(item)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; language map values must be strings.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language map value', languageMap});\n      }\n      const val = {'@value': item};\n      if(expandedKey !== '@none') {\n        val['@language'] = key.toLowerCase();\n      }\n      rval.push(val);\n    }\n  }\n  return rval;\n}\n\nfunction _expandIndexMap(\n  {activeCtx, options, activeProperty, value, expansionMap, asGraph,\n    indexKey}) {\n  const rval = [];\n  const keys = Object.keys(value).sort();\n  const isTypeIndex = indexKey === '@type';\n  for(let key of keys) {\n    // if indexKey is @type, there may be a context defined for it\n    if(isTypeIndex) {\n      const ctx = _getContextValue(activeCtx, key, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = _processContext({\n          activeCtx,\n          localCtx: ctx,\n          isTypeScopedContext: true,\n          options\n        });\n      }\n    }\n\n    let val = value[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n\n    // expand for @type, but also for @none\n    const expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    if(indexKey === '@id') {\n      // expand document relative\n      key = _expandIri(activeCtx, key, {base: true}, options);\n    } else if(isTypeIndex) {\n      key = expandedKey;\n    }\n\n    val = api.expand({\n      activeCtx,\n      activeProperty,\n      element: val,\n      options,\n      insideList: false,\n      insideIndex: true,\n      expansionMap\n    });\n    for(let item of val) {\n      // If this is also a @graph container, turn items into graphs\n      if(asGraph && !_isGraph(item)) {\n        item = {'@graph': [item]};\n      }\n      if(indexKey === '@type') {\n        if(expandedKey === '@none') {\n          // ignore @none\n        } else if(item['@type']) {\n          item['@type'] = [key].concat(item['@type']);\n        } else {\n          item['@type'] = [key];\n        }\n      } else if(expandedKey !== '@none' && !(indexKey in item)) {\n        item[indexKey] = key;\n      }\n      rval.push(item);\n    }\n  }\n  return rval;\n}\n"]},"metadata":{},"sourceType":"script"}