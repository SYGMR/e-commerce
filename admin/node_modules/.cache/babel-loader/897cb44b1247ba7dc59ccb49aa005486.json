{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Guillaume\\\\Code\\\\e-commerce\\\\admin\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar JsonLdError = require('./JsonLdError');\n\nvar graphTypes = require('./graphTypes');\n\nvar types = require('./types');\n\nvar util = require('./util'); // constants\n\n\nvar _require = require('./constants'),\n    RDF_LIST = _require.RDF_LIST,\n    RDF_FIRST = _require.RDF_FIRST,\n    RDF_REST = _require.RDF_REST,\n    RDF_NIL = _require.RDF_NIL,\n    RDF_TYPE = _require.RDF_TYPE,\n    RDF_JSON_LITERAL = _require.RDF_JSON_LITERAL,\n    XSD_BOOLEAN = _require.XSD_BOOLEAN,\n    XSD_DOUBLE = _require.XSD_DOUBLE,\n    XSD_INTEGER = _require.XSD_INTEGER,\n    XSD_STRING = _require.XSD_STRING;\n\nvar api = {};\nmodule.exports = api;\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset the RDF dataset.\n * @param options the RDF serialization options.\n *\n * @return a Promise that resolves to the JSON-LD output.\n */\n\napi.fromRDF = function _callee(dataset, _ref) {\n  var _ref$useRdfType, useRdfType, _ref$useNativeTypes, useNativeTypes, defaultGraph, graphMap, referencedOnce, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, quad, _name, nodeMap, s, p, o, _node, objectIsNode, value, object, name, graphObject, nil, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, usage, node, property, head, list, listNodes, nodeKeyCount, _i, _listNodes, listNode, result, subjects, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, subject, _node2, graph, _graphObject, graphSubjects, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, graphSubject, _node3;\n\n  return _regeneratorRuntime.async(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _ref$useRdfType = _ref.useRdfType, useRdfType = _ref$useRdfType === void 0 ? false : _ref$useRdfType, _ref$useNativeTypes = _ref.useNativeTypes, useNativeTypes = _ref$useNativeTypes === void 0 ? false : _ref$useNativeTypes;\n          defaultGraph = {};\n          graphMap = {\n            '@default': defaultGraph\n          };\n          referencedOnce = {};\n          _iteratorNormalCompletion = true;\n          _didIteratorError = false;\n          _iteratorError = undefined;\n          _context.prev = 7;\n          _iterator = dataset[Symbol.iterator]();\n\n        case 9:\n          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n            _context.next = 31;\n            break;\n          }\n\n          quad = _step.value;\n          // TODO: change 'name' to 'graph'\n          _name = quad.graph.termType === 'DefaultGraph' ? '@default' : quad.graph.value;\n\n          if (!(_name in graphMap)) {\n            graphMap[_name] = {};\n          }\n\n          if (_name !== '@default' && !(_name in defaultGraph)) {\n            defaultGraph[_name] = {\n              '@id': _name\n            };\n          }\n\n          nodeMap = graphMap[_name]; // get subject, predicate, object\n\n          s = quad.subject.value;\n          p = quad.predicate.value;\n          o = quad.object;\n\n          if (!(s in nodeMap)) {\n            nodeMap[s] = {\n              '@id': s\n            };\n          }\n\n          _node = nodeMap[s];\n          objectIsNode = o.termType.endsWith('Node');\n\n          if (objectIsNode && !(o.value in nodeMap)) {\n            nodeMap[o.value] = {\n              '@id': o.value\n            };\n          }\n\n          if (!(p === RDF_TYPE && !useRdfType && objectIsNode)) {\n            _context.next = 25;\n            break;\n          }\n\n          util.addValue(_node, '@type', o.value, {\n            propertyIsArray: true\n          });\n          return _context.abrupt(\"continue\", 28);\n\n        case 25:\n          value = _RDFToObject(o, useNativeTypes);\n          util.addValue(_node, p, value, {\n            propertyIsArray: true\n          }); // object may be an RDF list/partial list node but we can't know easily\n          // until all triples are read\n\n          if (objectIsNode) {\n            if (o.value === RDF_NIL) {\n              // track rdf:nil uniquely per graph\n              object = nodeMap[o.value];\n\n              if (!('usages' in object)) {\n                object.usages = [];\n              }\n\n              object.usages.push({\n                node: _node,\n                property: p,\n                value: value\n              });\n            } else if (o.value in referencedOnce) {\n              // object referenced more than once\n              referencedOnce[o.value] = false;\n            } else {\n              // keep track of single reference\n              referencedOnce[o.value] = {\n                node: _node,\n                property: p,\n                value: value\n              };\n            }\n          }\n\n        case 28:\n          _iteratorNormalCompletion = true;\n          _context.next = 9;\n          break;\n\n        case 31:\n          _context.next = 37;\n          break;\n\n        case 33:\n          _context.prev = 33;\n          _context.t0 = _context[\"catch\"](7);\n          _didIteratorError = true;\n          _iteratorError = _context.t0;\n\n        case 37:\n          _context.prev = 37;\n          _context.prev = 38;\n\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n\n        case 40:\n          _context.prev = 40;\n\n          if (!_didIteratorError) {\n            _context.next = 43;\n            break;\n          }\n\n          throw _iteratorError;\n\n        case 43:\n          return _context.finish(40);\n\n        case 44:\n          return _context.finish(37);\n\n        case 45:\n          _context.t1 = _regeneratorRuntime.keys(graphMap);\n\n        case 46:\n          if ((_context.t2 = _context.t1()).done) {\n            _context.next = 102;\n            break;\n          }\n\n          name = _context.t2.value;\n          graphObject = graphMap[name]; // no @lists to be converted, continue\n\n          if (RDF_NIL in graphObject) {\n            _context.next = 51;\n            break;\n          }\n\n          return _context.abrupt(\"continue\", 46);\n\n        case 51:\n          // iterate backwards through each RDF list\n          nil = graphObject[RDF_NIL];\n\n          if (nil.usages) {\n            _context.next = 54;\n            break;\n          }\n\n          return _context.abrupt(\"continue\", 46);\n\n        case 54:\n          _iteratorNormalCompletion2 = true;\n          _didIteratorError2 = false;\n          _iteratorError2 = undefined;\n          _context.prev = 57;\n          _iterator2 = nil.usages[Symbol.iterator]();\n\n        case 59:\n          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n            _context.next = 85;\n            break;\n          }\n\n          usage = _step2.value;\n          node = usage.node;\n          property = usage.property;\n          head = usage.value;\n          list = [];\n          listNodes = []; // ensure node is a well-formed list node; it must:\n          // 1. Be referenced only once.\n          // 2. Have an array for rdf:first that has 1 item.\n          // 3. Have an array for rdf:rest that has 1 item.\n          // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,\n          //   optionally, @type where the value is rdf:List.\n\n          nodeKeyCount = Object.keys(node).length;\n\n        case 67:\n          if (!(property === RDF_REST && types.isObject(referencedOnce[node['@id']]) && types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 && types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 && (nodeKeyCount === 3 || nodeKeyCount === 4 && types.isArray(node['@type']) && node['@type'].length === 1 && node['@type'][0] === RDF_LIST))) {\n            _context.next = 79;\n            break;\n          }\n\n          list.push(node[RDF_FIRST][0]);\n          listNodes.push(node['@id']); // get next node, moving backwards through list\n\n          usage = referencedOnce[node['@id']];\n          node = usage.node;\n          property = usage.property;\n          head = usage.value;\n          nodeKeyCount = Object.keys(node).length; // if node is not a blank node, then list head found\n\n          if (graphTypes.isBlankNode(node)) {\n            _context.next = 77;\n            break;\n          }\n\n          return _context.abrupt(\"break\", 79);\n\n        case 77:\n          _context.next = 67;\n          break;\n\n        case 79:\n          // transform list into @list object\n          delete head['@id'];\n          head['@list'] = list.reverse();\n\n          for (_i = 0, _listNodes = listNodes; _i < _listNodes.length; _i++) {\n            listNode = _listNodes[_i];\n            delete graphObject[listNode];\n          }\n\n        case 82:\n          _iteratorNormalCompletion2 = true;\n          _context.next = 59;\n          break;\n\n        case 85:\n          _context.next = 91;\n          break;\n\n        case 87:\n          _context.prev = 87;\n          _context.t3 = _context[\"catch\"](57);\n          _didIteratorError2 = true;\n          _iteratorError2 = _context.t3;\n\n        case 91:\n          _context.prev = 91;\n          _context.prev = 92;\n\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n\n        case 94:\n          _context.prev = 94;\n\n          if (!_didIteratorError2) {\n            _context.next = 97;\n            break;\n          }\n\n          throw _iteratorError2;\n\n        case 97:\n          return _context.finish(94);\n\n        case 98:\n          return _context.finish(91);\n\n        case 99:\n          delete nil.usages;\n          _context.next = 46;\n          break;\n\n        case 102:\n          result = [];\n          subjects = Object.keys(defaultGraph).sort();\n          _iteratorNormalCompletion3 = true;\n          _didIteratorError3 = false;\n          _iteratorError3 = undefined;\n          _context.prev = 107;\n          _iterator3 = subjects[Symbol.iterator]();\n\n        case 109:\n          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n            _context.next = 139;\n            break;\n          }\n\n          subject = _step3.value;\n          _node2 = defaultGraph[subject];\n\n          if (!(subject in graphMap)) {\n            _context.next = 135;\n            break;\n          }\n\n          graph = _node2['@graph'] = [];\n          _graphObject = graphMap[subject];\n          graphSubjects = Object.keys(_graphObject).sort();\n          _iteratorNormalCompletion4 = true;\n          _didIteratorError4 = false;\n          _iteratorError4 = undefined;\n          _context.prev = 119;\n\n          for (_iterator4 = graphSubjects[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            graphSubject = _step4.value;\n            _node3 = _graphObject[graphSubject]; // only add full subjects to top-level\n\n            if (!graphTypes.isSubjectReference(_node3)) {\n              graph.push(_node3);\n            }\n          }\n\n          _context.next = 127;\n          break;\n\n        case 123:\n          _context.prev = 123;\n          _context.t4 = _context[\"catch\"](119);\n          _didIteratorError4 = true;\n          _iteratorError4 = _context.t4;\n\n        case 127:\n          _context.prev = 127;\n          _context.prev = 128;\n\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n\n        case 130:\n          _context.prev = 130;\n\n          if (!_didIteratorError4) {\n            _context.next = 133;\n            break;\n          }\n\n          throw _iteratorError4;\n\n        case 133:\n          return _context.finish(130);\n\n        case 134:\n          return _context.finish(127);\n\n        case 135:\n          // only add full subjects to top-level\n          if (!graphTypes.isSubjectReference(_node2)) {\n            result.push(_node2);\n          }\n\n        case 136:\n          _iteratorNormalCompletion3 = true;\n          _context.next = 109;\n          break;\n\n        case 139:\n          _context.next = 145;\n          break;\n\n        case 141:\n          _context.prev = 141;\n          _context.t5 = _context[\"catch\"](107);\n          _didIteratorError3 = true;\n          _iteratorError3 = _context.t5;\n\n        case 145:\n          _context.prev = 145;\n          _context.prev = 146;\n\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n\n        case 148:\n          _context.prev = 148;\n\n          if (!_didIteratorError3) {\n            _context.next = 151;\n            break;\n          }\n\n          throw _iteratorError3;\n\n        case 151:\n          return _context.finish(148);\n\n        case 152:\n          return _context.finish(145);\n\n        case 153:\n          return _context.abrupt(\"return\", result);\n\n        case 154:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[7, 33, 37, 45], [38,, 40, 44], [57, 87, 91, 99], [92,, 94, 98], [107, 141, 145, 153], [119, 123, 127, 135], [128,, 130, 134], [146,, 148, 152]]);\n};\n/**\n * Converts an RDF triple object to a JSON-LD object.\n *\n * @param o the RDF triple object to convert.\n * @param useNativeTypes true to output native types, false not to.\n *\n * @return the JSON-LD object.\n */\n\n\nfunction _RDFToObject(o, useNativeTypes) {\n  // convert NamedNode/BlankNode object to JSON-LD\n  if (o.termType.endsWith('Node')) {\n    return {\n      '@id': o.value\n    };\n  } // convert literal to JSON-LD\n\n\n  var rval = {\n    '@value': o.value\n  }; // add language\n\n  if (o.language) {\n    rval['@language'] = o.language;\n  } else {\n    var type = o.datatype.value;\n\n    if (!type) {\n      type = XSD_STRING;\n    }\n\n    if (type === RDF_JSON_LITERAL) {\n      type = '@json';\n\n      try {\n        rval['@value'] = JSON.parse(rval['@value']);\n      } catch (e) {\n        throw new JsonLdError('JSON literal could not be parsed.', 'jsonld.InvalidJsonLiteral', {\n          code: 'invalid JSON literal',\n          value: rval['@value'],\n          cause: e\n        });\n      }\n    } // use native types for certain xsd types\n\n\n    if (useNativeTypes) {\n      if (type === XSD_BOOLEAN) {\n        if (rval['@value'] === 'true') {\n          rval['@value'] = true;\n        } else if (rval['@value'] === 'false') {\n          rval['@value'] = false;\n        }\n      } else if (types.isNumeric(rval['@value'])) {\n        if (type === XSD_INTEGER) {\n          var i = parseInt(rval['@value'], 10);\n\n          if (i.toFixed(0) === rval['@value']) {\n            rval['@value'] = i;\n          }\n        } else if (type === XSD_DOUBLE) {\n          rval['@value'] = parseFloat(rval['@value']);\n        }\n      } // do not add native type\n\n\n      if (![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {\n        rval['@type'] = type;\n      }\n    } else if (type !== XSD_STRING) {\n      rval['@type'] = type;\n    }\n  }\n\n  return rval;\n}","map":{"version":3,"sources":["C:/Users/Guillaume/Code/e-commerce/admin/node_modules/jsonld/lib/fromRdf.js"],"names":["JsonLdError","require","graphTypes","types","util","RDF_LIST","RDF_FIRST","RDF_REST","RDF_NIL","RDF_TYPE","RDF_JSON_LITERAL","XSD_BOOLEAN","XSD_DOUBLE","XSD_INTEGER","XSD_STRING","api","module","exports","fromRDF","dataset","useRdfType","useNativeTypes","defaultGraph","graphMap","referencedOnce","quad","name","graph","termType","value","nodeMap","s","subject","p","predicate","o","object","node","objectIsNode","endsWith","addValue","propertyIsArray","_RDFToObject","usages","push","property","graphObject","nil","usage","head","list","listNodes","nodeKeyCount","Object","keys","length","isObject","isArray","isBlankNode","reverse","listNode","result","subjects","sort","graphSubjects","graphSubject","isSubjectReference","rval","language","type","datatype","JSON","parse","e","code","cause","isNumeric","i","parseInt","toFixed","parseFloat","includes"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\nconst util = require('./util');\n\n// constants\nconst {\n  // RDF,\n  RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  // RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = require('./constants');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset the RDF dataset.\n * @param options the RDF serialization options.\n *\n * @return a Promise that resolves to the JSON-LD output.\n */\napi.fromRDF = async (\n  dataset, {useRdfType = false, useNativeTypes = false}) => {\n  const defaultGraph = {};\n  const graphMap = {'@default': defaultGraph};\n  const referencedOnce = {};\n\n  for(const quad of dataset) {\n    // TODO: change 'name' to 'graph'\n    const name = (quad.graph.termType === 'DefaultGraph') ?\n      '@default' : quad.graph.value;\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n\n    const nodeMap = graphMap[name];\n\n    // get subject, predicate, object\n    const s = quad.subject.value;\n    const p = quad.predicate.value;\n    const o = quad.object;\n\n    if(!(s in nodeMap)) {\n      nodeMap[s] = {'@id': s};\n    }\n    const node = nodeMap[s];\n\n    const objectIsNode = o.termType.endsWith('Node');\n    if(objectIsNode && !(o.value in nodeMap)) {\n      nodeMap[o.value] = {'@id': o.value};\n    }\n\n    if(p === RDF_TYPE && !useRdfType && objectIsNode) {\n      util.addValue(node, '@type', o.value, {propertyIsArray: true});\n      continue;\n    }\n\n    const value = _RDFToObject(o, useNativeTypes);\n    util.addValue(node, p, value, {propertyIsArray: true});\n\n    // object may be an RDF list/partial list node but we can't know easily\n    // until all triples are read\n    if(objectIsNode) {\n      if(o.value === RDF_NIL) {\n        // track rdf:nil uniquely per graph\n        const object = nodeMap[o.value];\n        if(!('usages' in object)) {\n          object.usages = [];\n        }\n        object.usages.push({\n          node,\n          property: p,\n          value\n        });\n      } else if(o.value in referencedOnce) {\n        // object referenced more than once\n        referencedOnce[o.value] = false;\n      } else {\n        // keep track of single reference\n        referencedOnce[o.value] = {\n          node,\n          property: p,\n          value\n        };\n      }\n    }\n  }\n\n  /*\n  for(let name in dataset) {\n    const graph = dataset[name];\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n    const nodeMap = graphMap[name];\n    for(let ti = 0; ti < graph.length; ++ti) {\n      const triple = graph[ti];\n\n      // get subject, predicate, object\n      const s = triple.subject.value;\n      const p = triple.predicate.value;\n      const o = triple.object;\n\n      if(!(s in nodeMap)) {\n        nodeMap[s] = {'@id': s};\n      }\n      const node = nodeMap[s];\n\n      const objectIsId = (o.type === 'IRI' || o.type === 'blank node');\n      if(objectIsId && !(o.value in nodeMap)) {\n        nodeMap[o.value] = {'@id': o.value};\n      }\n\n      if(p === RDF_TYPE && !useRdfType && objectIsId) {\n        util.addValue(node, '@type', o.value, {propertyIsArray: true});\n        continue;\n      }\n\n      const value = _RDFToObject(o, useNativeTypes);\n      util.addValue(node, p, value, {propertyIsArray: true});\n\n      // object may be an RDF list/partial list node but we can't know easily\n      // until all triples are read\n      if(objectIsId) {\n        if(o.value === RDF_NIL) {\n          // track rdf:nil uniquely per graph\n          const object = nodeMap[o.value];\n          if(!('usages' in object)) {\n            object.usages = [];\n          }\n          object.usages.push({\n            node: node,\n            property: p,\n            value: value\n          });\n        } else if(o.value in referencedOnce) {\n          // object referenced more than once\n          referencedOnce[o.value] = false;\n        } else {\n          // keep track of single reference\n          referencedOnce[o.value] = {\n            node: node,\n            property: p,\n            value: value\n          };\n        }\n      }\n    }\n  }*/\n\n  // convert linked lists to @list arrays\n  for(const name in graphMap) {\n    const graphObject = graphMap[name];\n\n    // no @lists to be converted, continue\n    if(!(RDF_NIL in graphObject)) {\n      continue;\n    }\n\n    // iterate backwards through each RDF list\n    const nil = graphObject[RDF_NIL];\n    if(!nil.usages) {\n      continue;\n    }\n    for(let usage of nil.usages) {\n      let node = usage.node;\n      let property = usage.property;\n      let head = usage.value;\n      const list = [];\n      const listNodes = [];\n\n      // ensure node is a well-formed list node; it must:\n      // 1. Be referenced only once.\n      // 2. Have an array for rdf:first that has 1 item.\n      // 3. Have an array for rdf:rest that has 1 item.\n      // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,\n      //   optionally, @type where the value is rdf:List.\n      let nodeKeyCount = Object.keys(node).length;\n      while(property === RDF_REST &&\n        types.isObject(referencedOnce[node['@id']]) &&\n        types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 &&\n        types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 &&\n        (nodeKeyCount === 3 ||\n          (nodeKeyCount === 4 && types.isArray(node['@type']) &&\n          node['@type'].length === 1 && node['@type'][0] === RDF_LIST))) {\n        list.push(node[RDF_FIRST][0]);\n        listNodes.push(node['@id']);\n\n        // get next node, moving backwards through list\n        usage = referencedOnce[node['@id']];\n        node = usage.node;\n        property = usage.property;\n        head = usage.value;\n        nodeKeyCount = Object.keys(node).length;\n\n        // if node is not a blank node, then list head found\n        if(!graphTypes.isBlankNode(node)) {\n          break;\n        }\n      }\n\n      // transform list into @list object\n      delete head['@id'];\n      head['@list'] = list.reverse();\n      for(const listNode of listNodes) {\n        delete graphObject[listNode];\n      }\n    }\n\n    delete nil.usages;\n  }\n\n  const result = [];\n  const subjects = Object.keys(defaultGraph).sort();\n  for(const subject of subjects) {\n    const node = defaultGraph[subject];\n    if(subject in graphMap) {\n      const graph = node['@graph'] = [];\n      const graphObject = graphMap[subject];\n      const graphSubjects = Object.keys(graphObject).sort();\n      for(const graphSubject of graphSubjects) {\n        const node = graphObject[graphSubject];\n        // only add full subjects to top-level\n        if(!graphTypes.isSubjectReference(node)) {\n          graph.push(node);\n        }\n      }\n    }\n    // only add full subjects to top-level\n    if(!graphTypes.isSubjectReference(node)) {\n      result.push(node);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Converts an RDF triple object to a JSON-LD object.\n *\n * @param o the RDF triple object to convert.\n * @param useNativeTypes true to output native types, false not to.\n *\n * @return the JSON-LD object.\n */\nfunction _RDFToObject(o, useNativeTypes) {\n  // convert NamedNode/BlankNode object to JSON-LD\n  if(o.termType.endsWith('Node')) {\n    return {'@id': o.value};\n  }\n\n  // convert literal to JSON-LD\n  const rval = {'@value': o.value};\n\n  // add language\n  if(o.language) {\n    rval['@language'] = o.language;\n  } else {\n    let type = o.datatype.value;\n    if(!type) {\n      type = XSD_STRING;\n    }\n    if(type === RDF_JSON_LITERAL) {\n      type = '@json';\n      try {\n        rval['@value'] = JSON.parse(rval['@value']);\n      } catch(e) {\n        throw new JsonLdError(\n          'JSON literal could not be parsed.',\n          'jsonld.InvalidJsonLiteral',\n          {code: 'invalid JSON literal', value: rval['@value'], cause: e});\n      }\n    }\n    // use native types for certain xsd types\n    if(useNativeTypes) {\n      if(type === XSD_BOOLEAN) {\n        if(rval['@value'] === 'true') {\n          rval['@value'] = true;\n        } else if(rval['@value'] === 'false') {\n          rval['@value'] = false;\n        }\n      } else if(types.isNumeric(rval['@value'])) {\n        if(type === XSD_INTEGER) {\n          const i = parseInt(rval['@value'], 10);\n          if(i.toFixed(0) === rval['@value']) {\n            rval['@value'] = i;\n          }\n        } else if(type === XSD_DOUBLE) {\n          rval['@value'] = parseFloat(rval['@value']);\n        }\n      }\n      // do not add native type\n      if(![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {\n        rval['@type'] = type;\n      }\n    } else if(type !== XSD_STRING) {\n      rval['@type'] = type;\n    }\n  }\n\n  return rval;\n}\n"]},"metadata":{},"sourceType":"script"}