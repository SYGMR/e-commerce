{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Guillaume\\\\Code\\\\e-commerce\\\\admin\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Guillaume\\\\Code\\\\e-commerce\\\\admin\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar graphTypes = require('./graphTypes');\n\nvar types = require('./types'); // TODO: move `IdentifierIssuer` to its own package\n\n\nvar IdentifierIssuer = require('rdf-canonize').IdentifierIssuer;\n\nvar JsonLdError = require('./JsonLdError'); // constants\n\n\nvar REGEX_LINK_HEADERS = /(?:<[^>]*?>|\"[^\"]*?\"|[^,])+/g;\nvar REGEX_LINK_HEADER = /\\s*<([^>]*?)>\\s*(?:;\\s*(.*))?/;\nvar REGEX_LINK_HEADER_PARAMS = /(.*?)=(?:(?:\"([^\"]*?)\")|([^\"]*?))\\s*(?:(?:;\\s*)|$)/g;\nvar DEFAULTS = {\n  headers: {\n    accept: 'application/ld+json, application/json'\n  }\n};\nvar api = {};\nmodule.exports = api;\napi.IdentifierIssuer = IdentifierIssuer; // define setImmediate and nextTick\n// // nextTick implementation with browser-compatible fallback // //\n// from https://github.com/caolan/async/blob/master/lib/async.js\n// capture the global reference to guard against fakeTimer mocks\n\nvar _setImmediate = typeof setImmediate === 'function' && setImmediate;\n\nvar _delay = _setImmediate ? // not a direct alias (for IE10 compatibility)\nfunction (fn) {\n  return _setImmediate(fn);\n} : function (fn) {\n  return setTimeout(fn, 0);\n};\n\nif (typeof process === 'object' && typeof process.nextTick === 'function') {\n  api.nextTick = process.nextTick;\n} else {\n  api.nextTick = _delay;\n}\n\napi.setImmediate = _setImmediate ? _delay : api.nextTick;\n/**\n * Clones an object, array, Map, Set, or string/number. If a typed JavaScript\n * object is given, such as a Date, it will be converted to a string.\n *\n * @param value the value to clone.\n *\n * @return the cloned value.\n */\n\napi.clone = function (value) {\n  if (value && typeof value === 'object') {\n    var rval;\n\n    if (types.isArray(value)) {\n      rval = [];\n\n      for (var i = 0; i < value.length; ++i) {\n        rval[i] = api.clone(value[i]);\n      }\n    } else if (value instanceof Map) {\n      rval = new Map();\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref3 = _step.value;\n\n          var _ref2 = _slicedToArray(_ref3, 2);\n\n          var k = _ref2[0];\n          var v = _ref2[1];\n          rval.set(k, api.clone(v));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } else if (value instanceof Set) {\n      rval = new Set();\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _v = _step2.value;\n          rval.add(api.clone(_v));\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    } else if (types.isObject(value)) {\n      rval = {};\n\n      for (var key in value) {\n        rval[key] = api.clone(value[key]);\n      }\n    } else {\n      rval = value.toString();\n    }\n\n    return rval;\n  }\n\n  return value;\n};\n/**\n * Ensure a value is an array. If the value is an array, it is returned.\n * Otherwise, it is wrapped in an array.\n *\n * @param value the value to return as an array.\n *\n * @return the value as an array.\n */\n\n\napi.asArray = function (value) {\n  return Array.isArray(value) ? value : [value];\n};\n/**\n * Builds an HTTP headers object for making a JSON-LD request from custom\n * headers and asserts the `accept` header isn't overridden.\n *\n * @param headers an object of headers with keys as header names and values\n *          as header values.\n *\n * @return an object of headers with a valid `accept` header.\n */\n\n\napi.buildHeaders = function () {\n  var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var hasAccept = Object.keys(headers).some(function (h) {\n    return h.toLowerCase() === 'accept';\n  });\n\n  if (hasAccept) {\n    throw new RangeError('Accept header may not be specified; only \"' + DEFAULTS.headers.accept + '\" is supported.');\n  }\n\n  return Object.assign({\n    Accept: DEFAULTS.headers.accept\n  }, headers);\n};\n/**\n * Parses a link header. The results will be key'd by the value of \"rel\".\n *\n * Link: <http://json-ld.org/contexts/person.jsonld>;\n * rel=\"http://www.w3.org/ns/json-ld#context\"; type=\"application/ld+json\"\n *\n * Parses as: {\n *   'http://www.w3.org/ns/json-ld#context': {\n *     target: http://json-ld.org/contexts/person.jsonld,\n *     type: 'application/ld+json'\n *   }\n * }\n *\n * If there is more than one \"rel\" with the same IRI, then entries in the\n * resulting map for that \"rel\" will be arrays.\n *\n * @param header the link header to parse.\n */\n\n\napi.parseLinkHeader = function (header) {\n  var rval = {}; // split on unbracketed/unquoted commas\n\n  var entries = header.match(REGEX_LINK_HEADERS);\n\n  for (var i = 0; i < entries.length; ++i) {\n    var match = entries[i].match(REGEX_LINK_HEADER);\n\n    if (!match) {\n      continue;\n    }\n\n    var result = {\n      target: match[1]\n    };\n    var params = match[2];\n\n    while (match = REGEX_LINK_HEADER_PARAMS.exec(params)) {\n      result[match[1]] = match[2] === undefined ? match[3] : match[2];\n    }\n\n    var rel = result['rel'] || '';\n\n    if (Array.isArray(rval[rel])) {\n      rval[rel].push(result);\n    } else if (rval.hasOwnProperty(rel)) {\n      rval[rel] = [rval[rel], result];\n    } else {\n      rval[rel] = result;\n    }\n  }\n\n  return rval;\n};\n/**\n * Throws an exception if the given value is not a valid @type value.\n *\n * @param v the value to check.\n */\n\n\napi.validateTypeValue = function (v) {\n  // can be a string or an empty object\n  if (types.isString(v) || types.isEmptyObject(v)) {\n    return;\n  } // must be an array\n\n\n  var isValid = false;\n\n  if (types.isArray(v)) {\n    // must contain only strings\n    isValid = true;\n\n    for (var i = 0; i < v.length; ++i) {\n      if (!types.isString(v[i])) {\n        isValid = false;\n        break;\n      }\n    }\n  }\n\n  if (!isValid) {\n    throw new JsonLdError('Invalid JSON-LD syntax; \"@type\" value must a string, an array of ' + 'strings, or an empty object.', 'jsonld.SyntaxError', {\n      code: 'invalid type value',\n      value: v\n    });\n  }\n};\n/**\n * Returns true if the given subject has the given property.\n *\n * @param subject the subject to check.\n * @param property the property to look for.\n *\n * @return true if the subject has the given property, false if not.\n */\n\n\napi.hasProperty = function (subject, property) {\n  if (subject.hasOwnProperty(property)) {\n    var value = subject[property];\n    return !types.isArray(value) || value.length > 0;\n  }\n\n  return false;\n};\n/**\n * Determines if the given value is a property of the given subject.\n *\n * @param subject the subject to check.\n * @param property the property to check.\n * @param value the value to check.\n *\n * @return true if the value exists, false if not.\n */\n\n\napi.hasValue = function (subject, property, value) {\n  if (api.hasProperty(subject, property)) {\n    var val = subject[property];\n    var isList = graphTypes.isList(val);\n\n    if (types.isArray(val) || isList) {\n      if (isList) {\n        val = val['@list'];\n      }\n\n      for (var i = 0; i < val.length; ++i) {\n        if (api.compareValues(value, val[i])) {\n          return true;\n        }\n      }\n    } else if (!types.isArray(value)) {\n      // avoid matching the set of values with an array value parameter\n      return api.compareValues(value, val);\n    }\n  }\n\n  return false;\n};\n/**\n * Adds a value to a subject. If the value is an array, all values in the\n * array will be added.\n *\n * @param subject the subject to add the value to.\n * @param property the property that relates the value to the subject.\n * @param value the value to add.\n * @param [options] the options to use:\n *        [propertyIsArray] true if the property is always an array, false\n *          if not (default: false).\n *        [valueIsArray] true if the value to be added should be preserved as\n *          an array (lists) (default: false).\n *        [allowDuplicate] true to allow duplicates, false not to (uses a\n *          simple shallow comparison of subject ID or value) (default: true).\n */\n\n\napi.addValue = function (subject, property, value, options) {\n  options = options || {};\n\n  if (!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n\n  if (!('valueIsArray' in options)) {\n    options.valueIsArray = false;\n  }\n\n  if (!('allowDuplicate' in options)) {\n    options.allowDuplicate = true;\n  }\n\n  if (options.valueIsArray) {\n    subject[property] = value;\n  } else if (types.isArray(value)) {\n    if (value.length === 0 && options.propertyIsArray && !subject.hasOwnProperty(property)) {\n      subject[property] = [];\n    }\n\n    for (var i = 0; i < value.length; ++i) {\n      api.addValue(subject, property, value[i], options);\n    }\n  } else if (subject.hasOwnProperty(property)) {\n    // check if subject already has value if duplicates not allowed\n    var hasValue = !options.allowDuplicate && api.hasValue(subject, property, value); // make property an array if value not present or always an array\n\n    if (!types.isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {\n      subject[property] = [subject[property]];\n    } // add new value\n\n\n    if (!hasValue) {\n      subject[property].push(value);\n    }\n  } else {\n    // add new value as set or single value\n    subject[property] = options.propertyIsArray ? [value] : value;\n  }\n};\n/**\n * Gets all of the values for a subject's property as an array.\n *\n * @param subject the subject.\n * @param property the property.\n *\n * @return all of the values for a subject's property as an array.\n */\n\n\napi.getValues = function (subject, property) {\n  return [].concat(subject[property] || []);\n};\n/**\n * Removes a property from a subject.\n *\n * @param subject the subject.\n * @param property the property.\n */\n\n\napi.removeProperty = function (subject, property) {\n  delete subject[property];\n};\n/**\n * Removes a value from a subject.\n *\n * @param subject the subject.\n * @param property the property that relates the value to the subject.\n * @param value the value to remove.\n * @param [options] the options to use:\n *          [propertyIsArray] true if the property is always an array, false\n *            if not (default: false).\n */\n\n\napi.removeValue = function (subject, property, value, options) {\n  options = options || {};\n\n  if (!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  } // filter out value\n\n\n  var values = api.getValues(subject, property).filter(function (e) {\n    return !api.compareValues(e, value);\n  });\n\n  if (values.length === 0) {\n    api.removeProperty(subject, property);\n  } else if (values.length === 1 && !options.propertyIsArray) {\n    subject[property] = values[0];\n  } else {\n    subject[property] = values;\n  }\n};\n/**\n * Relabels all blank nodes in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [issuer] an IdentifierIssuer to use to label blank nodes.\n */\n\n\napi.relabelBlankNodes = function (input, options) {\n  options = options || {};\n  var issuer = options.issuer || new IdentifierIssuer('_:b');\n  return _labelBlankNodes(issuer, input);\n};\n/**\n * Compares two JSON-LD values for equality. Two JSON-LD values will be\n * considered equal if:\n *\n * 1. They are both primitives of the same type and value.\n * 2. They are both @values with the same @value, @type, @language,\n *   and @index, OR\n * 3. They both have @ids they are the same.\n *\n * @param v1 the first value.\n * @param v2 the second value.\n *\n * @return true if v1 and v2 are considered equal, false if not.\n */\n\n\napi.compareValues = function (v1, v2) {\n  // 1. equal primitives\n  if (v1 === v2) {\n    return true;\n  } // 2. equal @values\n\n\n  if (graphTypes.isValue(v1) && graphTypes.isValue(v2) && v1['@value'] === v2['@value'] && v1['@type'] === v2['@type'] && v1['@language'] === v2['@language'] && v1['@index'] === v2['@index']) {\n    return true;\n  } // 3. equal @ids\n\n\n  if (types.isObject(v1) && '@id' in v1 && types.isObject(v2) && '@id' in v2) {\n    return v1['@id'] === v2['@id'];\n  }\n\n  return false;\n};\n/**\n * Compares two strings first based on length and then lexicographically.\n *\n * @param a the first string.\n * @param b the second string.\n *\n * @return -1 if a < b, 1 if a > b, 0 if a === b.\n */\n\n\napi.compareShortestLeast = function (a, b) {\n  if (a.length < b.length) {\n    return -1;\n  }\n\n  if (b.length < a.length) {\n    return 1;\n  }\n\n  if (a === b) {\n    return 0;\n  }\n\n  return a < b ? -1 : 1;\n};\n\napi.normalizeDocumentLoader = function (fn) {\n  if (fn.length < 2) {\n    return api.callbackify(fn);\n  }\n\n  return function _callee(url) {\n    var callback,\n        _args = arguments;\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            callback = _args[1];\n            return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n              try {\n                fn(url, function (err, remoteDoc) {\n                  if (typeof callback === 'function') {\n                    return _invokeCallback(callback, err, remoteDoc);\n                  } else if (err) {\n                    reject(err);\n                  } else {\n                    resolve(remoteDoc);\n                  }\n                });\n              } catch (e) {\n                if (typeof callback === 'function') {\n                  return _invokeCallback(callback, e);\n                }\n\n                reject(e);\n              }\n            }));\n\n          case 2:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    });\n  };\n};\n\napi.callbackify = function (fn) {\n  return function _callee2() {\n    var _len,\n        args,\n        _key,\n        callback,\n        result,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            for (_len = _args2.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = _args2[_key];\n            }\n\n            callback = args[args.length - 1];\n\n            if (typeof callback === 'function') {\n              args.pop();\n            }\n\n            _context2.prev = 3;\n            _context2.next = 6;\n            return _regeneratorRuntime.awrap(fn.apply(null, args));\n\n          case 6:\n            result = _context2.sent;\n            _context2.next = 14;\n            break;\n\n          case 9:\n            _context2.prev = 9;\n            _context2.t0 = _context2[\"catch\"](3);\n\n            if (!(typeof callback === 'function')) {\n              _context2.next = 13;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", _invokeCallback(callback, _context2.t0));\n\n          case 13:\n            throw _context2.t0;\n\n          case 14:\n            if (!(typeof callback === 'function')) {\n              _context2.next = 16;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", _invokeCallback(callback, null, result));\n\n          case 16:\n            return _context2.abrupt(\"return\", result);\n\n          case 17:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[3, 9]]);\n  };\n};\n\nfunction _invokeCallback(callback, err, result) {\n  // execute on next tick to prevent \"unhandled rejected promise\"\n  // and simulate what would have happened in a promiseless API\n  api.nextTick(function () {\n    return callback(err, result);\n  });\n}\n/**\n * Labels the blank nodes in the given value using the given IdentifierIssuer.\n *\n * @param issuer the IdentifierIssuer to use.\n * @param element the element with blank nodes to rename.\n *\n * @return the element.\n */\n\n\nfunction _labelBlankNodes(issuer, element) {\n  if (types.isArray(element)) {\n    for (var i = 0; i < element.length; ++i) {\n      element[i] = _labelBlankNodes(issuer, element[i]);\n    }\n  } else if (graphTypes.isList(element)) {\n    element['@list'] = _labelBlankNodes(issuer, element['@list']);\n  } else if (types.isObject(element)) {\n    // relabel blank node\n    if (graphTypes.isBlankNode(element)) {\n      element['@id'] = issuer.getId(element['@id']);\n    } // recursively apply to all keys\n\n\n    var keys = Object.keys(element).sort();\n\n    for (var ki = 0; ki < keys.length; ++ki) {\n      var key = keys[ki];\n\n      if (key !== '@id') {\n        element[key] = _labelBlankNodes(issuer, element[key]);\n      }\n    }\n  }\n\n  return element;\n}","map":{"version":3,"sources":["C:/Users/Guillaume/Code/e-commerce/admin/node_modules/jsonld/lib/util.js"],"names":["graphTypes","require","types","IdentifierIssuer","JsonLdError","REGEX_LINK_HEADERS","REGEX_LINK_HEADER","REGEX_LINK_HEADER_PARAMS","DEFAULTS","headers","accept","api","module","exports","_setImmediate","setImmediate","_delay","fn","setTimeout","process","nextTick","clone","value","rval","isArray","i","length","Map","k","v","set","Set","add","isObject","key","toString","asArray","Array","buildHeaders","hasAccept","Object","keys","some","h","toLowerCase","RangeError","assign","Accept","parseLinkHeader","header","entries","match","result","target","params","exec","undefined","rel","push","hasOwnProperty","validateTypeValue","isString","isEmptyObject","isValid","code","hasProperty","subject","property","hasValue","val","isList","compareValues","addValue","options","propertyIsArray","valueIsArray","allowDuplicate","getValues","concat","removeProperty","removeValue","values","filter","e","relabelBlankNodes","input","issuer","_labelBlankNodes","v1","v2","isValue","compareShortestLeast","a","b","normalizeDocumentLoader","callbackify","url","callback","Promise","resolve","reject","err","remoteDoc","_invokeCallback","args","pop","apply","element","isBlankNode","getId","sort","ki"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\n// TODO: move `IdentifierIssuer` to its own package\nconst IdentifierIssuer = require('rdf-canonize').IdentifierIssuer;\nconst JsonLdError = require('./JsonLdError');\n\n// constants\nconst REGEX_LINK_HEADERS = /(?:<[^>]*?>|\"[^\"]*?\"|[^,])+/g;\nconst REGEX_LINK_HEADER = /\\s*<([^>]*?)>\\s*(?:;\\s*(.*))?/;\nconst REGEX_LINK_HEADER_PARAMS =\n  /(.*?)=(?:(?:\"([^\"]*?)\")|([^\"]*?))\\s*(?:(?:;\\s*)|$)/g;\n\nconst DEFAULTS = {\n  headers: {\n    accept: 'application/ld+json, application/json'\n  }\n};\n\nconst api = {};\nmodule.exports = api;\napi.IdentifierIssuer = IdentifierIssuer;\n\n// define setImmediate and nextTick\n// // nextTick implementation with browser-compatible fallback // //\n// from https://github.com/caolan/async/blob/master/lib/async.js\n\n// capture the global reference to guard against fakeTimer mocks\nconst _setImmediate = typeof setImmediate === 'function' && setImmediate;\n\nconst _delay = _setImmediate ?\n  // not a direct alias (for IE10 compatibility)\n  fn => _setImmediate(fn) :\n  fn => setTimeout(fn, 0);\n\nif(typeof process === 'object' && typeof process.nextTick === 'function') {\n  api.nextTick = process.nextTick;\n} else {\n  api.nextTick = _delay;\n}\napi.setImmediate = _setImmediate ? _delay : api.nextTick;\n\n/**\n * Clones an object, array, Map, Set, or string/number. If a typed JavaScript\n * object is given, such as a Date, it will be converted to a string.\n *\n * @param value the value to clone.\n *\n * @return the cloned value.\n */\napi.clone = function(value) {\n  if(value && typeof value === 'object') {\n    let rval;\n    if(types.isArray(value)) {\n      rval = [];\n      for(let i = 0; i < value.length; ++i) {\n        rval[i] = api.clone(value[i]);\n      }\n    } else if(value instanceof Map) {\n      rval = new Map();\n      for(const [k, v] of value) {\n        rval.set(k, api.clone(v));\n      }\n    } else if(value instanceof Set) {\n      rval = new Set();\n      for(const v of value) {\n        rval.add(api.clone(v));\n      }\n    } else if(types.isObject(value)) {\n      rval = {};\n      for(const key in value) {\n        rval[key] = api.clone(value[key]);\n      }\n    } else {\n      rval = value.toString();\n    }\n    return rval;\n  }\n  return value;\n};\n\n/**\n * Ensure a value is an array. If the value is an array, it is returned.\n * Otherwise, it is wrapped in an array.\n *\n * @param value the value to return as an array.\n *\n * @return the value as an array.\n */\napi.asArray = function(value) {\n  return Array.isArray(value) ? value : [value];\n};\n\n/**\n * Builds an HTTP headers object for making a JSON-LD request from custom\n * headers and asserts the `accept` header isn't overridden.\n *\n * @param headers an object of headers with keys as header names and values\n *          as header values.\n *\n * @return an object of headers with a valid `accept` header.\n */\napi.buildHeaders = (headers = {}) => {\n  const hasAccept = Object.keys(headers).some(\n    h => h.toLowerCase() === 'accept');\n\n  if(hasAccept) {\n    throw new RangeError(\n      'Accept header may not be specified; only \"' +\n      DEFAULTS.headers.accept + '\" is supported.');\n  }\n\n  return Object.assign({Accept: DEFAULTS.headers.accept}, headers);\n};\n\n/**\n * Parses a link header. The results will be key'd by the value of \"rel\".\n *\n * Link: <http://json-ld.org/contexts/person.jsonld>;\n * rel=\"http://www.w3.org/ns/json-ld#context\"; type=\"application/ld+json\"\n *\n * Parses as: {\n *   'http://www.w3.org/ns/json-ld#context': {\n *     target: http://json-ld.org/contexts/person.jsonld,\n *     type: 'application/ld+json'\n *   }\n * }\n *\n * If there is more than one \"rel\" with the same IRI, then entries in the\n * resulting map for that \"rel\" will be arrays.\n *\n * @param header the link header to parse.\n */\napi.parseLinkHeader = header => {\n  const rval = {};\n  // split on unbracketed/unquoted commas\n  const entries = header.match(REGEX_LINK_HEADERS);\n  for(let i = 0; i < entries.length; ++i) {\n    let match = entries[i].match(REGEX_LINK_HEADER);\n    if(!match) {\n      continue;\n    }\n    const result = {target: match[1]};\n    const params = match[2];\n    while((match = REGEX_LINK_HEADER_PARAMS.exec(params))) {\n      result[match[1]] = (match[2] === undefined) ? match[3] : match[2];\n    }\n    const rel = result['rel'] || '';\n    if(Array.isArray(rval[rel])) {\n      rval[rel].push(result);\n    } else if(rval.hasOwnProperty(rel)) {\n      rval[rel] = [rval[rel], result];\n    } else {\n      rval[rel] = result;\n    }\n  }\n  return rval;\n};\n\n/**\n * Throws an exception if the given value is not a valid @type value.\n *\n * @param v the value to check.\n */\napi.validateTypeValue = v => {\n  // can be a string or an empty object\n  if(types.isString(v) || types.isEmptyObject(v)) {\n    return;\n  }\n\n  // must be an array\n  let isValid = false;\n  if(types.isArray(v)) {\n    // must contain only strings\n    isValid = true;\n    for(let i = 0; i < v.length; ++i) {\n      if(!(types.isString(v[i]))) {\n        isValid = false;\n        break;\n      }\n    }\n  }\n\n  if(!isValid) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; \"@type\" value must a string, an array of ' +\n      'strings, or an empty object.', 'jsonld.SyntaxError',\n      {code: 'invalid type value', value: v});\n  }\n};\n\n/**\n * Returns true if the given subject has the given property.\n *\n * @param subject the subject to check.\n * @param property the property to look for.\n *\n * @return true if the subject has the given property, false if not.\n */\napi.hasProperty = (subject, property) => {\n  if(subject.hasOwnProperty(property)) {\n    const value = subject[property];\n    return (!types.isArray(value) || value.length > 0);\n  }\n  return false;\n};\n\n/**\n * Determines if the given value is a property of the given subject.\n *\n * @param subject the subject to check.\n * @param property the property to check.\n * @param value the value to check.\n *\n * @return true if the value exists, false if not.\n */\napi.hasValue = (subject, property, value) => {\n  if(api.hasProperty(subject, property)) {\n    let val = subject[property];\n    const isList = graphTypes.isList(val);\n    if(types.isArray(val) || isList) {\n      if(isList) {\n        val = val['@list'];\n      }\n      for(let i = 0; i < val.length; ++i) {\n        if(api.compareValues(value, val[i])) {\n          return true;\n        }\n      }\n    } else if(!types.isArray(value)) {\n      // avoid matching the set of values with an array value parameter\n      return api.compareValues(value, val);\n    }\n  }\n  return false;\n};\n\n/**\n * Adds a value to a subject. If the value is an array, all values in the\n * array will be added.\n *\n * @param subject the subject to add the value to.\n * @param property the property that relates the value to the subject.\n * @param value the value to add.\n * @param [options] the options to use:\n *        [propertyIsArray] true if the property is always an array, false\n *          if not (default: false).\n *        [valueIsArray] true if the value to be added should be preserved as\n *          an array (lists) (default: false).\n *        [allowDuplicate] true to allow duplicates, false not to (uses a\n *          simple shallow comparison of subject ID or value) (default: true).\n */\napi.addValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n  if(!('valueIsArray' in options)) {\n    options.valueIsArray = false;\n  }\n  if(!('allowDuplicate' in options)) {\n    options.allowDuplicate = true;\n  }\n\n  if(options.valueIsArray) {\n    subject[property] = value;\n  } else if(types.isArray(value)) {\n    if(value.length === 0 && options.propertyIsArray &&\n      !subject.hasOwnProperty(property)) {\n      subject[property] = [];\n    }\n    for(let i = 0; i < value.length; ++i) {\n      api.addValue(subject, property, value[i], options);\n    }\n  } else if(subject.hasOwnProperty(property)) {\n    // check if subject already has value if duplicates not allowed\n    const hasValue = (!options.allowDuplicate &&\n      api.hasValue(subject, property, value));\n\n    // make property an array if value not present or always an array\n    if(!types.isArray(subject[property]) &&\n      (!hasValue || options.propertyIsArray)) {\n      subject[property] = [subject[property]];\n    }\n\n    // add new value\n    if(!hasValue) {\n      subject[property].push(value);\n    }\n  } else {\n    // add new value as set or single value\n    subject[property] = options.propertyIsArray ? [value] : value;\n  }\n};\n\n/**\n * Gets all of the values for a subject's property as an array.\n *\n * @param subject the subject.\n * @param property the property.\n *\n * @return all of the values for a subject's property as an array.\n */\napi.getValues = (subject, property) => [].concat(subject[property] || []);\n\n/**\n * Removes a property from a subject.\n *\n * @param subject the subject.\n * @param property the property.\n */\napi.removeProperty = (subject, property) => {\n  delete subject[property];\n};\n\n/**\n * Removes a value from a subject.\n *\n * @param subject the subject.\n * @param property the property that relates the value to the subject.\n * @param value the value to remove.\n * @param [options] the options to use:\n *          [propertyIsArray] true if the property is always an array, false\n *            if not (default: false).\n */\napi.removeValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n\n  // filter out value\n  const values = api.getValues(subject, property).filter(\n    e => !api.compareValues(e, value));\n\n  if(values.length === 0) {\n    api.removeProperty(subject, property);\n  } else if(values.length === 1 && !options.propertyIsArray) {\n    subject[property] = values[0];\n  } else {\n    subject[property] = values;\n  }\n};\n\n/**\n * Relabels all blank nodes in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [issuer] an IdentifierIssuer to use to label blank nodes.\n */\napi.relabelBlankNodes = (input, options) => {\n  options = options || {};\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  return _labelBlankNodes(issuer, input);\n};\n\n/**\n * Compares two JSON-LD values for equality. Two JSON-LD values will be\n * considered equal if:\n *\n * 1. They are both primitives of the same type and value.\n * 2. They are both @values with the same @value, @type, @language,\n *   and @index, OR\n * 3. They both have @ids they are the same.\n *\n * @param v1 the first value.\n * @param v2 the second value.\n *\n * @return true if v1 and v2 are considered equal, false if not.\n */\napi.compareValues = (v1, v2) => {\n  // 1. equal primitives\n  if(v1 === v2) {\n    return true;\n  }\n\n  // 2. equal @values\n  if(graphTypes.isValue(v1) && graphTypes.isValue(v2) &&\n    v1['@value'] === v2['@value'] &&\n    v1['@type'] === v2['@type'] &&\n    v1['@language'] === v2['@language'] &&\n    v1['@index'] === v2['@index']) {\n    return true;\n  }\n\n  // 3. equal @ids\n  if(types.isObject(v1) &&\n    ('@id' in v1) &&\n    types.isObject(v2) &&\n    ('@id' in v2)) {\n    return v1['@id'] === v2['@id'];\n  }\n\n  return false;\n};\n\n/**\n * Compares two strings first based on length and then lexicographically.\n *\n * @param a the first string.\n * @param b the second string.\n *\n * @return -1 if a < b, 1 if a > b, 0 if a === b.\n */\napi.compareShortestLeast = (a, b) => {\n  if(a.length < b.length) {\n    return -1;\n  }\n  if(b.length < a.length) {\n    return 1;\n  }\n  if(a === b) {\n    return 0;\n  }\n  return (a < b) ? -1 : 1;\n};\n\napi.normalizeDocumentLoader = fn => {\n  if(fn.length < 2) {\n    return api.callbackify(fn);\n  }\n\n  return async function(url) {\n    const callback = arguments[1];\n    return new Promise((resolve, reject) => {\n      try {\n        fn(url, (err, remoteDoc) => {\n          if(typeof callback === 'function') {\n            return _invokeCallback(callback, err, remoteDoc);\n          } else if(err) {\n            reject(err);\n          } else {\n            resolve(remoteDoc);\n          }\n        });\n      } catch(e) {\n        if(typeof callback === 'function') {\n          return _invokeCallback(callback, e);\n        }\n        reject(e);\n      }\n    });\n  };\n};\n\napi.callbackify = fn => {\n  return async function(...args) {\n    const callback = args[args.length - 1];\n    if(typeof callback === 'function') {\n      args.pop();\n    }\n\n    let result;\n    try {\n      result = await fn.apply(null, args);\n    } catch(e) {\n      if(typeof callback === 'function') {\n        return _invokeCallback(callback, e);\n      }\n      throw e;\n    }\n\n    if(typeof callback === 'function') {\n      return _invokeCallback(callback, null, result);\n    }\n\n    return result;\n  };\n};\n\nfunction _invokeCallback(callback, err, result) {\n  // execute on next tick to prevent \"unhandled rejected promise\"\n  // and simulate what would have happened in a promiseless API\n  api.nextTick(() => callback(err, result));\n}\n\n/**\n * Labels the blank nodes in the given value using the given IdentifierIssuer.\n *\n * @param issuer the IdentifierIssuer to use.\n * @param element the element with blank nodes to rename.\n *\n * @return the element.\n */\nfunction _labelBlankNodes(issuer, element) {\n  if(types.isArray(element)) {\n    for(let i = 0; i < element.length; ++i) {\n      element[i] = _labelBlankNodes(issuer, element[i]);\n    }\n  } else if(graphTypes.isList(element)) {\n    element['@list'] = _labelBlankNodes(issuer, element['@list']);\n  } else if(types.isObject(element)) {\n    // relabel blank node\n    if(graphTypes.isBlankNode(element)) {\n      element['@id'] = issuer.getId(element['@id']);\n    }\n\n    // recursively apply to all keys\n    const keys = Object.keys(element).sort();\n    for(let ki = 0; ki < keys.length; ++ki) {\n      const key = keys[ki];\n      if(key !== '@id') {\n        element[key] = _labelBlankNodes(issuer, element[key]);\n      }\n    }\n  }\n\n  return element;\n}\n"]},"metadata":{},"sourceType":"script"}