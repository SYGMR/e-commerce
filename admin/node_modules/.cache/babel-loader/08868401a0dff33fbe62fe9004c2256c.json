{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Guillaume\\\\Code\\\\e-commerce\\\\admin\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\Guillaume\\\\Code\\\\e-commerce\\\\admin\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Guillaume\\\\Code\\\\e-commerce\\\\admin\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar util = require('./util');\n\nvar ActiveContextCache = require('./ActiveContextCache');\n\nvar JsonLdError = require('./JsonLdError');\n\nvar _require = require('./types'),\n    _isArray = _require.isArray,\n    _isObject = _require.isObject,\n    _isString = _require.isString,\n    _isUndefined = _require.isUndefined;\n\nvar _require2 = require('./url'),\n    _isAbsoluteIri = _require2.isAbsolute,\n    _isRelativeIri = _require2.isRelative,\n    prependBase = _require2.prependBase,\n    parseUrl = _require2.parse;\n\nvar _require3 = require('./util'),\n    _asArray = _require3.asArray,\n    _compareShortestLeast = _require3.compareShortestLeast;\n\nvar MAX_CONTEXT_URLS = 10;\nvar INITIAL_CONTEXT_CACHE = new Map();\nvar INITIAL_CONTEXT_CACHE_MAX_SIZE = 10000;\nvar api = {};\nmodule.exports = api;\napi.cache = new ActiveContextCache();\n/**\n * Processes a local context and returns a new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param options the context processing options.\n * @param isPropertyTermScopedContext `true` if `localCtx` is a scoped context\n *   from a property term.\n * @param isTypeScopedContext `true` if `localCtx` is a scoped context\n *   from a type.\n *\n * @return the new active context.\n */\n\napi.process = function (_ref) {\n  var activeCtx = _ref.activeCtx,\n      localCtx = _ref.localCtx,\n      options = _ref.options,\n      _ref$isPropertyTermSc = _ref.isPropertyTermScopedContext,\n      isPropertyTermScopedContext = _ref$isPropertyTermSc === void 0 ? false : _ref$isPropertyTermSc,\n      _ref$isTypeScopedCont = _ref.isTypeScopedContext,\n      isTypeScopedContext = _ref$isTypeScopedCont === void 0 ? false : _ref$isTypeScopedCont;\n\n  // normalize local context to an array of @context objects\n  if (_isObject(localCtx) && '@context' in localCtx && _isArray(localCtx['@context'])) {\n    localCtx = localCtx['@context'];\n  }\n\n  var ctxs = _asArray(localCtx); // no contexts in array, return current active context w/o changes\n\n\n  if (ctxs.length === 0) {\n    return activeCtx;\n  } // track the previous context\n\n\n  var previousContext = activeCtx.previousContext || activeCtx; // if context is property scoped and there's a previous context, amend it,\n  // not the current one\n\n  if (isPropertyTermScopedContext && activeCtx.previousContext) {\n    // TODO: consider optimizing to a shallow copy\n    activeCtx = activeCtx.clone();\n    activeCtx.isPropertyTermScoped = true;\n    activeCtx.previousContext = api.process({\n      activeCtx: activeCtx.previousContext,\n      localCtx: ctxs,\n      options: options,\n      isPropertyTermScopedContext: isPropertyTermScopedContext\n    });\n    return activeCtx;\n  } // process each context in order, update active context\n  // on each iteration to ensure proper caching\n\n\n  var rval = activeCtx;\n\n  for (var i = 0; i < ctxs.length; ++i) {\n    var ctx = ctxs[i]; // update active context to one computed from last iteration\n\n    activeCtx = rval; // reset to initial context\n\n    if (ctx === null) {\n      // We can't nullify if there are protected terms and we're\n      // not processing a property term scoped context\n      if (!isPropertyTermScopedContext && Object.keys(activeCtx.protected).length !== 0) {\n        var protectedMode = options && options.protectedMode || 'error';\n\n        if (protectedMode === 'error') {\n          throw new JsonLdError('Tried to nullify a context with protected terms outside of ' + 'a term definition.', 'jsonld.SyntaxError', {\n            code: 'invalid context nullification'\n          });\n        } else if (protectedMode === 'warn') {\n          // FIXME: remove logging and use a handler\n          console.warn('WARNING: invalid context nullification');\n          var oldActiveCtx = activeCtx; // copy all protected term definitions to fresh initial context\n\n          rval = activeCtx = api.getInitialContext(options).clone();\n\n          for (var _i = 0, _Object$entries = Object.entries(oldActiveCtx.protected); _i < _Object$entries.length; _i++) {\n            var _ref4 = _Object$entries[_i];\n\n            var _ref3 = _slicedToArray(_ref4, 2);\n\n            var term = _ref3[0];\n            var _protected = _ref3[1];\n\n            if (_protected) {\n              activeCtx.mappings[term] = util.clone(oldActiveCtx.mappings[term]);\n            }\n          }\n\n          activeCtx.protected = util.clone(oldActiveCtx.protected); // cache result\n\n          if (api.cache) {\n            api.cache.set(oldActiveCtx, ctx, rval);\n          }\n\n          continue;\n        }\n\n        throw new JsonLdError('Invalid protectedMode.', 'jsonld.SyntaxError', {\n          code: 'invalid protected mode',\n          context: localCtx,\n          protectedMode: protectedMode\n        });\n      }\n\n      rval = activeCtx = api.getInitialContext(options).clone(); // if context is type-scoped, ensure previous context has been set\n\n      if (isTypeScopedContext) {\n        rval.previousContext = previousContext.clone();\n      }\n\n      continue;\n    } // get context from cache if available\n\n\n    if (api.cache) {\n      var cached = api.cache.get(activeCtx, ctx);\n\n      if (cached) {\n        rval = activeCtx = cached;\n        continue;\n      }\n    } // dereference @context key if present\n\n\n    if (_isObject(ctx) && '@context' in ctx) {\n      ctx = ctx['@context'];\n    } // context must be an object by now, all URLs retrieved before this call\n\n\n    if (!_isObject(ctx)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context must be an object.', 'jsonld.SyntaxError', {\n        code: 'invalid local context',\n        context: ctx\n      });\n    } // TODO: there is likely a `preivousContext` cloning optimization that\n    // could be applied here (no need to copy it under certain conditions)\n    // clone context before updating it\n\n\n    rval = rval.clone(); // define context mappings for keys in local context\n\n    var defined = new Map(); // handle @version\n\n    if ('@version' in ctx) {\n      if (ctx['@version'] !== 1.1) {\n        throw new JsonLdError('Unsupported JSON-LD version: ' + ctx['@version'], 'jsonld.UnsupportedVersion', {\n          code: 'invalid @version value',\n          context: ctx\n        });\n      }\n\n      if (activeCtx.processingMode && activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError('@version: ' + ctx['@version'] + ' not compatible with ' + activeCtx.processingMode, 'jsonld.ProcessingModeConflict', {\n          code: 'processing mode conflict',\n          context: ctx\n        });\n      }\n\n      rval.processingMode = 'json-ld-1.1';\n      rval['@version'] = ctx['@version'];\n      defined.set('@version', true);\n    } // if not set explicitly, set processingMode to \"json-ld-1.0\"\n\n\n    rval.processingMode = rval.processingMode || activeCtx.processingMode || 'json-ld-1.0'; // handle @base\n\n    if ('@base' in ctx) {\n      var base = ctx['@base'];\n\n      if (base === null) {// no action\n      } else if (_isAbsoluteIri(base)) {\n        base = parseUrl(base);\n      } else if (_isRelativeIri(base)) {\n        base = parseUrl(prependBase(activeCtx['@base'].href, base));\n      } else {\n        throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@base\" in a ' + '@context must be an absolute IRI, a relative IRI, or null.', 'jsonld.SyntaxError', {\n          code: 'invalid base IRI',\n          context: ctx\n        });\n      }\n\n      rval['@base'] = base;\n      defined.set('@base', true);\n    } // handle @vocab\n\n\n    if ('@vocab' in ctx) {\n      var value = ctx['@vocab'];\n\n      if (value === null) {\n        delete rval['@vocab'];\n      } else if (!_isString(value)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@vocab\" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {\n          code: 'invalid vocab mapping',\n          context: ctx\n        });\n      } else if (!_isAbsoluteIri(value)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@vocab\" in a ' + '@context must be an absolute IRI.', 'jsonld.SyntaxError', {\n          code: 'invalid vocab mapping',\n          context: ctx\n        });\n      } else {\n        rval['@vocab'] = value;\n      }\n\n      defined.set('@vocab', true);\n    } // handle @language\n\n\n    if ('@language' in ctx) {\n      var _value = ctx['@language'];\n\n      if (_value === null) {\n        delete rval['@language'];\n      } else if (!_isString(_value)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@language\" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {\n          code: 'invalid default language',\n          context: ctx\n        });\n      } else {\n        rval['@language'] = _value.toLowerCase();\n      }\n\n      defined.set('@language', true);\n    } // handle @protected; determine whether this sub-context is declaring\n    // all its terms to be \"protected\" (exceptions can be made on a\n    // per-definition basis)\n\n\n    defined.set('@protected', ctx['@protected'] || false); // process all other keys\n\n    for (var key in ctx) {\n      api.createTermDefinition(rval, ctx, key, defined, options, isPropertyTermScopedContext);\n    } // if context is type-scoped, ensure previous context has been set\n\n\n    if (isTypeScopedContext && !rval.previousContext) {\n      rval.previousContext = previousContext.clone();\n    } // cache result\n\n\n    if (api.cache) {\n      api.cache.set(activeCtx, ctx, rval);\n    }\n  }\n\n  return rval;\n};\n/**\n * Creates a term definition during context processing.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context being processed.\n * @param term the term in the local context to define the mapping for.\n * @param defined a map of defining/defined keys to detect cycles and prevent\n *          double definitions.\n * @param {Object} [options] - creation options.\n * @param {string} [options.protectedMode=\"error\"] - \"error\" to throw error\n *   on `@protected` constraint violation, \"warn\" to allow violations and\n *   signal a warning.\n * @param isPropertyTermScopedContext `true` if `localCtx` is a scoped context\n *   from a property term.\n */\n\n\napi.createTermDefinition = function (activeCtx, localCtx, term, defined, options) {\n  var isPropertyTermScopedContext = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n  if (defined.has(term)) {\n    // term already defined\n    if (defined.get(term)) {\n      return;\n    } // cycle detected\n\n\n    throw new JsonLdError('Cyclical context definition detected.', 'jsonld.CyclicalContext', {\n      code: 'cyclic IRI mapping',\n      context: localCtx,\n      term: term\n    });\n  } // now defining term\n\n\n  defined.set(term, false);\n\n  if (api.isKeyword(term)) {\n    throw new JsonLdError('Invalid JSON-LD syntax; keywords cannot be overridden.', 'jsonld.SyntaxError', {\n      code: 'keyword redefinition',\n      context: localCtx,\n      term: term\n    });\n  }\n\n  if (term === '') {\n    throw new JsonLdError('Invalid JSON-LD syntax; a term cannot be an empty string.', 'jsonld.SyntaxError', {\n      code: 'invalid term definition',\n      context: localCtx\n    });\n  } // keep reference to previous mapping for potential `@protected` check\n\n\n  var previousMapping = activeCtx.mappings.get(term); // remove old mapping\n\n  if (activeCtx.mappings.has(term)) {\n    activeCtx.mappings.delete(term);\n  } // get context term value\n\n\n  var value;\n\n  if (localCtx.hasOwnProperty(term)) {\n    value = localCtx[term];\n  } // clear context entry\n\n\n  if (value === null || _isObject(value) && value['@id'] === null) {\n    activeCtx.mappings.set(term, null);\n    defined.set(term, true);\n    return;\n  } // convert short-hand value to object w/@id\n\n\n  var simpleTerm = false;\n\n  if (_isString(value)) {\n    simpleTerm = true;\n    value = {\n      '@id': value\n    };\n  }\n\n  if (!_isObject(value)) {\n    throw new JsonLdError('Invalid JSON-LD syntax; @context term values must be ' + 'strings or objects.', 'jsonld.SyntaxError', {\n      code: 'invalid term definition',\n      context: localCtx\n    });\n  } // create new mapping\n\n\n  var mapping = {};\n  activeCtx.mappings.set(term, mapping);\n  mapping.reverse = false; // make sure term definition only has expected keywords\n\n  var validKeys = ['@container', '@id', '@language', '@reverse', '@type']; // JSON-LD 1.1 support\n\n  if (api.processingMode(activeCtx, 1.1)) {\n    validKeys.push('@context', '@nest', '@prefix', '@protected');\n  }\n\n  for (var kw in value) {\n    if (!validKeys.includes(kw)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a term definition must not contain ' + kw, 'jsonld.SyntaxError', {\n        code: 'invalid term definition',\n        context: localCtx\n      });\n    }\n  } // always compute whether term has a colon as an optimization for\n  // _compactIri\n\n\n  var colon = term.indexOf(':');\n  mapping._termHasColon = colon !== -1;\n\n  if ('@reverse' in value) {\n    if ('@id' in value) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @reverse term definition must not ' + 'contain @id.', 'jsonld.SyntaxError', {\n        code: 'invalid reverse property',\n        context: localCtx\n      });\n    }\n\n    if ('@nest' in value) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @reverse term definition must not ' + 'contain @nest.', 'jsonld.SyntaxError', {\n        code: 'invalid reverse property',\n        context: localCtx\n      });\n    }\n\n    var reverse = value['@reverse'];\n\n    if (!_isString(reverse)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @context @reverse value must be a string.', 'jsonld.SyntaxError', {\n        code: 'invalid IRI mapping',\n        context: localCtx\n      });\n    } // expand and add @id mapping\n\n\n    var _id = _expandIri(activeCtx, reverse, {\n      vocab: true,\n      base: false\n    }, localCtx, defined, options);\n\n    if (!_isAbsoluteIri(_id)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @context @reverse value must be an ' + 'absolute IRI or a blank node identifier.', 'jsonld.SyntaxError', {\n        code: 'invalid IRI mapping',\n        context: localCtx\n      });\n    }\n\n    mapping['@id'] = _id;\n    mapping.reverse = true;\n  } else if ('@id' in value) {\n    var _id2 = value['@id'];\n\n    if (!_isString(_id2)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @context @id value must be an array ' + 'of strings or a string.', 'jsonld.SyntaxError', {\n        code: 'invalid IRI mapping',\n        context: localCtx\n      });\n    }\n\n    if (_id2 !== term) {\n      // expand and add @id mapping\n      _id2 = _expandIri(activeCtx, _id2, {\n        vocab: true,\n        base: false\n      }, localCtx, defined, options);\n\n      if (!_isAbsoluteIri(_id2) && !api.isKeyword(_id2)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; a @context @id value must be an ' + 'absolute IRI, a blank node identifier, or a keyword.', 'jsonld.SyntaxError', {\n          code: 'invalid IRI mapping',\n          context: localCtx\n        });\n      }\n\n      mapping['@id'] = _id2; // indicate if this term may be used as a compact IRI prefix\n\n      mapping._prefix = !mapping._termHasColon && _id2.match(/[:\\/\\?#\\[\\]@]$/) && (simpleTerm || api.processingMode(activeCtx, 1.0));\n    }\n  }\n\n  if (!('@id' in mapping)) {\n    // see if the term has a prefix\n    if (mapping._termHasColon) {\n      var prefix = term.substr(0, colon);\n\n      if (localCtx.hasOwnProperty(prefix)) {\n        // define parent prefix\n        api.createTermDefinition(activeCtx, localCtx, prefix, defined, options);\n      }\n\n      if (activeCtx.mappings.has(prefix)) {\n        // set @id based on prefix parent\n        var suffix = term.substr(colon + 1);\n        mapping['@id'] = activeCtx.mappings.get(prefix)['@id'] + suffix;\n      } else {\n        // term is an absolute IRI\n        mapping['@id'] = term;\n      }\n    } else {\n      // non-IRIs *must* define @ids if @vocab is not available\n      if (!('@vocab' in activeCtx)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; @context terms must define an @id.', 'jsonld.SyntaxError', {\n          code: 'invalid IRI mapping',\n          context: localCtx,\n          term: term\n        });\n      } // prepend vocab to term\n\n\n      mapping['@id'] = activeCtx['@vocab'] + term;\n    }\n  } // Handle term protection\n\n\n  if (value['@protected'] === true || defined.get('@protected') === true && value['@protected'] !== false) {\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n  } // IRI mapping now defined\n\n\n  defined.set(term, true);\n\n  if ('@type' in value) {\n    var type = value['@type'];\n\n    if (!_isString(type)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be a string.', 'jsonld.SyntaxError', {\n        code: 'invalid type mapping',\n        context: localCtx\n      });\n    }\n\n    if (type !== '@id' && type !== '@vocab' && type !== '@json') {\n      // expand @type to full IRI\n      type = _expandIri(activeCtx, type, {\n        vocab: true,\n        base: false\n      }, localCtx, defined, options);\n\n      if (!_isAbsoluteIri(type)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be an ' + 'absolute IRI.', 'jsonld.SyntaxError', {\n          code: 'invalid type mapping',\n          context: localCtx\n        });\n      }\n\n      if (type.indexOf('_:') === 0) {\n        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be an IRI, ' + 'not a blank node identifier.', 'jsonld.SyntaxError', {\n          code: 'invalid type mapping',\n          context: localCtx\n        });\n      }\n    } // add @type to mapping\n\n\n    mapping['@type'] = type;\n  }\n\n  if ('@container' in value) {\n    // normalize container to an array form\n    var container = _isString(value['@container']) ? [value['@container']] : value['@container'] || [];\n    var validContainers = ['@list', '@set', '@index', '@language'];\n    var isValid = true;\n    var hasSet = container.includes('@set'); // JSON-LD 1.1 support\n\n    if (api.processingMode(activeCtx, 1.1)) {\n      validContainers.push('@graph', '@id', '@type'); // check container length\n\n      if (container.includes('@list')) {\n        if (container.length !== 1) {\n          throw new JsonLdError('Invalid JSON-LD syntax; @context @container with @list must ' + 'have no other values', 'jsonld.SyntaxError', {\n            code: 'invalid container mapping',\n            context: localCtx\n          });\n        }\n      } else if (container.includes('@graph')) {\n        if (container.some(function (key) {\n          return key !== '@graph' && key !== '@id' && key !== '@index' && key !== '@set';\n        })) {\n          throw new JsonLdError('Invalid JSON-LD syntax; @context @container with @graph must ' + 'have no other values other than @id, @index, and @set', 'jsonld.SyntaxError', {\n            code: 'invalid container mapping',\n            context: localCtx\n          });\n        }\n      } else {\n        // otherwise, container may also include @set\n        isValid &= container.length <= (hasSet ? 2 : 1);\n      }\n    } else {\n      // in JSON-LD 1.0, container must not be an array (it must be a string,\n      // which is one of the validContainers)\n      isValid &= !_isArray(value['@container']); // check container length\n\n      isValid &= container.length <= 1;\n    } // check against valid containers\n\n\n    isValid &= container.every(function (c) {\n      return validContainers.includes(c);\n    }); // @set not allowed with @list\n\n    isValid &= !(hasSet && container.includes('@list'));\n\n    if (!isValid) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @container value must be ' + 'one of the following: ' + validContainers.join(', '), 'jsonld.SyntaxError', {\n        code: 'invalid container mapping',\n        context: localCtx\n      });\n    }\n\n    if (mapping.reverse && !container.every(function (c) {\n      return ['@index', '@set'].includes(c);\n    })) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @container value for a @reverse ' + 'type definition must be @index or @set.', 'jsonld.SyntaxError', {\n        code: 'invalid reverse property',\n        context: localCtx\n      });\n    } // add @container to mapping\n\n\n    mapping['@container'] = container;\n  } // scoped contexts\n\n\n  if ('@context' in value) {\n    mapping['@context'] = value['@context'];\n  }\n\n  if ('@language' in value && !('@type' in value)) {\n    var language = value['@language'];\n\n    if (language !== null && !_isString(language)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @language value must be ' + 'a string or null.', 'jsonld.SyntaxError', {\n        code: 'invalid language mapping',\n        context: localCtx\n      });\n    } // add @language to mapping\n\n\n    if (language !== null) {\n      language = language.toLowerCase();\n    }\n\n    mapping['@language'] = language;\n  } // term may be used as a prefix\n\n\n  if ('@prefix' in value) {\n    if (mapping._termHasColon) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @prefix used on a compact IRI term', 'jsonld.SyntaxError', {\n        code: 'invalid term definition',\n        context: localCtx\n      });\n    }\n\n    if (typeof value['@prefix'] === 'boolean') {\n      mapping._prefix = value['@prefix'] === true;\n    } else {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context value for @prefix must be boolean', 'jsonld.SyntaxError', {\n        code: 'invalid @prefix value',\n        context: localCtx\n      });\n    }\n  }\n\n  if ('@nest' in value) {\n    var nest = value['@nest'];\n\n    if (!_isString(nest) || nest !== '@nest' && nest.indexOf('@') === 0) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @nest value must be ' + 'a string which is not a keyword other than @nest.', 'jsonld.SyntaxError', {\n        code: 'invalid @nest value',\n        context: localCtx\n      });\n    }\n\n    mapping['@nest'] = nest;\n  } // disallow aliasing @context and @preserve\n\n\n  var id = mapping['@id'];\n\n  if (id === '@context' || id === '@preserve') {\n    throw new JsonLdError('Invalid JSON-LD syntax; @context and @preserve cannot be aliased.', 'jsonld.SyntaxError', {\n      code: 'invalid keyword alias',\n      context: localCtx\n    });\n  } // FIXME if(1.1) ... ?\n\n\n  if (previousMapping && previousMapping.protected && !isPropertyTermScopedContext) {\n    // force new term to continue to be protected and see if the mappings would\n    // be equal\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n\n    if (!_deepCompare(previousMapping, mapping)) {\n      var protectedMode = options && options.protectedMode || 'error';\n\n      if (protectedMode === 'error') {\n        throw new JsonLdError('Invalid JSON-LD syntax; tried to redefine a protected term.', 'jsonld.SyntaxError', {\n          code: 'protected term redefinition',\n          context: localCtx,\n          term: term\n        });\n      } else if (protectedMode === 'warn') {\n        // FIXME: remove logging and use a handler\n        console.warn('WARNING: protected term redefinition', {\n          term: term\n        });\n        return;\n      }\n\n      throw new JsonLdError('Invalid protectedMode.', 'jsonld.SyntaxError', {\n        code: 'invalid protected mode',\n        context: localCtx,\n        term: term,\n        protectedMode: protectedMode\n      });\n    }\n  }\n};\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\n\n\napi.expandIri = function (activeCtx, value, relativeTo, options) {\n  return _expandIri(activeCtx, value, relativeTo, undefined, undefined, options);\n};\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param localCtx the local context being processed (only given if called\n *          during context processing).\n * @param defined a map for tracking cycles in context definitions (only given\n *          if called during context processing).\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\n\n\nfunction _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {\n  // already expanded\n  if (value === null || !_isString(value) || api.isKeyword(value)) {\n    return value;\n  } // define term dependency if not defined\n\n\n  if (localCtx && localCtx.hasOwnProperty(value) && defined.get(value) !== true) {\n    api.createTermDefinition(activeCtx, localCtx, value, defined, options);\n  } // if context is from a property term scoped context composed with a\n  // type-scoped context, then use previous context instead\n\n\n  if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  relativeTo = relativeTo || {};\n\n  if (relativeTo.vocab) {\n    var mapping = activeCtx.mappings.get(value); // value is explicitly ignored with a null mapping\n\n    if (mapping === null) {\n      return null;\n    }\n\n    if (mapping) {\n      // value is a term\n      return mapping['@id'];\n    }\n  } // split value into prefix:suffix\n\n\n  var colon = value.indexOf(':');\n\n  if (colon !== -1) {\n    var prefix = value.substr(0, colon);\n    var suffix = value.substr(colon + 1); // do not expand blank nodes (prefix of '_') or already-absolute\n    // IRIs (suffix of '//')\n\n    if (prefix === '_' || suffix.indexOf('//') === 0) {\n      return value;\n    } // prefix dependency not defined, define it\n\n\n    if (localCtx && localCtx.hasOwnProperty(prefix)) {\n      api.createTermDefinition(activeCtx, localCtx, prefix, defined, options);\n    } // use mapping if prefix is defined\n\n\n    if (activeCtx.mappings.has(prefix)) {\n      var _mapping = activeCtx.mappings.get(prefix);\n\n      return _mapping['@id'] + suffix;\n    } // already absolute IRI\n\n\n    return value;\n  } // prepend vocab\n\n\n  if (relativeTo.vocab && '@vocab' in activeCtx) {\n    return activeCtx['@vocab'] + value;\n  } // prepend base\n\n\n  if (relativeTo.base) {\n    return prependBase(activeCtx['@base'], value);\n  }\n\n  return value;\n}\n/**\n * Gets the initial context.\n *\n * @param options the options to use:\n *          [base] the document base IRI.\n *\n * @return the initial context.\n */\n\n\napi.getInitialContext = function (options) {\n  var base = parseUrl(options.base || '');\n  var key = JSON.stringify({\n    base: base,\n    processingMode: options.processingMode\n  });\n  var cached = INITIAL_CONTEXT_CACHE.get(key);\n\n  if (cached) {\n    return cached;\n  }\n\n  var initialContext = {\n    '@base': base,\n    processingMode: options.processingMode,\n    mappings: new Map(),\n    inverse: null,\n    getInverse: _createInverseContext,\n    clone: _cloneActiveContext,\n    revertTypeScopedContext: _revertTypeScopedContext,\n    protected: {}\n  }; // TODO: consider using LRU cache instead\n\n  if (INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {\n    // clear whole cache -- assumes scenario where the cache fills means\n    // the cache isn't being used very efficiently anyway\n    INITIAL_CONTEXT_CACHE.clear();\n  }\n\n  INITIAL_CONTEXT_CACHE.set(key, initialContext);\n  return initialContext;\n  /**\n   * Generates an inverse context for use in the compaction algorithm, if\n   * not already generated for the given active context.\n   *\n   * @return the inverse context.\n   */\n\n  function _createInverseContext() {\n    var activeCtx = this; // lazily create inverse\n\n    if (activeCtx.inverse) {\n      return activeCtx.inverse;\n    }\n\n    var inverse = activeCtx.inverse = {}; // variables for building fast CURIE map\n\n    var fastCurieMap = activeCtx.fastCurieMap = {};\n    var irisToTerms = {}; // handle default language\n\n    var defaultLanguage = activeCtx['@language'] || '@none'; // create term selections for each mapping in the context, ordered by\n    // shortest and then lexicographically least\n\n    var mappings = activeCtx.mappings;\n\n    var terms = _toConsumableArray(mappings.keys()).sort(_compareShortestLeast);\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = terms[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var term = _step.value;\n        var mapping = mappings.get(term);\n\n        if (mapping === null) {\n          continue;\n        }\n\n        var container = mapping['@container'] || '@none';\n        container = [].concat(container).sort().join(''); // iterate over every IRI in the mapping\n\n        var ids = _asArray(mapping['@id']);\n\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = ids[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var iri = _step2.value;\n            var entry = inverse[iri];\n            var isKeyword = api.isKeyword(iri);\n\n            if (!entry) {\n              // initialize entry\n              inverse[iri] = entry = {};\n\n              if (!isKeyword && !mapping._termHasColon) {\n                // init IRI to term map and fast CURIE prefixes\n                irisToTerms[iri] = [term];\n                var fastCurieEntry = {\n                  iri: iri,\n                  terms: irisToTerms[iri]\n                };\n\n                if (iri[0] in fastCurieMap) {\n                  fastCurieMap[iri[0]].push(fastCurieEntry);\n                } else {\n                  fastCurieMap[iri[0]] = [fastCurieEntry];\n                }\n              }\n            } else if (!isKeyword && !mapping._termHasColon) {\n              // add IRI to term match\n              irisToTerms[iri].push(term);\n            } // add new entry\n\n\n            if (!entry[container]) {\n              entry[container] = {\n                '@language': {},\n                '@type': {},\n                '@any': {}\n              };\n            }\n\n            entry = entry[container];\n\n            _addPreferredTerm(term, entry['@any'], '@none');\n\n            if (mapping.reverse) {\n              // term is preferred for values using @reverse\n              _addPreferredTerm(term, entry['@type'], '@reverse');\n            } else if ('@type' in mapping) {\n              // term is preferred for values using specific type\n              _addPreferredTerm(term, entry['@type'], mapping['@type']);\n            } else if ('@language' in mapping) {\n              // term is preferred for values using specific language\n              var language = mapping['@language'] || '@null';\n\n              _addPreferredTerm(term, entry['@language'], language);\n            } else {\n              // term is preferred for values w/default language or no type and\n              // no language\n              // add an entry for the default language\n              _addPreferredTerm(term, entry['@language'], defaultLanguage); // add entries for no type and no language\n\n\n              _addPreferredTerm(term, entry['@type'], '@none');\n\n              _addPreferredTerm(term, entry['@language'], '@none');\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } // build fast CURIE map\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    for (var _key in fastCurieMap) {\n      _buildIriMap(fastCurieMap, _key, 1);\n    }\n\n    return inverse;\n  }\n  /**\n   * Runs a recursive algorithm to build a lookup map for quickly finding\n   * potential CURIEs.\n   *\n   * @param iriMap the map to build.\n   * @param key the current key in the map to work on.\n   * @param idx the index into the IRI to compare.\n   */\n\n\n  function _buildIriMap(iriMap, key, idx) {\n    var entries = iriMap[key];\n    var next = iriMap[key] = {};\n    var iri;\n    var letter;\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = entries[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var entry = _step3.value;\n        iri = entry.iri;\n\n        if (idx >= iri.length) {\n          letter = '';\n        } else {\n          letter = iri[idx];\n        }\n\n        if (letter in next) {\n          next[letter].push(entry);\n        } else {\n          next[letter] = [entry];\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    for (var _key2 in next) {\n      if (_key2 === '') {\n        continue;\n      }\n\n      _buildIriMap(next, _key2, idx + 1);\n    }\n  }\n  /**\n   * Adds the term for the given entry if not already added.\n   *\n   * @param term the term to add.\n   * @param entry the inverse context typeOrLanguage entry to add to.\n   * @param typeOrLanguageValue the key in the entry to add to.\n   */\n\n\n  function _addPreferredTerm(term, entry, typeOrLanguageValue) {\n    if (!entry.hasOwnProperty(typeOrLanguageValue)) {\n      entry[typeOrLanguageValue] = term;\n    }\n  }\n  /**\n   * Clones an active context, creating a child active context.\n   *\n   * @return a clone (child) of the active context.\n   */\n\n\n  function _cloneActiveContext() {\n    var child = {};\n    child['@base'] = this['@base'];\n    child.mappings = util.clone(this.mappings);\n    child.clone = this.clone;\n    child.inverse = null;\n    child.getInverse = this.getInverse;\n    child.protected = util.clone(this.protected);\n\n    if (this.previousContext) {\n      child.isPropertyTermScoped = this.previousContext.isPropertyTermScoped;\n      child.previousContext = this.previousContext.clone();\n    }\n\n    child.revertTypeScopedContext = this.revertTypeScopedContext;\n\n    if ('@language' in this) {\n      child['@language'] = this['@language'];\n    }\n\n    if ('@vocab' in this) {\n      child['@vocab'] = this['@vocab'];\n    }\n\n    return child;\n  }\n  /**\n   * Reverts any type-scoped context in this active context to the previous\n   * context.\n   */\n\n\n  function _revertTypeScopedContext() {\n    if (!this.previousContext) {\n      return this;\n    }\n\n    return this.previousContext.clone();\n  }\n};\n/**\n * Gets the value for the given active context key and type, null if none is\n * set or undefined if none is set and type is '@context'.\n *\n * @param ctx the active context.\n * @param key the context key.\n * @param [type] the type of value to get (eg: '@id', '@type'), if not\n *          specified gets the entire entry for a key, null if not found.\n *\n * @return the value, null, or undefined.\n */\n\n\napi.getContextValue = function (ctx, key, type) {\n  // invalid key\n  if (key === null) {\n    if (type === '@context') {\n      return undefined;\n    }\n\n    return null;\n  } // get specific entry information\n\n\n  if (ctx.mappings.has(key)) {\n    var entry = ctx.mappings.get(key);\n\n    if (_isUndefined(type)) {\n      // return whole entry\n      return entry;\n    }\n\n    if (entry.hasOwnProperty(type)) {\n      // return entry value for type\n      return entry[type];\n    }\n  } // get default language\n\n\n  if (type === '@language' && ctx.hasOwnProperty(type)) {\n    return ctx[type];\n  }\n\n  if (type === '@context') {\n    return undefined;\n  }\n\n  return null;\n};\n/**\n * Retrieves external @context URLs using the given document loader. Every\n * instance of @context in the input that refers to a URL will be replaced\n * with the JSON @context found at that URL.\n *\n * @param input the JSON-LD input with possible contexts.\n * @param options the options to use:\n *          documentLoader(url, [callback(err, remoteDoc)]) the document loader.\n * @param callback(err, input) called once the operation completes.\n */\n\n\napi.getAllContexts = function _callee(input, options) {\n  return _regeneratorRuntime.async(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", _retrieveContextUrls(input, options));\n\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  });\n};\n/**\n * Processing Mode check.\n *\n * @param activeCtx the current active context.\n * @param version the string or numeric version to check.\n *\n * @return boolean.\n */\n\n\napi.processingMode = function (activeCtx, version) {\n  if (version.toString() >= '1.1') {\n    return activeCtx.processingMode && activeCtx.processingMode >= 'json-ld-' + version.toString();\n  } else {\n    return !activeCtx.processingMode || activeCtx.processingMode === 'json-ld-1.0';\n  }\n};\n/**\n * Returns whether or not the given value is a keyword.\n *\n * @param v the value to check.\n *\n * @return true if the value is a keyword, false if not.\n */\n\n\napi.isKeyword = function (v) {\n  if (!_isString(v)) {\n    return false;\n  }\n\n  switch (v) {\n    case '@base':\n    case '@container':\n    case '@context':\n    case '@default':\n    case '@embed':\n    case '@explicit':\n    case '@graph':\n    case '@id':\n    case '@index':\n    case '@json':\n    case '@language':\n    case '@list':\n    case '@nest':\n    case '@none':\n    case '@omitDefault':\n    case '@prefix':\n    case '@preserve':\n    case '@protected':\n    case '@requireAll':\n    case '@reverse':\n    case '@set':\n    case '@type':\n    case '@value':\n    case '@version':\n    case '@vocab':\n      return true;\n  }\n\n  return false;\n};\n\nfunction _retrieveContextUrls(input, options) {\n  var documentLoader, retrieve;\n  return _regeneratorRuntime.async(function _retrieveContextUrls$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          retrieve = function _ref5(doc, cycles, documentLoader) {\n            var urls, queue;\n            return _regeneratorRuntime.async(function retrieve$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    if (!(cycles.size > MAX_CONTEXT_URLS)) {\n                      _context3.next = 2;\n                      break;\n                    }\n\n                    throw new JsonLdError('Maximum number of @context URLs exceeded.', 'jsonld.ContextUrlError', {\n                      code: 'loading remote context failed',\n                      max: MAX_CONTEXT_URLS\n                    });\n\n                  case 2:\n                    // find all URLs in the given document\n                    urls = new Map();\n\n                    _findContextUrls(doc, urls, false, options.base);\n\n                    if (!(urls.size === 0)) {\n                      _context3.next = 6;\n                      break;\n                    }\n\n                    return _context3.abrupt(\"return\");\n\n                  case 6:\n                    // queue all unretrieved URLs\n                    queue = _toConsumableArray(urls.keys()).filter(function (u) {\n                      return urls.get(u) === false;\n                    }); // retrieve URLs in queue\n\n                    return _context3.abrupt(\"return\", Promise.all(queue.map(function _callee2(url) {\n                      var _cycles, remoteDoc, ctx;\n\n                      return _regeneratorRuntime.async(function _callee2$(_context2) {\n                        while (1) {\n                          switch (_context2.prev = _context2.next) {\n                            case 0:\n                              if (!cycles.has(url)) {\n                                _context2.next = 2;\n                                break;\n                              }\n\n                              throw new JsonLdError('Cyclical @context URLs detected.', 'jsonld.ContextUrlError', {\n                                code: 'recursive context inclusion',\n                                url: url\n                              });\n\n                            case 2:\n                              _cycles = new Set(cycles);\n\n                              _cycles.add(url);\n\n                              _context2.prev = 4;\n                              _context2.next = 7;\n                              return _regeneratorRuntime.awrap(documentLoader(url));\n\n                            case 7:\n                              remoteDoc = _context2.sent;\n                              ctx = remoteDoc.document || null; // parse string context as JSON\n\n                              if (_isString(ctx)) {\n                                ctx = JSON.parse(ctx);\n                              }\n\n                              _context2.next = 15;\n                              break;\n\n                            case 12:\n                              _context2.prev = 12;\n                              _context2.t0 = _context2[\"catch\"](4);\n                              throw new JsonLdError('Dereferencing a URL did not result in a valid JSON-LD object. ' + 'Possible causes are an inaccessible URL perhaps due to ' + 'a same-origin policy (ensure the server uses CORS if you are ' + 'using client-side JavaScript), too many redirects, a ' + 'non-JSON response, or more than one HTTP Link Header was ' + 'provided for a remote context.', 'jsonld.InvalidUrl', {\n                                code: 'loading remote context failed',\n                                url: url,\n                                cause: _context2.t0\n                              });\n\n                            case 15:\n                              if (_isObject(ctx)) {\n                                _context2.next = 17;\n                                break;\n                              }\n\n                              throw new JsonLdError('Dereferencing a URL did not result in a JSON object. The ' + 'response was valid JSON, but it was not a JSON object.', 'jsonld.InvalidUrl', {\n                                code: 'invalid remote context',\n                                url: url\n                              });\n\n                            case 17:\n                              // use empty context if no @context key is present\n                              if (!('@context' in ctx)) {\n                                ctx = {\n                                  '@context': {}\n                                };\n                              } else {\n                                ctx = {\n                                  '@context': ctx['@context']\n                                };\n                              } // append @context URL to context if given\n\n\n                              if (remoteDoc.contextUrl) {\n                                if (!_isArray(ctx['@context'])) {\n                                  ctx['@context'] = [ctx['@context']];\n                                }\n\n                                ctx['@context'].push(remoteDoc.contextUrl);\n                              } // recurse\n\n\n                              _context2.next = 21;\n                              return _regeneratorRuntime.awrap(retrieve(ctx, _cycles, documentLoader));\n\n                            case 21:\n                              // store retrieved context w/replaced @context URLs\n                              urls.set(url, ctx['@context']); // replace all @context URLs in the document\n\n                              _findContextUrls(doc, urls, true, options.base);\n\n                            case 23:\n                            case \"end\":\n                              return _context2.stop();\n                          }\n                        }\n                      }, null, null, [[4, 12]]);\n                    })));\n\n                  case 8:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            });\n          };\n\n          documentLoader = util.normalizeDocumentLoader(options.documentLoader); // retrieve all @context URLs in input\n\n          _context4.next = 4;\n          return _regeneratorRuntime.awrap(retrieve(input, new Set(), documentLoader));\n\n        case 4:\n          return _context4.abrupt(\"return\", input);\n\n        case 5:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  });\n}\n/**\n * Finds all @context URLs in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param urls a map of URLs (url => false/@contexts).\n * @param replace true to replace the URLs in the given input with the\n *           @contexts from the urls map, false not to.\n * @param base the base IRI to use to resolve relative IRIs.\n *\n * @return true if new URLs to retrieve were found, false if not.\n */\n\n\nfunction _findContextUrls(input, urls, replace, base) {\n  if (_isArray(input)) {\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = input[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var element = _step4.value;\n\n        _findContextUrls(element, urls, replace, base);\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    return;\n  }\n\n  if (!_isObject(input)) {\n    // no @context URLs can be found in non-object input\n    return;\n  } // input is an object\n\n\n  for (var key in input) {\n    if (key !== '@context') {\n      _findContextUrls(input[key], urls, replace, base);\n\n      continue;\n    } // get @context\n\n\n    var ctx = input[key];\n\n    if (_isArray(ctx)) {\n      // array @context\n      var length = ctx.length;\n\n      for (var i = 0; i < length; ++i) {\n        var _ctx = ctx[i];\n\n        if (_isString(_ctx)) {\n          var prepended = prependBase(base, _ctx);\n          var resolved = urls.get(prepended); // replace w/@context if requested\n\n          if (replace) {\n            if (_isArray(resolved)) {\n              // add flattened context\n              Array.prototype.splice.apply(ctx, [i, 1].concat(resolved));\n              i += resolved.length - 1;\n              length = ctx.length;\n            } else if (resolved !== false) {\n              ctx[i] = resolved;\n            }\n          } else if (resolved === undefined) {\n            // @context URL found\n            urls.set(prepended, false);\n          }\n        } else {\n          // look for scoped context\n          for (var _key3 in _ctx) {\n            if (_isObject(_ctx[_key3])) {\n              _findContextUrls(_ctx[_key3], urls, replace, base);\n            }\n          }\n        }\n      }\n    } else if (_isString(ctx)) {\n      // string @context\n      var _prepended = prependBase(base, ctx);\n\n      var _resolved = urls.get(_prepended); // replace w/@context if requested\n\n\n      if (replace) {\n        if (_resolved !== false) {\n          input[key] = _resolved;\n        }\n      } else if (_resolved === undefined) {\n        // @context URL found\n        urls.set(_prepended, false);\n      }\n    } else {\n      // look for scoped context\n      for (var _key4 in ctx) {\n        if (_isObject(ctx[_key4])) {\n          _findContextUrls(ctx[_key4], urls, replace, base);\n        }\n      }\n    }\n  }\n}\n\nfunction _deepCompare(x1, x2) {\n  // compare `null` or primitive types directly\n  if (!(x1 && typeof x1 === 'object') || !(x2 && typeof x2 === 'object')) {\n    return x1 === x2;\n  } // x1 and x2 are objects (also potentially arrays)\n\n\n  var x1Array = Array.isArray(x1);\n\n  if (x1Array !== Array.isArray(x2)) {\n    return false;\n  }\n\n  if (x1Array) {\n    if (x1.length !== x2.length) {\n      return false;\n    }\n\n    for (var i = 0; i < x1.length; ++i) {\n      if (!_deepCompare(x1[i], x2[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  } // x1 and x2 are non-array objects\n\n\n  var k1s = Object.keys(x1);\n  var k2s = Object.keys(x2);\n\n  if (k1s.length !== k2s.length) {\n    return false;\n  }\n\n  for (var k1 in x1) {\n    var v1 = x1[k1];\n    var v2 = x2[k1]; // special case: `@container` can be in any order\n\n    if (k1 === '@container') {\n      if (Array.isArray(v1) && Array.isArray(v2)) {\n        v1 = v1.slice().sort();\n        v2 = v2.slice().sort();\n      }\n    }\n\n    if (!_deepCompare(v1, v2)) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Guillaume/Code/e-commerce/admin/node_modules/jsonld/lib/context.js"],"names":["util","require","ActiveContextCache","JsonLdError","_isArray","isArray","_isObject","isObject","_isString","isString","_isUndefined","isUndefined","_isAbsoluteIri","isAbsolute","_isRelativeIri","isRelative","prependBase","parseUrl","parse","_asArray","asArray","_compareShortestLeast","compareShortestLeast","MAX_CONTEXT_URLS","INITIAL_CONTEXT_CACHE","Map","INITIAL_CONTEXT_CACHE_MAX_SIZE","api","module","exports","cache","process","activeCtx","localCtx","options","isPropertyTermScopedContext","isTypeScopedContext","ctxs","length","previousContext","clone","isPropertyTermScoped","rval","i","ctx","Object","keys","protected","protectedMode","code","console","warn","oldActiveCtx","getInitialContext","entries","term","_protected","mappings","set","context","cached","get","defined","processingMode","base","href","value","toLowerCase","key","createTermDefinition","has","isKeyword","previousMapping","delete","hasOwnProperty","simpleTerm","mapping","reverse","validKeys","push","kw","includes","colon","indexOf","_termHasColon","id","_expandIri","vocab","_prefix","match","prefix","substr","suffix","type","container","validContainers","isValid","hasSet","some","every","c","join","language","nest","_deepCompare","expandIri","relativeTo","undefined","JSON","stringify","initialContext","inverse","getInverse","_createInverseContext","_cloneActiveContext","revertTypeScopedContext","_revertTypeScopedContext","size","clear","fastCurieMap","irisToTerms","defaultLanguage","terms","sort","concat","ids","iri","entry","fastCurieEntry","_addPreferredTerm","_buildIriMap","iriMap","idx","next","letter","typeOrLanguageValue","child","getContextValue","getAllContexts","input","_retrieveContextUrls","version","toString","v","retrieve","doc","cycles","documentLoader","max","urls","_findContextUrls","queue","filter","u","Promise","all","map","url","_cycles","Set","add","remoteDoc","document","cause","contextUrl","normalizeDocumentLoader","replace","element","_ctx","prepended","resolved","Array","prototype","splice","apply","x1","x2","x1Array","k1s","k2s","k1","v1","v2","slice"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst util = require('./util');\nconst ActiveContextCache = require('./ActiveContextCache');\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isAbsolute: _isAbsoluteIri,\n  isRelative: _isRelativeIri,\n  prependBase,\n  parse: parseUrl\n} = require('./url');\n\nconst {\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst MAX_CONTEXT_URLS = 10;\n\nconst INITIAL_CONTEXT_CACHE = new Map();\nconst INITIAL_CONTEXT_CACHE_MAX_SIZE = 10000;\n\nconst api = {};\nmodule.exports = api;\n\napi.cache = new ActiveContextCache();\n\n/**\n * Processes a local context and returns a new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param options the context processing options.\n * @param isPropertyTermScopedContext `true` if `localCtx` is a scoped context\n *   from a property term.\n * @param isTypeScopedContext `true` if `localCtx` is a scoped context\n *   from a type.\n *\n * @return the new active context.\n */\napi.process = ({\n  activeCtx, localCtx, options,\n  isPropertyTermScopedContext = false,\n  isTypeScopedContext = false\n}) => {\n  // normalize local context to an array of @context objects\n  if(_isObject(localCtx) && '@context' in localCtx &&\n    _isArray(localCtx['@context'])) {\n    localCtx = localCtx['@context'];\n  }\n  const ctxs = _asArray(localCtx);\n\n  // no contexts in array, return current active context w/o changes\n  if(ctxs.length === 0) {\n    return activeCtx;\n  }\n\n  // track the previous context\n  const previousContext = activeCtx.previousContext || activeCtx;\n\n  // if context is property scoped and there's a previous context, amend it,\n  // not the current one\n  if(isPropertyTermScopedContext && activeCtx.previousContext) {\n    // TODO: consider optimizing to a shallow copy\n    activeCtx = activeCtx.clone();\n    activeCtx.isPropertyTermScoped = true;\n    activeCtx.previousContext = api.process({\n      activeCtx: activeCtx.previousContext,\n      localCtx: ctxs,\n      options,\n      isPropertyTermScopedContext\n    });\n    return activeCtx;\n  }\n\n  // process each context in order, update active context\n  // on each iteration to ensure proper caching\n  let rval = activeCtx;\n  for(let i = 0; i < ctxs.length; ++i) {\n    let ctx = ctxs[i];\n\n    // update active context to one computed from last iteration\n    activeCtx = rval;\n\n    // reset to initial context\n    if(ctx === null) {\n      // We can't nullify if there are protected terms and we're\n      // not processing a property term scoped context\n      if(!isPropertyTermScopedContext &&\n        Object.keys(activeCtx.protected).length !== 0) {\n        const protectedMode = (options && options.protectedMode) || 'error';\n        if(protectedMode === 'error') {\n          throw new JsonLdError(\n            'Tried to nullify a context with protected terms outside of ' +\n            'a term definition.',\n            'jsonld.SyntaxError',\n            {code: 'invalid context nullification'});\n        } else if(protectedMode === 'warn') {\n          // FIXME: remove logging and use a handler\n          console.warn('WARNING: invalid context nullification');\n          const oldActiveCtx = activeCtx;\n          // copy all protected term definitions to fresh initial context\n          rval = activeCtx = api.getInitialContext(options).clone();\n          for(const [term, _protected] of\n            Object.entries(oldActiveCtx.protected)) {\n            if(_protected) {\n              activeCtx.mappings[term] =\n                util.clone(oldActiveCtx.mappings[term]);\n            }\n          }\n          activeCtx.protected = util.clone(oldActiveCtx.protected);\n\n          // cache result\n          if(api.cache) {\n            api.cache.set(oldActiveCtx, ctx, rval);\n          }\n\n          continue;\n        }\n        throw new JsonLdError(\n          'Invalid protectedMode.',\n          'jsonld.SyntaxError',\n          {code: 'invalid protected mode', context: localCtx, protectedMode});\n      }\n      rval = activeCtx = api.getInitialContext(options).clone();\n      // if context is type-scoped, ensure previous context has been set\n      if(isTypeScopedContext) {\n        rval.previousContext = previousContext.clone();\n      }\n      continue;\n    }\n\n    // get context from cache if available\n    if(api.cache) {\n      const cached = api.cache.get(activeCtx, ctx);\n      if(cached) {\n        rval = activeCtx = cached;\n        continue;\n      }\n    }\n\n    // dereference @context key if present\n    if(_isObject(ctx) && '@context' in ctx) {\n      ctx = ctx['@context'];\n    }\n\n    // context must be an object by now, all URLs retrieved before this call\n    if(!_isObject(ctx)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context must be an object.',\n        'jsonld.SyntaxError', {code: 'invalid local context', context: ctx});\n    }\n\n    // TODO: there is likely a `preivousContext` cloning optimization that\n    // could be applied here (no need to copy it under certain conditions)\n\n    // clone context before updating it\n    rval = rval.clone();\n\n    // define context mappings for keys in local context\n    const defined = new Map();\n\n    // handle @version\n    if('@version' in ctx) {\n      if(ctx['@version'] !== 1.1) {\n        throw new JsonLdError(\n          'Unsupported JSON-LD version: ' + ctx['@version'],\n          'jsonld.UnsupportedVersion',\n          {code: 'invalid @version value', context: ctx});\n      }\n      if(activeCtx.processingMode &&\n        activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          '@version: ' + ctx['@version'] + ' not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.ProcessingModeConflict',\n          {code: 'processing mode conflict', context: ctx});\n      }\n      rval.processingMode = 'json-ld-1.1';\n      rval['@version'] = ctx['@version'];\n      defined.set('@version', true);\n    }\n\n    // if not set explicitly, set processingMode to \"json-ld-1.0\"\n    rval.processingMode =\n      rval.processingMode || activeCtx.processingMode || 'json-ld-1.0';\n\n    // handle @base\n    if('@base' in ctx) {\n      let base = ctx['@base'];\n\n      if(base === null) {\n        // no action\n      } else if(_isAbsoluteIri(base)) {\n        base = parseUrl(base);\n      } else if(_isRelativeIri(base)) {\n        base = parseUrl(prependBase(activeCtx['@base'].href, base));\n      } else {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@base\" in a ' +\n          '@context must be an absolute IRI, a relative IRI, or null.',\n          'jsonld.SyntaxError', {code: 'invalid base IRI', context: ctx});\n      }\n\n      rval['@base'] = base;\n      defined.set('@base', true);\n    }\n\n    // handle @vocab\n    if('@vocab' in ctx) {\n      const value = ctx['@vocab'];\n      if(value === null) {\n        delete rval['@vocab'];\n      } else if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@vocab\" in a ' +\n          '@context must be a string or null.',\n          'jsonld.SyntaxError', {code: 'invalid vocab mapping', context: ctx});\n      } else if(!_isAbsoluteIri(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@vocab\" in a ' +\n          '@context must be an absolute IRI.',\n          'jsonld.SyntaxError', {code: 'invalid vocab mapping', context: ctx});\n      } else {\n        rval['@vocab'] = value;\n      }\n      defined.set('@vocab', true);\n    }\n\n    // handle @language\n    if('@language' in ctx) {\n      const value = ctx['@language'];\n      if(value === null) {\n        delete rval['@language'];\n      } else if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@language\" in a ' +\n          '@context must be a string or null.',\n          'jsonld.SyntaxError',\n          {code: 'invalid default language', context: ctx});\n      } else {\n        rval['@language'] = value.toLowerCase();\n      }\n      defined.set('@language', true);\n    }\n\n    // handle @protected; determine whether this sub-context is declaring\n    // all its terms to be \"protected\" (exceptions can be made on a\n    // per-definition basis)\n    defined.set('@protected', ctx['@protected'] || false);\n\n    // process all other keys\n    for(const key in ctx) {\n      api.createTermDefinition(\n        rval, ctx, key, defined, options,\n        isPropertyTermScopedContext);\n    }\n\n    // if context is type-scoped, ensure previous context has been set\n    if(isTypeScopedContext && !rval.previousContext) {\n      rval.previousContext = previousContext.clone();\n    }\n\n    // cache result\n    if(api.cache) {\n      api.cache.set(activeCtx, ctx, rval);\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Creates a term definition during context processing.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context being processed.\n * @param term the term in the local context to define the mapping for.\n * @param defined a map of defining/defined keys to detect cycles and prevent\n *          double definitions.\n * @param {Object} [options] - creation options.\n * @param {string} [options.protectedMode=\"error\"] - \"error\" to throw error\n *   on `@protected` constraint violation, \"warn\" to allow violations and\n *   signal a warning.\n * @param isPropertyTermScopedContext `true` if `localCtx` is a scoped context\n *   from a property term.\n */\napi.createTermDefinition = (\n  activeCtx, localCtx, term, defined, options,\n  isPropertyTermScopedContext = false) => {\n  if(defined.has(term)) {\n    // term already defined\n    if(defined.get(term)) {\n      return;\n    }\n    // cycle detected\n    throw new JsonLdError(\n      'Cyclical context definition detected.',\n      'jsonld.CyclicalContext',\n      {code: 'cyclic IRI mapping', context: localCtx, term});\n  }\n\n  // now defining term\n  defined.set(term, false);\n\n  if(api.isKeyword(term)) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; keywords cannot be overridden.',\n      'jsonld.SyntaxError',\n      {code: 'keyword redefinition', context: localCtx, term});\n  }\n\n  if(term === '') {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; a term cannot be an empty string.',\n      'jsonld.SyntaxError',\n      {code: 'invalid term definition', context: localCtx});\n  }\n\n  // keep reference to previous mapping for potential `@protected` check\n  const previousMapping = activeCtx.mappings.get(term);\n\n  // remove old mapping\n  if(activeCtx.mappings.has(term)) {\n    activeCtx.mappings.delete(term);\n  }\n\n  // get context term value\n  let value;\n  if(localCtx.hasOwnProperty(term)) {\n    value = localCtx[term];\n  }\n\n  // clear context entry\n  if(value === null || (_isObject(value) && value['@id'] === null)) {\n    activeCtx.mappings.set(term, null);\n    defined.set(term, true);\n    return;\n  }\n\n  // convert short-hand value to object w/@id\n  let simpleTerm = false;\n  if(_isString(value)) {\n    simpleTerm = true;\n    value = {'@id': value};\n  }\n\n  if(!_isObject(value)) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; @context term values must be ' +\n      'strings or objects.',\n      'jsonld.SyntaxError',\n      {code: 'invalid term definition', context: localCtx});\n  }\n\n  // create new mapping\n  const mapping = {};\n  activeCtx.mappings.set(term, mapping);\n  mapping.reverse = false;\n\n  // make sure term definition only has expected keywords\n  const validKeys = ['@container', '@id', '@language', '@reverse', '@type'];\n\n  // JSON-LD 1.1 support\n  if(api.processingMode(activeCtx, 1.1)) {\n    validKeys.push('@context', '@nest', '@prefix', '@protected');\n  }\n\n  for(const kw in value) {\n    if(!validKeys.includes(kw)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a term definition must not contain ' + kw,\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n  }\n\n  // always compute whether term has a colon as an optimization for\n  // _compactIri\n  const colon = term.indexOf(':');\n  mapping._termHasColon = (colon !== -1);\n\n  if('@reverse' in value) {\n    if('@id' in value) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @reverse term definition must not ' +\n        'contain @id.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n    if('@nest' in value) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @reverse term definition must not ' +\n        'contain @nest.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n    const reverse = value['@reverse'];\n    if(!_isString(reverse)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @reverse value must be a string.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n\n    // expand and add @id mapping\n    const id = _expandIri(\n      activeCtx, reverse, {vocab: true, base: false}, localCtx, defined,\n      options);\n    if(!_isAbsoluteIri(id)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @reverse value must be an ' +\n        'absolute IRI or a blank node identifier.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n    mapping['@id'] = id;\n    mapping.reverse = true;\n  } else if('@id' in value) {\n    let id = value['@id'];\n    if(!_isString(id)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @id value must be an array ' +\n        'of strings or a string.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n    if(id !== term) {\n      // expand and add @id mapping\n      id = _expandIri(\n        activeCtx, id, {vocab: true, base: false}, localCtx, defined, options);\n      if(!_isAbsoluteIri(id) && !api.isKeyword(id)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a @context @id value must be an ' +\n          'absolute IRI, a blank node identifier, or a keyword.',\n          'jsonld.SyntaxError',\n          {code: 'invalid IRI mapping', context: localCtx});\n      }\n      mapping['@id'] = id;\n      // indicate if this term may be used as a compact IRI prefix\n      mapping._prefix = (!mapping._termHasColon &&\n        id.match(/[:\\/\\?#\\[\\]@]$/) &&\n        (simpleTerm || api.processingMode(activeCtx, 1.0)));\n    }\n  }\n\n  if(!('@id' in mapping)) {\n    // see if the term has a prefix\n    if(mapping._termHasColon) {\n      const prefix = term.substr(0, colon);\n      if(localCtx.hasOwnProperty(prefix)) {\n        // define parent prefix\n        api.createTermDefinition(activeCtx, localCtx, prefix, defined, options);\n      }\n\n      if(activeCtx.mappings.has(prefix)) {\n        // set @id based on prefix parent\n        const suffix = term.substr(colon + 1);\n        mapping['@id'] = activeCtx.mappings.get(prefix)['@id'] + suffix;\n      } else {\n        // term is an absolute IRI\n        mapping['@id'] = term;\n      }\n    } else {\n      // non-IRIs *must* define @ids if @vocab is not available\n      if(!('@vocab' in activeCtx)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @context terms must define an @id.',\n          'jsonld.SyntaxError',\n          {code: 'invalid IRI mapping', context: localCtx, term});\n      }\n      // prepend vocab to term\n      mapping['@id'] = activeCtx['@vocab'] + term;\n    }\n  }\n\n  // Handle term protection\n  if(value['@protected'] === true ||\n    (defined.get('@protected') === true && value['@protected'] !== false)) {\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n  }\n\n  // IRI mapping now defined\n  defined.set(term, true);\n\n  if('@type' in value) {\n    let type = value['@type'];\n    if(!_isString(type)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an @context @type value must be a string.',\n        'jsonld.SyntaxError',\n        {code: 'invalid type mapping', context: localCtx});\n    }\n\n    if(type !== '@id' && type !== '@vocab' && type !== '@json') {\n      // expand @type to full IRI\n      type = _expandIri(\n        activeCtx, type, {vocab: true, base: false}, localCtx, defined,\n        options);\n      if(!_isAbsoluteIri(type)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must be an ' +\n          'absolute IRI.',\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n      if(type.indexOf('_:') === 0) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must be an IRI, ' +\n          'not a blank node identifier.',\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n    }\n\n    // add @type to mapping\n    mapping['@type'] = type;\n  }\n\n  if('@container' in value) {\n    // normalize container to an array form\n    const container = _isString(value['@container']) ?\n      [value['@container']] : (value['@container'] || []);\n    const validContainers = ['@list', '@set', '@index', '@language'];\n    let isValid = true;\n    const hasSet = container.includes('@set');\n\n    // JSON-LD 1.1 support\n    if(api.processingMode(activeCtx, 1.1)) {\n      validContainers.push('@graph', '@id', '@type');\n\n      // check container length\n      if(container.includes('@list')) {\n        if(container.length !== 1) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; @context @container with @list must ' +\n            'have no other values',\n            'jsonld.SyntaxError',\n            {code: 'invalid container mapping', context: localCtx});\n        }\n      } else if(container.includes('@graph')) {\n        if(container.some(key =>\n          key !== '@graph' && key !== '@id' && key !== '@index' &&\n          key !== '@set')) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; @context @container with @graph must ' +\n            'have no other values other than @id, @index, and @set',\n            'jsonld.SyntaxError',\n            {code: 'invalid container mapping', context: localCtx});\n        }\n      } else {\n        // otherwise, container may also include @set\n        isValid &= container.length <= (hasSet ? 2 : 1);\n      }\n    } else {\n      // in JSON-LD 1.0, container must not be an array (it must be a string,\n      // which is one of the validContainers)\n      isValid &= !_isArray(value['@container']);\n\n      // check container length\n      isValid &= container.length <= 1;\n    }\n\n    // check against valid containers\n    isValid &= container.every(c => validContainers.includes(c));\n\n    // @set not allowed with @list\n    isValid &= !(hasSet && container.includes('@list'));\n\n    if(!isValid) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @container value must be ' +\n        'one of the following: ' + validContainers.join(', '),\n        'jsonld.SyntaxError',\n        {code: 'invalid container mapping', context: localCtx});\n    }\n\n    if(mapping.reverse &&\n      !container.every(c => ['@index', '@set'].includes(c))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @container value for a @reverse ' +\n        'type definition must be @index or @set.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n\n    // add @container to mapping\n    mapping['@container'] = container;\n  }\n\n  // scoped contexts\n  if('@context' in value) {\n    mapping['@context'] = value['@context'];\n  }\n\n  if('@language' in value && !('@type' in value)) {\n    let language = value['@language'];\n    if(language !== null && !_isString(language)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @language value must be ' +\n        'a string or null.', 'jsonld.SyntaxError',\n        {code: 'invalid language mapping', context: localCtx});\n    }\n\n    // add @language to mapping\n    if(language !== null) {\n      language = language.toLowerCase();\n    }\n    mapping['@language'] = language;\n  }\n\n  // term may be used as a prefix\n  if('@prefix' in value) {\n    if(mapping._termHasColon) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @prefix used on a compact IRI term',\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(typeof value['@prefix'] === 'boolean') {\n      mapping._prefix = value['@prefix'] === true;\n    } else {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context value for @prefix must be boolean',\n        'jsonld.SyntaxError',\n        {code: 'invalid @prefix value', context: localCtx});\n    }\n  }\n\n  if('@nest' in value) {\n    const nest = value['@nest'];\n    if(!_isString(nest) || (nest !== '@nest' && nest.indexOf('@') === 0)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @nest value must be ' +\n        'a string which is not a keyword other than @nest.',\n        'jsonld.SyntaxError',\n        {code: 'invalid @nest value', context: localCtx});\n    }\n    mapping['@nest'] = nest;\n  }\n\n  // disallow aliasing @context and @preserve\n  const id = mapping['@id'];\n  if(id === '@context' || id === '@preserve') {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; @context and @preserve cannot be aliased.',\n      'jsonld.SyntaxError', {code: 'invalid keyword alias', context: localCtx});\n  }\n\n  // FIXME if(1.1) ... ?\n  if(previousMapping && previousMapping.protected &&\n    !isPropertyTermScopedContext) {\n    // force new term to continue to be protected and see if the mappings would\n    // be equal\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n    if(!_deepCompare(previousMapping, mapping)) {\n      const protectedMode = (options && options.protectedMode) || 'error';\n      if(protectedMode === 'error') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; tried to redefine a protected term.',\n          'jsonld.SyntaxError',\n          {code: 'protected term redefinition', context: localCtx, term});\n      } else if(protectedMode === 'warn') {\n        // FIXME: remove logging and use a handler\n        console.warn('WARNING: protected term redefinition', {term});\n        return;\n      }\n      throw new JsonLdError(\n        'Invalid protectedMode.',\n        'jsonld.SyntaxError',\n        {code: 'invalid protected mode', context: localCtx, term,\n          protectedMode});\n    }\n  }\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\napi.expandIri = (activeCtx, value, relativeTo, options) => {\n  return _expandIri(activeCtx, value, relativeTo, undefined, undefined,\n    options);\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param localCtx the local context being processed (only given if called\n *          during context processing).\n * @param defined a map for tracking cycles in context definitions (only given\n *          if called during context processing).\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {\n  // already expanded\n  if(value === null || !_isString(value) || api.isKeyword(value)) {\n    return value;\n  }\n\n  // define term dependency if not defined\n  if(localCtx && localCtx.hasOwnProperty(value) &&\n    defined.get(value) !== true) {\n    api.createTermDefinition(activeCtx, localCtx, value, defined, options);\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use previous context instead\n  if(activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  relativeTo = relativeTo || {};\n  if(relativeTo.vocab) {\n    const mapping = activeCtx.mappings.get(value);\n\n    // value is explicitly ignored with a null mapping\n    if(mapping === null) {\n      return null;\n    }\n\n    if(mapping) {\n      // value is a term\n      return mapping['@id'];\n    }\n  }\n\n  // split value into prefix:suffix\n  const colon = value.indexOf(':');\n  if(colon !== -1) {\n    const prefix = value.substr(0, colon);\n    const suffix = value.substr(colon + 1);\n\n    // do not expand blank nodes (prefix of '_') or already-absolute\n    // IRIs (suffix of '//')\n    if(prefix === '_' || suffix.indexOf('//') === 0) {\n      return value;\n    }\n\n    // prefix dependency not defined, define it\n    if(localCtx && localCtx.hasOwnProperty(prefix)) {\n      api.createTermDefinition(activeCtx, localCtx, prefix, defined, options);\n    }\n\n    // use mapping if prefix is defined\n    if(activeCtx.mappings.has(prefix)) {\n      const mapping = activeCtx.mappings.get(prefix);\n      return mapping['@id'] + suffix;\n    }\n\n    // already absolute IRI\n    return value;\n  }\n\n  // prepend vocab\n  if(relativeTo.vocab && '@vocab' in activeCtx) {\n    return activeCtx['@vocab'] + value;\n  }\n\n  // prepend base\n  if(relativeTo.base) {\n    return prependBase(activeCtx['@base'], value);\n  }\n\n  return value;\n}\n\n/**\n * Gets the initial context.\n *\n * @param options the options to use:\n *          [base] the document base IRI.\n *\n * @return the initial context.\n */\napi.getInitialContext = options => {\n  const base = parseUrl(options.base || '');\n  const key = JSON.stringify({base, processingMode: options.processingMode});\n  const cached = INITIAL_CONTEXT_CACHE.get(key);\n  if(cached) {\n    return cached;\n  }\n\n  const initialContext = {\n    '@base': base,\n    processingMode: options.processingMode,\n    mappings: new Map(),\n    inverse: null,\n    getInverse: _createInverseContext,\n    clone: _cloneActiveContext,\n    revertTypeScopedContext: _revertTypeScopedContext,\n    protected: {}\n  };\n  // TODO: consider using LRU cache instead\n  if(INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {\n    // clear whole cache -- assumes scenario where the cache fills means\n    // the cache isn't being used very efficiently anyway\n    INITIAL_CONTEXT_CACHE.clear();\n  }\n  INITIAL_CONTEXT_CACHE.set(key, initialContext);\n  return initialContext;\n\n  /**\n   * Generates an inverse context for use in the compaction algorithm, if\n   * not already generated for the given active context.\n   *\n   * @return the inverse context.\n   */\n  function _createInverseContext() {\n    const activeCtx = this;\n\n    // lazily create inverse\n    if(activeCtx.inverse) {\n      return activeCtx.inverse;\n    }\n    const inverse = activeCtx.inverse = {};\n\n    // variables for building fast CURIE map\n    const fastCurieMap = activeCtx.fastCurieMap = {};\n    const irisToTerms = {};\n\n    // handle default language\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // create term selections for each mapping in the context, ordered by\n    // shortest and then lexicographically least\n    const mappings = activeCtx.mappings;\n    const terms = [...mappings.keys()].sort(_compareShortestLeast);\n    for(const term of terms) {\n      const mapping = mappings.get(term);\n      if(mapping === null) {\n        continue;\n      }\n\n      let container = mapping['@container'] || '@none';\n      container = [].concat(container).sort().join('');\n\n      // iterate over every IRI in the mapping\n      const ids = _asArray(mapping['@id']);\n      for(const iri of ids) {\n        let entry = inverse[iri];\n        const isKeyword = api.isKeyword(iri);\n\n        if(!entry) {\n          // initialize entry\n          inverse[iri] = entry = {};\n\n          if(!isKeyword && !mapping._termHasColon) {\n            // init IRI to term map and fast CURIE prefixes\n            irisToTerms[iri] = [term];\n            const fastCurieEntry = {iri, terms: irisToTerms[iri]};\n            if(iri[0] in fastCurieMap) {\n              fastCurieMap[iri[0]].push(fastCurieEntry);\n            } else {\n              fastCurieMap[iri[0]] = [fastCurieEntry];\n            }\n          }\n        } else if(!isKeyword && !mapping._termHasColon) {\n          // add IRI to term match\n          irisToTerms[iri].push(term);\n        }\n\n        // add new entry\n        if(!entry[container]) {\n          entry[container] = {\n            '@language': {},\n            '@type': {},\n            '@any': {}\n          };\n        }\n        entry = entry[container];\n        _addPreferredTerm(term, entry['@any'], '@none');\n\n        if(mapping.reverse) {\n          // term is preferred for values using @reverse\n          _addPreferredTerm(term, entry['@type'], '@reverse');\n        } else if('@type' in mapping) {\n          // term is preferred for values using specific type\n          _addPreferredTerm(term, entry['@type'], mapping['@type']);\n        } else if('@language' in mapping) {\n          // term is preferred for values using specific language\n          const language = mapping['@language'] || '@null';\n          _addPreferredTerm(term, entry['@language'], language);\n        } else {\n          // term is preferred for values w/default language or no type and\n          // no language\n          // add an entry for the default language\n          _addPreferredTerm(term, entry['@language'], defaultLanguage);\n\n          // add entries for no type and no language\n          _addPreferredTerm(term, entry['@type'], '@none');\n          _addPreferredTerm(term, entry['@language'], '@none');\n        }\n      }\n    }\n\n    // build fast CURIE map\n    for(const key in fastCurieMap) {\n      _buildIriMap(fastCurieMap, key, 1);\n    }\n\n    return inverse;\n  }\n\n  /**\n   * Runs a recursive algorithm to build a lookup map for quickly finding\n   * potential CURIEs.\n   *\n   * @param iriMap the map to build.\n   * @param key the current key in the map to work on.\n   * @param idx the index into the IRI to compare.\n   */\n  function _buildIriMap(iriMap, key, idx) {\n    const entries = iriMap[key];\n    const next = iriMap[key] = {};\n\n    let iri;\n    let letter;\n    for(const entry of entries) {\n      iri = entry.iri;\n      if(idx >= iri.length) {\n        letter = '';\n      } else {\n        letter = iri[idx];\n      }\n      if(letter in next) {\n        next[letter].push(entry);\n      } else {\n        next[letter] = [entry];\n      }\n    }\n\n    for(const key in next) {\n      if(key === '') {\n        continue;\n      }\n      _buildIriMap(next, key, idx + 1);\n    }\n  }\n\n  /**\n   * Adds the term for the given entry if not already added.\n   *\n   * @param term the term to add.\n   * @param entry the inverse context typeOrLanguage entry to add to.\n   * @param typeOrLanguageValue the key in the entry to add to.\n   */\n  function _addPreferredTerm(term, entry, typeOrLanguageValue) {\n    if(!entry.hasOwnProperty(typeOrLanguageValue)) {\n      entry[typeOrLanguageValue] = term;\n    }\n  }\n\n  /**\n   * Clones an active context, creating a child active context.\n   *\n   * @return a clone (child) of the active context.\n   */\n  function _cloneActiveContext() {\n    const child = {};\n    child['@base'] = this['@base'];\n    child.mappings = util.clone(this.mappings);\n    child.clone = this.clone;\n    child.inverse = null;\n    child.getInverse = this.getInverse;\n    child.protected = util.clone(this.protected);\n    if(this.previousContext) {\n      child.isPropertyTermScoped = this.previousContext.isPropertyTermScoped;\n      child.previousContext = this.previousContext.clone();\n    }\n    child.revertTypeScopedContext = this.revertTypeScopedContext;\n    if('@language' in this) {\n      child['@language'] = this['@language'];\n    }\n    if('@vocab' in this) {\n      child['@vocab'] = this['@vocab'];\n    }\n    return child;\n  }\n\n  /**\n   * Reverts any type-scoped context in this active context to the previous\n   * context.\n   */\n  function _revertTypeScopedContext() {\n    if(!this.previousContext) {\n      return this;\n    }\n    return this.previousContext.clone();\n  }\n};\n\n/**\n * Gets the value for the given active context key and type, null if none is\n * set or undefined if none is set and type is '@context'.\n *\n * @param ctx the active context.\n * @param key the context key.\n * @param [type] the type of value to get (eg: '@id', '@type'), if not\n *          specified gets the entire entry for a key, null if not found.\n *\n * @return the value, null, or undefined.\n */\napi.getContextValue = (ctx, key, type) => {\n  // invalid key\n  if(key === null) {\n    if(type === '@context') {\n      return undefined;\n    }\n    return null;\n  }\n\n  // get specific entry information\n  if(ctx.mappings.has(key)) {\n    const entry = ctx.mappings.get(key);\n\n    if(_isUndefined(type)) {\n      // return whole entry\n      return entry;\n    }\n    if(entry.hasOwnProperty(type)) {\n      // return entry value for type\n      return entry[type];\n    }\n  }\n\n  // get default language\n  if(type === '@language' && ctx.hasOwnProperty(type)) {\n    return ctx[type];\n  }\n\n  if(type === '@context') {\n    return undefined;\n  }\n  return null;\n};\n\n/**\n * Retrieves external @context URLs using the given document loader. Every\n * instance of @context in the input that refers to a URL will be replaced\n * with the JSON @context found at that URL.\n *\n * @param input the JSON-LD input with possible contexts.\n * @param options the options to use:\n *          documentLoader(url, [callback(err, remoteDoc)]) the document loader.\n * @param callback(err, input) called once the operation completes.\n */\napi.getAllContexts = async (input, options) => {\n  return _retrieveContextUrls(input, options);\n};\n\n/**\n * Processing Mode check.\n *\n * @param activeCtx the current active context.\n * @param version the string or numeric version to check.\n *\n * @return boolean.\n */\napi.processingMode = (activeCtx, version) => {\n  if(version.toString() >= '1.1') {\n    return activeCtx.processingMode &&\n      activeCtx.processingMode >= 'json-ld-' + version.toString();\n  } else {\n    return !activeCtx.processingMode ||\n      activeCtx.processingMode === 'json-ld-1.0';\n  }\n};\n\n/**\n * Returns whether or not the given value is a keyword.\n *\n * @param v the value to check.\n *\n * @return true if the value is a keyword, false if not.\n */\napi.isKeyword = v => {\n  if(!_isString(v)) {\n    return false;\n  }\n  switch(v) {\n    case '@base':\n    case '@container':\n    case '@context':\n    case '@default':\n    case '@embed':\n    case '@explicit':\n    case '@graph':\n    case '@id':\n    case '@index':\n    case '@json':\n    case '@language':\n    case '@list':\n    case '@nest':\n    case '@none':\n    case '@omitDefault':\n    case '@prefix':\n    case '@preserve':\n    case '@protected':\n    case '@requireAll':\n    case '@reverse':\n    case '@set':\n    case '@type':\n    case '@value':\n    case '@version':\n    case '@vocab':\n      return true;\n  }\n  return false;\n};\n\nasync function _retrieveContextUrls(input, options) {\n  const documentLoader = util.normalizeDocumentLoader(options.documentLoader);\n\n  // retrieve all @context URLs in input\n  await retrieve(input, new Set(), documentLoader);\n\n  return input;\n\n  // recursive function that will retrieve all @context URLs in documents\n  async function retrieve(doc, cycles, documentLoader) {\n    if(cycles.size > MAX_CONTEXT_URLS) {\n      throw new JsonLdError(\n        'Maximum number of @context URLs exceeded.',\n        'jsonld.ContextUrlError',\n        {code: 'loading remote context failed', max: MAX_CONTEXT_URLS});\n    }\n\n    // find all URLs in the given document\n    const urls = new Map();\n    _findContextUrls(doc, urls, false, options.base);\n    if(urls.size === 0) {\n      return;\n    }\n\n    // queue all unretrieved URLs\n    const queue = [...urls.keys()].filter(u => urls.get(u) === false);\n\n    // retrieve URLs in queue\n    return Promise.all(queue.map(async url => {\n      // check for context URL cycle\n      if(cycles.has(url)) {\n        throw new JsonLdError(\n          'Cyclical @context URLs detected.',\n          'jsonld.ContextUrlError',\n          {code: 'recursive context inclusion', url});\n      }\n\n      const _cycles = new Set(cycles);\n      _cycles.add(url);\n      let remoteDoc;\n      let ctx;\n\n      try {\n        remoteDoc = await documentLoader(url);\n        ctx = remoteDoc.document || null;\n        // parse string context as JSON\n        if(_isString(ctx)) {\n          ctx = JSON.parse(ctx);\n        }\n      } catch(e) {\n        throw new JsonLdError(\n          'Dereferencing a URL did not result in a valid JSON-LD object. ' +\n          'Possible causes are an inaccessible URL perhaps due to ' +\n          'a same-origin policy (ensure the server uses CORS if you are ' +\n          'using client-side JavaScript), too many redirects, a ' +\n          'non-JSON response, or more than one HTTP Link Header was ' +\n          'provided for a remote context.',\n          'jsonld.InvalidUrl',\n          {code: 'loading remote context failed', url, cause: e});\n      }\n\n      // ensure ctx is an object\n      if(!_isObject(ctx)) {\n        throw new JsonLdError(\n          'Dereferencing a URL did not result in a JSON object. The ' +\n          'response was valid JSON, but it was not a JSON object.',\n          'jsonld.InvalidUrl',\n          {code: 'invalid remote context', url});\n      }\n\n      // use empty context if no @context key is present\n      if(!('@context' in ctx)) {\n        ctx = {'@context': {}};\n      } else {\n        ctx = {'@context': ctx['@context']};\n      }\n\n      // append @context URL to context if given\n      if(remoteDoc.contextUrl) {\n        if(!_isArray(ctx['@context'])) {\n          ctx['@context'] = [ctx['@context']];\n        }\n        ctx['@context'].push(remoteDoc.contextUrl);\n      }\n\n      // recurse\n      await retrieve(ctx, _cycles, documentLoader);\n\n      // store retrieved context w/replaced @context URLs\n      urls.set(url, ctx['@context']);\n\n      // replace all @context URLs in the document\n      _findContextUrls(doc, urls, true, options.base);\n    }));\n  }\n}\n\n/**\n * Finds all @context URLs in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param urls a map of URLs (url => false/@contexts).\n * @param replace true to replace the URLs in the given input with the\n *           @contexts from the urls map, false not to.\n * @param base the base IRI to use to resolve relative IRIs.\n *\n * @return true if new URLs to retrieve were found, false if not.\n */\nfunction _findContextUrls(input, urls, replace, base) {\n  if(_isArray(input)) {\n    for(const element of input) {\n      _findContextUrls(element, urls, replace, base);\n    }\n    return;\n  }\n\n  if(!_isObject(input)) {\n    // no @context URLs can be found in non-object input\n    return;\n  }\n\n  // input is an object\n  for(const key in input) {\n    if(key !== '@context') {\n      _findContextUrls(input[key], urls, replace, base);\n      continue;\n    }\n\n    // get @context\n    const ctx = input[key];\n\n    if(_isArray(ctx)) {\n      // array @context\n      let length = ctx.length;\n      for(let i = 0; i < length; ++i) {\n        const _ctx = ctx[i];\n        if(_isString(_ctx)) {\n          const prepended = prependBase(base, _ctx);\n          const resolved = urls.get(prepended);\n          // replace w/@context if requested\n          if(replace) {\n            if(_isArray(resolved)) {\n              // add flattened context\n              Array.prototype.splice.apply(ctx, [i, 1].concat(resolved));\n              i += resolved.length - 1;\n              length = ctx.length;\n            } else if(resolved !== false) {\n              ctx[i] = resolved;\n            }\n          } else if(resolved === undefined) {\n            // @context URL found\n            urls.set(prepended, false);\n          }\n        } else {\n          // look for scoped context\n          for(const key in _ctx) {\n            if(_isObject(_ctx[key])) {\n              _findContextUrls(_ctx[key], urls, replace, base);\n            }\n          }\n        }\n      }\n    } else if(_isString(ctx)) {\n      // string @context\n      const prepended = prependBase(base, ctx);\n      const resolved = urls.get(prepended);\n      // replace w/@context if requested\n      if(replace) {\n        if(resolved !== false) {\n          input[key] = resolved;\n        }\n      } else if(resolved === undefined) {\n        // @context URL found\n        urls.set(prepended, false);\n      }\n    } else {\n      // look for scoped context\n      for(const key in ctx) {\n        if(_isObject(ctx[key])) {\n          _findContextUrls(ctx[key], urls, replace, base);\n        }\n      }\n    }\n  }\n}\n\nfunction _deepCompare(x1, x2) {\n  // compare `null` or primitive types directly\n  if((!(x1 && typeof x1 === 'object')) ||\n     (!(x2 && typeof x2 === 'object'))) {\n    return x1 === x2;\n  }\n  // x1 and x2 are objects (also potentially arrays)\n  const x1Array = Array.isArray(x1);\n  if(x1Array !== Array.isArray(x2)) {\n    return false;\n  }\n  if(x1Array) {\n    if(x1.length !== x2.length) {\n      return false;\n    }\n    for(let i = 0; i < x1.length; ++i) {\n      if(!_deepCompare(x1[i], x2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // x1 and x2 are non-array objects\n  const k1s = Object.keys(x1);\n  const k2s = Object.keys(x2);\n  if(k1s.length !== k2s.length) {\n    return false;\n  }\n  for(const k1 in x1) {\n    let v1 = x1[k1];\n    let v2 = x2[k1];\n    // special case: `@container` can be in any order\n    if(k1 === '@container') {\n      if(Array.isArray(v1) && Array.isArray(v2)) {\n        v1 = v1.slice().sort();\n        v2 = v2.slice().sort();\n      }\n    }\n    if(!_deepCompare(v1, v2)) {\n      return false;\n    }\n  }\n  return true;\n}\n"]},"metadata":{},"sourceType":"script"}