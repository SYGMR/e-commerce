{"ast":null,"code":"var _objectWithoutProperties = require(\"C:\\\\Users\\\\Guillaume\\\\Code\\\\e-commerce\\\\admin\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectWithoutProperties\");\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Guillaume\\\\Code\\\\e-commerce\\\\admin\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\n/**\n * A JavaScript implementation of the JSON-LD API.\n *\n * @author Dave Longley\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2011-2017 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nvar canonize = require('rdf-canonize');\n\nvar util = require('./util');\n\nvar IdentifierIssuer = util.IdentifierIssuer;\n\nvar JsonLdError = require('./JsonLdError');\n\nvar NQuads = require('./NQuads');\n\nvar Rdfa = require('./Rdfa');\n\nvar _require = require('./expand'),\n    _expand = _require.expand;\n\nvar _require2 = require('./flatten'),\n    _flatten = _require2.flatten;\n\nvar _require3 = require('./fromRdf'),\n    _fromRDF = _require3.fromRDF;\n\nvar _require4 = require('./toRdf'),\n    _toRDF = _require4.toRDF;\n\nvar _require5 = require('./frame'),\n    _frameMergedOrDefault = _require5.frameMergedOrDefault;\n\nvar _require6 = require('./types'),\n    _isArray = _require6.isArray,\n    _isObject = _require6.isObject,\n    _isString = _require6.isString;\n\nvar _require7 = require('./graphTypes'),\n    _isSubjectReference = _require7.isSubjectReference;\n\nvar _require8 = require('./context'),\n    _getInitialContext = _require8.getInitialContext,\n    _processContext = _require8.process,\n    _getAllContexts = _require8.getAllContexts;\n\nvar _require9 = require('./compact'),\n    _compact = _require9.compact,\n    _compactIri = _require9.compactIri,\n    _removePreserve = _require9.removePreserve;\n\nvar _require10 = require('./nodeMap'),\n    _createNodeMap = _require10.createNodeMap,\n    _createMergedNodeMap = _require10.createMergedNodeMap,\n    _mergeNodeMaps = _require10.mergeNodeMaps; // determine if in-browser or using node.js\n\n\nvar _nodejs = typeof process !== 'undefined' && process.versions && process.versions.node;\n\nvar _browser = !_nodejs && (typeof window !== 'undefined' || typeof self !== 'undefined');\n/* eslint-disable indent */\n// attaches jsonld API to the given object\n\n\nvar wrapper = function wrapper(jsonld) {\n  /** Registered RDF dataset parsers hashed by content-type. */\n  var _rdfParsers = {};\n  /* Core API */\n\n  /**\n   * Performs JSON-LD compaction.\n   *\n   * @param input the JSON-LD input to compact.\n   * @param ctx the context to compact with.\n   * @param [options] options to use:\n   *          [base] the base IRI to use.\n   *          [compactArrays] true to compact arrays to single values when\n   *            appropriate, false not to (default: true).\n   *          [compactToRelative] true to compact IRIs to be relative to document\n   *            base, false to keep absolute (default: true)\n   *          [graph] true to always output a top-level graph (default: false).\n   *          [expandContext] a context to expand with.\n   *          [skipExpansion] true to assume the input is expanded and skip\n   *            expansion, false not to, defaults to false.\n   *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n   *          [expansionMap(info)] a function that can be used to custom map\n   *            unmappable values (or to throw an error when they are detected);\n   *            if this function returns `undefined` then the default behavior\n   *            will be used.\n   *          [framing] true if compaction is occuring during a framing operation.\n   *          [compactionMap(info)] a function that can be used to custom map\n   *            unmappable values (or to throw an error when they are detected);\n   *            if this function returns `undefined` then the default behavior\n   *            will be used.\n   * @param [callback(err, compacted)] called once the operation completes.\n   *\n   * @return a Promise that resolves to the compacted output.\n   */\n\n  jsonld.compact = util.callbackify(function _callee(input, ctx, options) {\n    var expanded,\n        activeCtx,\n        compacted,\n        tmp,\n        i,\n        hasContext,\n        graphAlias,\n        graph,\n        _graph,\n        key,\n        _graph2,\n        _args = arguments;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(_args.length < 2)) {\n              _context.next = 2;\n              break;\n            }\n\n            throw new TypeError('Could not compact, too few arguments.');\n\n          case 2:\n            if (!(ctx === null)) {\n              _context.next = 4;\n              break;\n            }\n\n            throw new JsonLdError('The compaction context must not be null.', 'jsonld.CompactError', {\n              code: 'invalid local context'\n            });\n\n          case 4:\n            if (!(input === null)) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\", null);\n\n          case 6:\n            // set default options\n            options = _setDefaults(options, {\n              base: _isString(input) ? input : '',\n              compactArrays: true,\n              compactToRelative: true,\n              graph: false,\n              skipExpansion: false,\n              link: false,\n              issuer: new IdentifierIssuer('_:b')\n            });\n\n            if (options.link) {\n              // force skip expansion when linking, \"link\" is not part of the public\n              // API, it should only be called from framing\n              options.skipExpansion = true;\n            }\n\n            if (!options.compactToRelative) {\n              delete options.base;\n            } // expand input\n\n\n            if (!options.skipExpansion) {\n              _context.next = 13;\n              break;\n            }\n\n            expanded = input;\n            _context.next = 16;\n            break;\n\n          case 13:\n            _context.next = 15;\n            return _regeneratorRuntime.awrap(jsonld.expand(input, options));\n\n          case 15:\n            expanded = _context.sent;\n\n          case 16:\n            _context.next = 18;\n            return _regeneratorRuntime.awrap(jsonld.processContext(_getInitialContext(options), ctx, options));\n\n          case 18:\n            activeCtx = _context.sent;\n            // do compaction\n            compacted = _compact({\n              activeCtx: activeCtx,\n              element: expanded,\n              options: options,\n              compactionMap: options.compactionMap\n            }); // perform clean up\n\n            if (options.compactArrays && !options.graph && _isArray(compacted)) {\n              if (compacted.length === 1) {\n                // simplify to a single item\n                compacted = compacted[0];\n              } else if (compacted.length === 0) {\n                // simplify to an empty object\n                compacted = {};\n              }\n            } else if (options.graph && _isObject(compacted)) {\n              // always use array if graph option is on\n              compacted = [compacted];\n            } // follow @context key\n\n\n            if (_isObject(ctx) && '@context' in ctx) {\n              ctx = ctx['@context'];\n            } // build output context\n\n\n            ctx = util.clone(ctx);\n\n            if (!_isArray(ctx)) {\n              ctx = [ctx];\n            } // remove empty contexts\n\n\n            tmp = ctx;\n            ctx = [];\n\n            for (i = 0; i < tmp.length; ++i) {\n              if (!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {\n                ctx.push(tmp[i]);\n              }\n            } // remove array if only one context\n\n\n            hasContext = ctx.length > 0;\n\n            if (ctx.length === 1) {\n              ctx = ctx[0];\n            } // add context and/or @graph\n\n\n            if (_isArray(compacted)) {\n              // use '@graph' keyword\n              graphAlias = _compactIri({\n                activeCtx: activeCtx,\n                iri: '@graph',\n                relativeTo: {\n                  vocab: true\n                }\n              });\n              graph = compacted;\n              compacted = {};\n\n              if (hasContext) {\n                compacted['@context'] = ctx;\n              }\n\n              compacted[graphAlias] = graph;\n            } else if (_isObject(compacted) && hasContext) {\n              // reorder keys so @context is first\n              _graph = compacted;\n              compacted = {\n                '@context': ctx\n              };\n\n              for (key in _graph) {\n                compacted[key] = _graph[key];\n              }\n            }\n\n            if (options.framing) {\n              // get graph alias\n              _graph2 = _compactIri({\n                activeCtx: activeCtx,\n                iri: '@graph',\n                relativeTo: {\n                  vocab: true\n                }\n              }); // remove @preserve from results\n\n              options.link = {};\n              compacted[_graph2] = _removePreserve(activeCtx, compacted[_graph2], options);\n            }\n\n            return _context.abrupt(\"return\", compacted);\n\n          case 32:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    });\n  });\n  /**\n   * Performs JSON-LD expansion.\n   *\n   * @param input the JSON-LD input to expand.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [keepFreeFloatingNodes] true to keep free-floating nodes,\n   *            false not to, defaults to false.\n   *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n   *          [expansionMap(info)] a function that can be used to custom map\n   *            unmappable values (or to throw an error when they are detected);\n   *            if this function returns `undefined` then the default behavior\n   *            will be used.\n   * @param [callback(err, expanded)] called once the operation completes.\n   *\n   * @return a Promise that resolves to the expanded output.\n   */\n\n  jsonld.expand = util.callbackify(function _callee2(input, options) {\n    var toResolve,\n        contextsToProcess,\n        expandContext,\n        defaultBase,\n        remoteDoc,\n        activeCtx,\n        expanded,\n        _args2 = arguments;\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(_args2.length < 1)) {\n              _context2.next = 2;\n              break;\n            }\n\n            throw new TypeError('Could not expand, too few arguments.');\n\n          case 2:\n            // set default options\n            options = _setDefaults(options, {\n              keepFreeFloatingNodes: false\n            });\n\n            if (options.expansionMap === false) {\n              options.expansionMap = undefined;\n            } // build set of objects that may have @contexts to resolve\n\n\n            toResolve = {}; // build set of contexts to process prior to expansion\n\n            contextsToProcess = []; // if an `expandContext` has been given ensure it gets resolved\n\n            if ('expandContext' in options) {\n              expandContext = util.clone(options.expandContext);\n\n              if (_isObject(expandContext) && '@context' in expandContext) {\n                toResolve.expandContext = expandContext;\n              } else {\n                toResolve.expandContext = {\n                  '@context': expandContext\n                };\n              }\n\n              contextsToProcess.push(toResolve.expandContext);\n            } // if input is a string, attempt to dereference remote document\n\n\n            if (_isString(input)) {\n              _context2.next = 11;\n              break;\n            }\n\n            // input is not a URL, do not need to retrieve it first\n            toResolve.input = util.clone(input);\n            _context2.next = 17;\n            break;\n\n          case 11:\n            _context2.next = 13;\n            return _regeneratorRuntime.awrap(jsonld.get(input, options));\n\n          case 13:\n            remoteDoc = _context2.sent;\n            defaultBase = remoteDoc.documentUrl;\n            toResolve.input = remoteDoc.document;\n\n            if (remoteDoc.contextUrl) {\n              // context included in HTTP link header and must be resolved\n              toResolve.remoteContext = {\n                '@context': remoteDoc.contextUrl\n              };\n              contextsToProcess.push(toResolve.remoteContext);\n            }\n\n          case 17:\n            // set default base\n            if (!('base' in options)) {\n              options.base = defaultBase || '';\n            } // get all contexts in `toResolve`\n\n\n            _context2.next = 20;\n            return _regeneratorRuntime.awrap(_getAllContexts(toResolve, options));\n\n          case 20:\n            // process any additional contexts\n            activeCtx = _getInitialContext(options);\n            contextsToProcess.forEach(function (localCtx) {\n              activeCtx = _processContext({\n                activeCtx: activeCtx,\n                localCtx: localCtx,\n                options: options\n              });\n            }); // expand resolved input\n\n            expanded = _expand({\n              activeCtx: activeCtx,\n              element: toResolve.input,\n              options: options,\n              expansionMap: options.expansionMap\n            }); // optimize away @graph with no other properties\n\n            if (_isObject(expanded) && '@graph' in expanded && Object.keys(expanded).length === 1) {\n              expanded = expanded['@graph'];\n            } else if (expanded === null) {\n              expanded = [];\n            } // normalize to an array\n\n\n            if (!_isArray(expanded)) {\n              expanded = [expanded];\n            }\n\n            return _context2.abrupt(\"return\", expanded);\n\n          case 26:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    });\n  });\n  /**\n   * Performs JSON-LD flattening.\n   *\n   * @param input the JSON-LD to flatten.\n   * @param ctx the context to use to compact the flattened output, or null.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n   * @param [callback(err, flattened)] called once the operation completes.\n   *\n   * @return a Promise that resolves to the flattened output.\n   */\n\n  jsonld.flatten = util.callbackify(function _callee3(input, ctx, options) {\n    var expanded,\n        flattened,\n        compacted,\n        _args3 = arguments;\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(_args3.length < 1)) {\n              _context3.next = 2;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", new TypeError('Could not flatten, too few arguments.'));\n\n          case 2:\n            if (typeof ctx === 'function') {\n              ctx = null;\n            } else {\n              ctx = ctx || null;\n            } // set default options\n\n\n            options = _setDefaults(options, {\n              base: _isString(input) ? input : ''\n            }); // expand input\n\n            _context3.next = 6;\n            return _regeneratorRuntime.awrap(jsonld.expand(input, options));\n\n          case 6:\n            expanded = _context3.sent;\n            // do flattening\n            flattened = _flatten(expanded);\n\n            if (!(ctx === null)) {\n              _context3.next = 10;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", flattened);\n\n          case 10:\n            // compact result (force @graph option to true, skip expansion)\n            options.graph = true;\n            options.skipExpansion = true;\n            _context3.next = 14;\n            return _regeneratorRuntime.awrap(jsonld.compact(flattened, ctx, options));\n\n          case 14:\n            compacted = _context3.sent;\n            return _context3.abrupt(\"return\", compacted);\n\n          case 16:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    });\n  });\n  /**\n   * Performs JSON-LD framing.\n   *\n   * @param input the JSON-LD input to frame.\n   * @param frame the JSON-LD frame to use.\n   * @param [options] the framing options.\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [embed] default @embed flag: '@last', '@always', '@never', '@link'\n   *            (default: '@last').\n   *          [explicit] default @explicit flag (default: false).\n   *          [requireAll] default @requireAll flag (default: true).\n   *          [omitDefault] default @omitDefault flag (default: false).\n   *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n   * @param [callback(err, framed)] called once the operation completes.\n   *\n   * @return a Promise that resolves to the framed output.\n   */\n\n  jsonld.frame = util.callbackify(function _callee4(input, frame, options) {\n    var remoteDoc,\n        ctx,\n        frameContext,\n        expanded,\n        opts,\n        expandedFrame,\n        framed,\n        compacted,\n        _args4 = arguments;\n    return _regeneratorRuntime.async(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!(_args4.length < 2)) {\n              _context4.next = 2;\n              break;\n            }\n\n            throw new TypeError('Could not frame, too few arguments.');\n\n          case 2:\n            // set default options\n            options = _setDefaults(options, {\n              base: _isString(input) ? input : '',\n              embed: '@last',\n              explicit: false,\n              requireAll: true,\n              omitDefault: false,\n              pruneBlankNodeIdentifiers: true,\n              bnodesToClear: []\n            }); // if frame is a string, attempt to dereference remote document\n\n            if (!_isString(frame)) {\n              _context4.next = 9;\n              break;\n            }\n\n            _context4.next = 6;\n            return _regeneratorRuntime.awrap(jsonld.get(frame, options));\n\n          case 6:\n            remoteDoc = _context4.sent;\n            frame = remoteDoc.document;\n\n            if (remoteDoc.contextUrl) {\n              // inject link header @context into frame\n              ctx = frame['@context'];\n\n              if (!ctx) {\n                ctx = remoteDoc.contextUrl;\n              } else if (_isArray(ctx)) {\n                ctx.push(remoteDoc.contextUrl);\n              } else {\n                ctx = [ctx, remoteDoc.contextUrl];\n              }\n\n              frame['@context'] = ctx;\n            }\n\n          case 9:\n            frameContext = frame ? frame['@context'] || {} : {}; // expand input\n\n            _context4.next = 12;\n            return _regeneratorRuntime.awrap(jsonld.expand(input, options));\n\n          case 12:\n            expanded = _context4.sent;\n            // expand frame\n            opts = util.clone(options);\n            opts.isFrame = true;\n            opts.keepFreeFloatingNodes = true;\n            _context4.next = 18;\n            return _regeneratorRuntime.awrap(jsonld.expand(frame, opts));\n\n          case 18:\n            expandedFrame = _context4.sent;\n            // if the unexpanded frame includes a key expanding to @graph, frame the\n            // default graph, otherwise, the merged graph\n            // FIXME should look for aliases of @graph\n            opts.merged = !('@graph' in frame); // do framing\n\n            framed = _frameMergedOrDefault(expanded, expandedFrame, opts); // compact result (force @graph option to true, skip expansion,\n            // check for linked embeds)\n\n            opts.graph = true;\n            opts.skipExpansion = true;\n            opts.link = {};\n            opts.framing = true;\n            _context4.next = 27;\n            return _regeneratorRuntime.awrap(jsonld.compact(framed, frameContext, opts));\n\n          case 27:\n            compacted = _context4.sent;\n            return _context4.abrupt(\"return\", compacted);\n\n          case 29:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    });\n  });\n  /**\n   * **Experimental**\n   *\n   * Links a JSON-LD document's nodes in memory.\n   *\n   * @param input the JSON-LD document to link.\n   * @param [ctx] the JSON-LD context to apply.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n   * @param [callback(err, linked)] called once the operation completes.\n   *\n   * @return a Promise that resolves to the linked output.\n   */\n\n  jsonld.link = util.callbackify(function _callee5(input, ctx, options) {\n    var frame;\n    return _regeneratorRuntime.async(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            // API matches running frame with a wildcard frame and embed: '@link'\n            // get arguments\n            frame = {};\n\n            if (ctx) {\n              frame['@context'] = ctx;\n            }\n\n            frame['@embed'] = '@link';\n            return _context5.abrupt(\"return\", jsonld.frame(input, frame, options));\n\n          case 4:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    });\n  });\n  /**\n   * Performs RDF dataset normalization on the given input. The input is JSON-LD\n   * unless the 'inputFormat' option is used. The output is an RDF dataset\n   * unless the 'format' option is used.\n   *\n   * @param input the input to normalize as JSON-LD or as a format specified by\n   *          the 'inputFormat' option.\n   * @param [options] the options to use:\n   *          [algorithm] the normalization algorithm to use, `URDNA2015` or\n   *            `URGNA2012` (default: `URDNA2015`).\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [skipExpansion] true to assume the input is expanded and skip\n   *            expansion, false not to, defaults to false.\n   *          [inputFormat] the format if input is not JSON-LD:\n   *            'application/n-quads' for N-Quads.\n   *          [format] the format if output is a string:\n   *            'application/n-quads' for N-Quads.\n   *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n   *          [useNative] true to use a native canonize algorithm\n   * @param [callback(err, normalized)] called once the operation completes.\n   *\n   * @return a Promise that resolves to the normalized output.\n   */\n\n  jsonld.normalize = jsonld.canonize = util.callbackify(function _callee6(input, options) {\n    var parsedInput,\n        opts,\n        dataset,\n        _args6 = arguments;\n    return _regeneratorRuntime.async(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (!(_args6.length < 1)) {\n              _context6.next = 2;\n              break;\n            }\n\n            throw new TypeError('Could not canonize, too few arguments.');\n\n          case 2:\n            // set default options\n            options = _setDefaults(options, {\n              base: _isString(input) ? input : '',\n              algorithm: 'URDNA2015',\n              skipExpansion: false\n            });\n\n            if (!('inputFormat' in options)) {\n              _context6.next = 8;\n              break;\n            }\n\n            if (!(options.inputFormat !== 'application/n-quads' && options.inputFormat !== 'application/nquads')) {\n              _context6.next = 6;\n              break;\n            }\n\n            throw new JsonLdError('Unknown canonicalization input format.', 'jsonld.CanonizeError');\n\n          case 6:\n            // TODO: `await` for async parsers\n            parsedInput = NQuads.parse(input); // do canonicalization\n\n            return _context6.abrupt(\"return\", canonize.canonize(parsedInput, options));\n\n          case 8:\n            // convert to RDF dataset then do normalization\n            opts = util.clone(options);\n            delete opts.format;\n            opts.produceGeneralizedRdf = false;\n            _context6.next = 13;\n            return _regeneratorRuntime.awrap(jsonld.toRDF(input, opts));\n\n          case 13:\n            dataset = _context6.sent;\n            return _context6.abrupt(\"return\", canonize.canonize(dataset, options));\n\n          case 15:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    });\n  });\n  /**\n   * Converts an RDF dataset to JSON-LD.\n   *\n   * @param dataset a serialized string of RDF in a format specified by the\n   *          format option or an RDF dataset to convert.\n   * @param [options] the options to use:\n   *          [format] the format if dataset param must first be parsed:\n   *            'application/n-quads' for N-Quads (default).\n   *          [rdfParser] a custom RDF-parser to use to parse the dataset.\n   *          [useRdfType] true to use rdf:type, false to use @type\n   *            (default: false).\n   *          [useNativeTypes] true to convert XSD types into native types\n   *            (boolean, integer, double), false not to (default: false).\n   * @param [callback(err, output)] called once the operation completes.\n   *\n   * @return a Promise that resolves to the JSON-LD document.\n   */\n\n  jsonld.fromRDF = util.callbackify(function _callee7(dataset, options) {\n    var _options,\n        format,\n        _options2,\n        rdfParser,\n        parsedDataset,\n        _args7 = arguments;\n\n    return _regeneratorRuntime.async(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            if (!(_args7.length < 1)) {\n              _context7.next = 2;\n              break;\n            }\n\n            throw new TypeError('Could not convert from RDF, too few arguments.');\n\n          case 2:\n            // set default options\n            options = _setDefaults(options, {\n              format: _isString(dataset) ? 'application/n-quads' : undefined\n            });\n            _options = options, format = _options.format;\n            _options2 = options, rdfParser = _options2.rdfParser; // handle special format\n\n            if (!format) {\n              _context7.next = 11;\n              break;\n            }\n\n            // check supported formats\n            rdfParser = rdfParser || _rdfParsers[format];\n\n            if (rdfParser) {\n              _context7.next = 9;\n              break;\n            }\n\n            throw new JsonLdError('Unknown input format.', 'jsonld.UnknownFormat', {\n              format: format\n            });\n\n          case 9:\n            _context7.next = 12;\n            break;\n\n          case 11:\n            // no-op parser, assume dataset already parsed\n            rdfParser = function rdfParser() {\n              return dataset;\n            };\n\n          case 12:\n            if (rdfParser.length > 1) {\n              // convert callback-based rdf parser to promise-based\n              parsedDataset = new Promise(function (resolve, reject) {\n                rdfParser(dataset, function (err, dataset) {\n                  if (err) {\n                    reject(err);\n                  } else {\n                    resolve(dataset);\n                  }\n                });\n              });\n            } else {\n              parsedDataset = Promise.resolve(rdfParser(dataset));\n            }\n\n            _context7.next = 15;\n            return _regeneratorRuntime.awrap(parsedDataset);\n\n          case 15:\n            parsedDataset = _context7.sent;\n\n            // back-compat with old parsers that produced legacy dataset format\n            if (!Array.isArray(parsedDataset)) {\n              parsedDataset = NQuads.legacyDatasetToQuads(parsedDataset);\n            }\n\n            return _context7.abrupt(\"return\", _fromRDF(parsedDataset, options));\n\n          case 18:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    });\n  });\n  /**\n   * Outputs the RDF dataset found in the given JSON-LD object.\n   *\n   * @param input the JSON-LD input.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [skipExpansion] true to assume the input is expanded and skip\n   *            expansion, false not to, defaults to false.\n   *          [format] the format to use to output a string:\n   *            'application/n-quads' for N-Quads.\n   *          [produceGeneralizedRdf] true to output generalized RDF, false\n   *            to produce only standard RDF (default: false).\n   *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n   * @param [callback(err, dataset)] called once the operation completes.\n   *\n   * @return a Promise that resolves to the RDF dataset.\n   */\n\n  jsonld.toRDF = util.callbackify(function _callee8(input, options) {\n    var expanded,\n        dataset,\n        _args8 = arguments;\n    return _regeneratorRuntime.async(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            if (!(_args8.length < 1)) {\n              _context8.next = 2;\n              break;\n            }\n\n            throw new TypeError('Could not convert to RDF, too few arguments.');\n\n          case 2:\n            // set default options\n            options = _setDefaults(options, {\n              base: _isString(input) ? input : '',\n              skipExpansion: false\n            }); // TODO: support toRDF custom map?\n\n            if (!options.skipExpansion) {\n              _context8.next = 7;\n              break;\n            }\n\n            expanded = input;\n            _context8.next = 10;\n            break;\n\n          case 7:\n            _context8.next = 9;\n            return _regeneratorRuntime.awrap(jsonld.expand(input, options));\n\n          case 9:\n            expanded = _context8.sent;\n\n          case 10:\n            // output RDF dataset\n            dataset = _toRDF(expanded, options);\n\n            if (!options.format) {\n              _context8.next = 17;\n              break;\n            }\n\n            if (!(options.format === 'application/n-quads' || options.format === 'application/nquads')) {\n              _context8.next = 16;\n              break;\n            }\n\n            _context8.next = 15;\n            return _regeneratorRuntime.awrap(NQuads.serialize(dataset));\n\n          case 15:\n            return _context8.abrupt(\"return\", _context8.sent);\n\n          case 16:\n            throw new JsonLdError('Unknown output format.', 'jsonld.UnknownFormat', {\n              format: options.format\n            });\n\n          case 17:\n            return _context8.abrupt(\"return\", dataset);\n\n          case 18:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    });\n  });\n  /**\n   * **Experimental**\n   *\n   * Recursively flattens the nodes in the given JSON-LD input into a merged\n   * map of node ID => node. All graphs will be merged into the default graph.\n   *\n   * @param input the JSON-LD input.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n   *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n   * @param [callback(err, nodeMap)] called once the operation completes.\n   *\n   * @return a Promise that resolves to the merged node map.\n   */\n\n  jsonld.createNodeMap = util.callbackify(function _callee9(input, options) {\n    var expanded,\n        _args9 = arguments;\n    return _regeneratorRuntime.async(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            if (!(_args9.length < 1)) {\n              _context9.next = 2;\n              break;\n            }\n\n            throw new TypeError('Could not create node map, too few arguments.');\n\n          case 2:\n            // set default options\n            options = _setDefaults(options, {\n              base: _isString(input) ? input : ''\n            }); // expand input\n\n            _context9.next = 5;\n            return _regeneratorRuntime.awrap(jsonld.expand(input, options));\n\n          case 5:\n            expanded = _context9.sent;\n            return _context9.abrupt(\"return\", _createMergedNodeMap(expanded, options));\n\n          case 7:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    });\n  });\n  /**\n   * **Experimental**\n   *\n   * Merges two or more JSON-LD documents into a single flattened document.\n   *\n   * @param docs the JSON-LD documents to merge together.\n   * @param ctx the context to use to compact the merged result, or null.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n   *          [mergeNodes] true to merge properties for nodes with the same ID,\n   *            false to ignore new properties for nodes with the same ID once\n   *            the ID has been defined; note that this may not prevent merging\n   *            new properties where a node is in the `object` position\n   *            (default: true).\n   *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n   * @param [callback(err, merged)] called once the operation completes.\n   *\n   * @return a Promise that resolves to the merged output.\n   */\n\n  jsonld.merge = util.callbackify(function _callee10(docs, ctx, options) {\n    var expanded,\n        mergeNodes,\n        issuer,\n        graphs,\n        i,\n        doc,\n        _graphs,\n        graphName,\n        _nodeMap,\n        nodeMap,\n        key,\n        defaultGraph,\n        flattened,\n        keys,\n        ki,\n        node,\n        compacted,\n        _args10 = arguments;\n\n    return _regeneratorRuntime.async(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            if (!(_args10.length < 1)) {\n              _context10.next = 2;\n              break;\n            }\n\n            throw new TypeError('Could not merge, too few arguments.');\n\n          case 2:\n            if (_isArray(docs)) {\n              _context10.next = 4;\n              break;\n            }\n\n            throw new TypeError('Could not merge, \"docs\" must be an array.');\n\n          case 4:\n            if (typeof ctx === 'function') {\n              ctx = null;\n            } else {\n              ctx = ctx || null;\n            } // set default options\n\n\n            options = _setDefaults(options, {}); // expand all documents\n\n            _context10.next = 8;\n            return _regeneratorRuntime.awrap(Promise.all(docs.map(function (doc) {\n              var opts = Object.assign({}, options);\n              return jsonld.expand(doc, opts);\n            })));\n\n          case 8:\n            expanded = _context10.sent;\n            mergeNodes = true;\n\n            if ('mergeNodes' in options) {\n              mergeNodes = options.mergeNodes;\n            }\n\n            issuer = options.issuer || new IdentifierIssuer('_:b');\n            graphs = {\n              '@default': {}\n            };\n            i = 0;\n\n          case 14:\n            if (!(i < expanded.length)) {\n              _context10.next = 33;\n              break;\n            }\n\n            // uniquely relabel blank nodes\n            doc = util.relabelBlankNodes(expanded[i], {\n              issuer: new IdentifierIssuer('_:b' + i + '-')\n            }); // add nodes to the shared node map graphs if merging nodes, to a\n            // separate graph set if not\n\n            _graphs = mergeNodes || i === 0 ? graphs : {\n              '@default': {}\n            };\n\n            _createNodeMap(doc, _graphs, '@default', issuer);\n\n            if (!(_graphs !== graphs)) {\n              _context10.next = 30;\n              break;\n            }\n\n            _context10.t0 = _regeneratorRuntime.keys(_graphs);\n\n          case 20:\n            if ((_context10.t1 = _context10.t0()).done) {\n              _context10.next = 30;\n              break;\n            }\n\n            graphName = _context10.t1.value;\n            _nodeMap = _graphs[graphName];\n\n            if (graphName in graphs) {\n              _context10.next = 26;\n              break;\n            }\n\n            graphs[graphName] = _nodeMap;\n            return _context10.abrupt(\"continue\", 20);\n\n          case 26:\n            nodeMap = graphs[graphName];\n\n            for (key in _nodeMap) {\n              if (!(key in nodeMap)) {\n                nodeMap[key] = _nodeMap[key];\n              }\n            }\n\n            _context10.next = 20;\n            break;\n\n          case 30:\n            ++i;\n            _context10.next = 14;\n            break;\n\n          case 33:\n            // add all non-default graphs to default graph\n            defaultGraph = _mergeNodeMaps(graphs); // produce flattened output\n\n            flattened = [];\n            keys = Object.keys(defaultGraph).sort();\n\n            for (ki = 0; ki < keys.length; ++ki) {\n              node = defaultGraph[keys[ki]]; // only add full subjects to top-level\n\n              if (!_isSubjectReference(node)) {\n                flattened.push(node);\n              }\n            }\n\n            if (!(ctx === null)) {\n              _context10.next = 39;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", flattened);\n\n          case 39:\n            // compact result (force @graph option to true, skip expansion)\n            options.graph = true;\n            options.skipExpansion = true;\n            _context10.next = 43;\n            return _regeneratorRuntime.awrap(jsonld.compact(flattened, ctx, options));\n\n          case 43:\n            compacted = _context10.sent;\n            return _context10.abrupt(\"return\", compacted);\n\n          case 45:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    });\n  });\n  /**\n   * The default document loader for external documents. If the environment\n   * is node.js, a callback-continuation-style document loader is used; otherwise,\n   * a promises-style document loader is used.\n   *\n   * @param url the URL to load.\n   * @param callback(err, remoteDoc) called once the operation completes,\n   *          if using a non-promises API.\n   *\n   * @return a promise, if using a promises API.\n   */\n\n  Object.defineProperty(jsonld, 'documentLoader', {\n    get: function get() {\n      return jsonld._documentLoader;\n    },\n    set: function set(v) {\n      return jsonld._documentLoader = util.normalizeDocumentLoader(v);\n    }\n  }); // default document loader not implemented\n\n  jsonld.documentLoader = function _callee11(url) {\n    return _regeneratorRuntime.async(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            throw new JsonLdError('Could not retrieve a JSON-LD document from the URL. URL ' + 'dereferencing not implemented.', 'jsonld.LoadDocumentError', {\n              code: 'loading document failed',\n              url: url\n            });\n\n          case 1:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    });\n  };\n  /**\n   * Deprecated default document loader. Do not use or override.\n   */\n\n\n  jsonld.loadDocument = util.callbackify(function _callee12() {\n    var _args12 = arguments;\n    return _regeneratorRuntime.async(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            return _context12.abrupt(\"return\", jsonld.documentLoader.apply(null, _args12));\n\n          case 1:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    });\n  });\n  /**\n   * Gets a remote JSON-LD document using the default document loader or\n   * one given in the passed options.\n   *\n   * @param url the URL to fetch.\n   * @param [options] the options to use:\n   *          [documentLoader] the document loader to use.\n   * @param [callback(err, remoteDoc)] called once the operation completes.\n   *\n   * @return a Promise that resolves to the retrieved remote document.\n   */\n\n  jsonld.get = util.callbackify(function _callee13(url, options) {\n    var load, remoteDoc;\n    return _regeneratorRuntime.async(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            if (typeof options.documentLoader === 'function') {\n              load = util.normalizeDocumentLoader(options.documentLoader);\n            } else {\n              load = jsonld.documentLoader;\n            }\n\n            _context13.next = 3;\n            return _regeneratorRuntime.awrap(load(url));\n\n          case 3:\n            remoteDoc = _context13.sent;\n            _context13.prev = 4;\n\n            if (remoteDoc.document) {\n              _context13.next = 7;\n              break;\n            }\n\n            throw new JsonLdError('No remote document found at the given URL.', 'jsonld.NullRemoteDocument');\n\n          case 7:\n            if (_isString(remoteDoc.document)) {\n              remoteDoc.document = JSON.parse(remoteDoc.document);\n            }\n\n            _context13.next = 13;\n            break;\n\n          case 10:\n            _context13.prev = 10;\n            _context13.t0 = _context13[\"catch\"](4);\n            throw new JsonLdError('Could not retrieve a JSON-LD document from the URL.', 'jsonld.LoadDocumentError', {\n              code: 'loading document failed',\n              cause: _context13.t0,\n              remoteDoc: remoteDoc\n            });\n\n          case 13:\n            return _context13.abrupt(\"return\", remoteDoc);\n\n          case 14:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, null, null, [[4, 10]]);\n  });\n  /**\n   * Processes a local context, resolving any URLs as necessary, and returns a\n   * new active context in its callback.\n   *\n   * @param activeCtx the current active context.\n   * @param localCtx the local context to process.\n   * @param [options] the options to use:\n   *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n   * @param [callback(err, activeCtx)] called once the operation completes.\n   *\n   * @return a Promise that resolves to the new active context.\n   */\n\n  jsonld.processContext = util.callbackify(function _callee14(activeCtx, localCtx, options) {\n    var ctx;\n    return _regeneratorRuntime.async(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            // set default options\n            options = _setDefaults(options, {\n              base: ''\n            }); // return initial context early for null context\n\n            if (!(localCtx === null)) {\n              _context14.next = 3;\n              break;\n            }\n\n            return _context14.abrupt(\"return\", _getInitialContext(options));\n\n          case 3:\n            // get URLs in localCtx\n            localCtx = util.clone(localCtx);\n\n            if (!(_isObject(localCtx) && '@context' in localCtx)) {\n              localCtx = {\n                '@context': localCtx\n              };\n            }\n\n            _context14.next = 7;\n            return _regeneratorRuntime.awrap(_getAllContexts(localCtx, options));\n\n          case 7:\n            ctx = _context14.sent;\n            return _context14.abrupt(\"return\", _processContext({\n              activeCtx: activeCtx,\n              localCtx: ctx,\n              options: options\n            }));\n\n          case 9:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    });\n  }); // backwards compatibility\n\n  jsonld.getContextValue = require('./context').getContextValue;\n  /**\n   * Document loaders.\n   */\n\n  jsonld.documentLoaders = {};\n  jsonld.documentLoaders.node = require('./documentLoaders/node');\n  jsonld.documentLoaders.xhr = require('./documentLoaders/xhr');\n  /**\n   * Assigns the default document loader for external document URLs to a built-in\n   * default. Supported types currently include: 'xhr' and 'node'.\n   *\n   * @param type the type to set.\n   * @param [params] the parameters required to use the document loader.\n   */\n\n  jsonld.useDocumentLoader = function (type) {\n    if (!(type in jsonld.documentLoaders)) {\n      throw new JsonLdError('Unknown document loader type: \"' + type + '\"', 'jsonld.UnknownDocumentLoader', {\n        type: type\n      });\n    } // set document loader\n\n\n    jsonld.documentLoader = jsonld.documentLoaders[type].apply(jsonld, Array.prototype.slice.call(arguments, 1));\n  };\n  /**\n   * Registers an RDF dataset parser by content-type, for use with\n   * jsonld.fromRDF. An RDF dataset parser will always be given two parameters,\n   * a string of input and a callback. An RDF dataset parser can be synchronous\n   * or asynchronous.\n   *\n   * If the parser function returns undefined or null then it will be assumed to\n   * be asynchronous w/a continuation-passing style and the callback parameter\n   * given to the parser MUST be invoked.\n   *\n   * If it returns a Promise, then it will be assumed to be asynchronous, but the\n   * callback parameter MUST NOT be invoked. It should instead be ignored.\n   *\n   * If it returns an RDF dataset, it will be assumed to be synchronous and the\n   * callback parameter MUST NOT be invoked. It should instead be ignored.\n   *\n   * @param contentType the content-type for the parser.\n   * @param parser(input, callback(err, dataset)) the parser function (takes a\n   *          string as a parameter and either returns null/undefined and uses\n   *          the given callback, returns a Promise, or returns an RDF dataset).\n   */\n\n\n  jsonld.registerRDFParser = function (contentType, parser) {\n    _rdfParsers[contentType] = parser;\n  };\n  /**\n   * Unregisters an RDF dataset parser by content-type.\n   *\n   * @param contentType the content-type for the parser.\n   */\n\n\n  jsonld.unregisterRDFParser = function (contentType) {\n    delete _rdfParsers[contentType];\n  }; // register the N-Quads RDF parser\n\n\n  jsonld.registerRDFParser('application/n-quads', NQuads.parse);\n  jsonld.registerRDFParser('application/nquads', NQuads.parse); // register the RDFa API RDF parser\n\n  jsonld.registerRDFParser('rdfa-api', Rdfa.parse);\n  /* URL API */\n\n  jsonld.url = require('./url');\n  /* Utility API */\n\n  jsonld.util = util; // backwards compatibility\n\n  Object.assign(jsonld, util); // reexpose API as jsonld.promises for backwards compatability\n\n  jsonld.promises = jsonld; // backwards compatibility\n\n  jsonld.RequestQueue = require('./RequestQueue');\n  /* WebIDL API */\n\n  jsonld.JsonLdProcessor = require('./JsonLdProcessor')(jsonld); // setup browser global JsonLdProcessor\n\n  if (_browser && typeof global.JsonLdProcessor === 'undefined') {\n    Object.defineProperty(global, 'JsonLdProcessor', {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: jsonld.JsonLdProcessor\n    });\n  } // set platform-specific defaults/APIs\n\n\n  if (_nodejs) {\n    // use node document loader by default\n    jsonld.useDocumentLoader('node');\n  } else if (typeof XMLHttpRequest !== 'undefined') {\n    // use xhr document loader by default\n    jsonld.useDocumentLoader('xhr');\n  }\n\n  function _setDefaults(options, _ref) {\n    var _ref$documentLoader = _ref.documentLoader,\n        documentLoader = _ref$documentLoader === void 0 ? jsonld.documentLoader : _ref$documentLoader,\n        defaults = _objectWithoutProperties(_ref, [\"documentLoader\"]);\n\n    return Object.assign({}, {\n      documentLoader: documentLoader\n    }, defaults, options);\n  } // end of jsonld API `wrapper` factory\n\n\n  return jsonld;\n}; // external APIs:\n// used to generate a new jsonld API instance\n\n\nvar factory = function factory() {\n  return wrapper(function () {\n    return factory();\n  });\n}; // wrap the main jsonld API instance\n\n\nwrapper(factory); // export API\n\nmodule.exports = factory;","map":{"version":3,"sources":["C:/Users/Guillaume/Code/e-commerce/admin/node_modules/jsonld/lib/jsonld.js"],"names":["canonize","require","util","IdentifierIssuer","JsonLdError","NQuads","Rdfa","_expand","expand","_flatten","flatten","_fromRDF","fromRDF","_toRDF","toRDF","_frameMergedOrDefault","frameMergedOrDefault","_isArray","isArray","_isObject","isObject","_isString","isString","_isSubjectReference","isSubjectReference","_getInitialContext","getInitialContext","_processContext","process","_getAllContexts","getAllContexts","_compact","compact","_compactIri","compactIri","_removePreserve","removePreserve","_createNodeMap","createNodeMap","_createMergedNodeMap","createMergedNodeMap","_mergeNodeMaps","mergeNodeMaps","_nodejs","versions","node","_browser","window","self","wrapper","jsonld","_rdfParsers","callbackify","input","ctx","options","length","TypeError","code","_setDefaults","base","compactArrays","compactToRelative","graph","skipExpansion","link","issuer","expanded","processContext","activeCtx","compacted","element","compactionMap","clone","tmp","i","Object","keys","push","hasContext","graphAlias","iri","relativeTo","vocab","key","framing","keepFreeFloatingNodes","expansionMap","undefined","toResolve","contextsToProcess","expandContext","get","remoteDoc","defaultBase","documentUrl","document","contextUrl","remoteContext","forEach","localCtx","flattened","frame","embed","explicit","requireAll","omitDefault","pruneBlankNodeIdentifiers","bnodesToClear","frameContext","opts","isFrame","expandedFrame","merged","framed","normalize","algorithm","inputFormat","parsedInput","parse","format","produceGeneralizedRdf","dataset","rdfParser","parsedDataset","Promise","resolve","reject","err","Array","legacyDatasetToQuads","serialize","merge","docs","all","map","doc","assign","mergeNodes","graphs","relabelBlankNodes","_graphs","graphName","_nodeMap","nodeMap","defaultGraph","sort","ki","defineProperty","_documentLoader","set","v","normalizeDocumentLoader","documentLoader","url","loadDocument","apply","load","JSON","cause","getContextValue","documentLoaders","xhr","useDocumentLoader","type","prototype","slice","call","arguments","registerRDFParser","contentType","parser","unregisterRDFParser","promises","RequestQueue","JsonLdProcessor","global","writable","enumerable","configurable","value","XMLHttpRequest","defaults","factory","module","exports"],"mappings":"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","sourcesContent":["/**\n * A JavaScript implementation of the JSON-LD API.\n *\n * @author Dave Longley\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2011-2017 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nconst canonize = require('rdf-canonize');\nconst util = require('./util');\nconst IdentifierIssuer = util.IdentifierIssuer;\nconst JsonLdError = require('./JsonLdError');\nconst NQuads = require('./NQuads');\nconst Rdfa = require('./Rdfa');\n\nconst {expand: _expand} = require('./expand');\nconst {flatten: _flatten} = require('./flatten');\nconst {fromRDF: _fromRDF} = require('./fromRdf');\nconst {toRDF: _toRDF} = require('./toRdf');\n\nconst {\n  frameMergedOrDefault: _frameMergedOrDefault\n} = require('./frame');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString\n} = require('./types');\n\nconst {\n  isSubjectReference: _isSubjectReference,\n} = require('./graphTypes');\n\nconst {\n  getInitialContext: _getInitialContext,\n  process: _processContext,\n  getAllContexts: _getAllContexts\n} = require('./context');\n\nconst {\n  compact: _compact,\n  compactIri: _compactIri,\n  removePreserve: _removePreserve\n} = require('./compact');\n\nconst {\n  createNodeMap: _createNodeMap,\n  createMergedNodeMap: _createMergedNodeMap,\n  mergeNodeMaps: _mergeNodeMaps\n} = require('./nodeMap');\n\n// determine if in-browser or using node.js\nconst _nodejs = (\n  typeof process !== 'undefined' && process.versions && process.versions.node);\nconst _browser = !_nodejs &&\n  (typeof window !== 'undefined' || typeof self !== 'undefined');\n\n/* eslint-disable indent */\n// attaches jsonld API to the given object\nconst wrapper = function(jsonld) {\n\n/** Registered RDF dataset parsers hashed by content-type. */\nconst _rdfParsers = {};\n\n/* Core API */\n\n/**\n * Performs JSON-LD compaction.\n *\n * @param input the JSON-LD input to compact.\n * @param ctx the context to compact with.\n * @param [options] options to use:\n *          [base] the base IRI to use.\n *          [compactArrays] true to compact arrays to single values when\n *            appropriate, false not to (default: true).\n *          [compactToRelative] true to compact IRIs to be relative to document\n *            base, false to keep absolute (default: true)\n *          [graph] true to always output a top-level graph (default: false).\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n *          [expansionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [framing] true if compaction is occuring during a framing operation.\n *          [compactionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n * @param [callback(err, compacted)] called once the operation completes.\n *\n * @return a Promise that resolves to the compacted output.\n */\njsonld.compact = util.callbackify(async function(input, ctx, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not compact, too few arguments.');\n  }\n\n  if(ctx === null) {\n    throw new JsonLdError(\n      'The compaction context must not be null.',\n      'jsonld.CompactError', {code: 'invalid local context'});\n  }\n\n  // nothing to compact\n  if(input === null) {\n    return null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    compactArrays: true,\n    compactToRelative: true,\n    graph: false,\n    skipExpansion: false,\n    link: false,\n    issuer: new IdentifierIssuer('_:b')\n  });\n  if(options.link) {\n    // force skip expansion when linking, \"link\" is not part of the public\n    // API, it should only be called from framing\n    options.skipExpansion = true;\n  }\n  if(!options.compactToRelative) {\n    delete options.base;\n  }\n\n  // expand input\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // process context\n  const activeCtx = await jsonld.processContext(\n    _getInitialContext(options), ctx, options);\n\n  // do compaction\n  let compacted = _compact({\n    activeCtx,\n    element: expanded,\n    options,\n    compactionMap: options.compactionMap\n  });\n\n  // perform clean up\n  if(options.compactArrays && !options.graph && _isArray(compacted)) {\n    if(compacted.length === 1) {\n      // simplify to a single item\n      compacted = compacted[0];\n    } else if(compacted.length === 0) {\n      // simplify to an empty object\n      compacted = {};\n    }\n  } else if(options.graph && _isObject(compacted)) {\n    // always use array if graph option is on\n    compacted = [compacted];\n  }\n\n  // follow @context key\n  if(_isObject(ctx) && '@context' in ctx) {\n    ctx = ctx['@context'];\n  }\n\n  // build output context\n  ctx = util.clone(ctx);\n  if(!_isArray(ctx)) {\n    ctx = [ctx];\n  }\n  // remove empty contexts\n  const tmp = ctx;\n  ctx = [];\n  for(let i = 0; i < tmp.length; ++i) {\n    if(!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {\n      ctx.push(tmp[i]);\n    }\n  }\n\n  // remove array if only one context\n  const hasContext = (ctx.length > 0);\n  if(ctx.length === 1) {\n    ctx = ctx[0];\n  }\n\n  // add context and/or @graph\n  if(_isArray(compacted)) {\n    // use '@graph' keyword\n    const graphAlias = _compactIri({\n      activeCtx, iri: '@graph', relativeTo: {vocab: true}\n    });\n    const graph = compacted;\n    compacted = {};\n    if(hasContext) {\n      compacted['@context'] = ctx;\n    }\n    compacted[graphAlias] = graph;\n  } else if(_isObject(compacted) && hasContext) {\n    // reorder keys so @context is first\n    const graph = compacted;\n    compacted = {'@context': ctx};\n    for(const key in graph) {\n      compacted[key] = graph[key];\n    }\n  }\n\n  if(options.framing) {\n    // get graph alias\n    const graph = _compactIri({\n      activeCtx, iri: '@graph', relativeTo: {vocab: true}\n    });\n    // remove @preserve from results\n    options.link = {};\n    compacted[graph] = _removePreserve(activeCtx, compacted[graph], options);\n  }\n\n  return compacted;\n});\n\n/**\n * Performs JSON-LD expansion.\n *\n * @param input the JSON-LD input to expand.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [keepFreeFloatingNodes] true to keep free-floating nodes,\n *            false not to, defaults to false.\n *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n *          [expansionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n * @param [callback(err, expanded)] called once the operation completes.\n *\n * @return a Promise that resolves to the expanded output.\n */\njsonld.expand = util.callbackify(async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not expand, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    keepFreeFloatingNodes: false\n  });\n  if(options.expansionMap === false) {\n    options.expansionMap = undefined;\n  }\n\n  // build set of objects that may have @contexts to resolve\n  const toResolve = {};\n\n  // build set of contexts to process prior to expansion\n  const contextsToProcess = [];\n\n  // if an `expandContext` has been given ensure it gets resolved\n  if('expandContext' in options) {\n    const expandContext = util.clone(options.expandContext);\n    if(_isObject(expandContext) && '@context' in expandContext) {\n      toResolve.expandContext = expandContext;\n    } else {\n      toResolve.expandContext = {'@context': expandContext};\n    }\n    contextsToProcess.push(toResolve.expandContext);\n  }\n\n  // if input is a string, attempt to dereference remote document\n  let defaultBase;\n  if(!_isString(input)) {\n    // input is not a URL, do not need to retrieve it first\n    toResolve.input = util.clone(input);\n  } else {\n    // load remote doc\n    const remoteDoc = await jsonld.get(input, options);\n    defaultBase = remoteDoc.documentUrl;\n    toResolve.input = remoteDoc.document;\n    if(remoteDoc.contextUrl) {\n      // context included in HTTP link header and must be resolved\n      toResolve.remoteContext = {'@context': remoteDoc.contextUrl};\n      contextsToProcess.push(toResolve.remoteContext);\n    }\n  }\n\n  // set default base\n  if(!('base' in options)) {\n    options.base = defaultBase || '';\n  }\n\n  // get all contexts in `toResolve`\n  await _getAllContexts(toResolve, options);\n\n  // process any additional contexts\n  let activeCtx = _getInitialContext(options);\n  contextsToProcess.forEach(localCtx => {\n    activeCtx = _processContext({activeCtx, localCtx, options});\n  });\n\n  // expand resolved input\n  let expanded = _expand({\n    activeCtx,\n    element: toResolve.input,\n    options,\n    expansionMap: options.expansionMap\n  });\n\n  // optimize away @graph with no other properties\n  if(_isObject(expanded) && ('@graph' in expanded) &&\n    Object.keys(expanded).length === 1) {\n    expanded = expanded['@graph'];\n  } else if(expanded === null) {\n    expanded = [];\n  }\n\n  // normalize to an array\n  if(!_isArray(expanded)) {\n    expanded = [expanded];\n  }\n\n  return expanded;\n});\n\n/**\n * Performs JSON-LD flattening.\n *\n * @param input the JSON-LD to flatten.\n * @param ctx the context to use to compact the flattened output, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n * @param [callback(err, flattened)] called once the operation completes.\n *\n * @return a Promise that resolves to the flattened output.\n */\njsonld.flatten = util.callbackify(async function(input, ctx, options) {\n  if(arguments.length < 1) {\n    return new TypeError('Could not flatten, too few arguments.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : ''\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // do flattening\n  const flattened = _flatten(expanded);\n\n  if(ctx === null) {\n    // no compaction required\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n});\n\n/**\n * Performs JSON-LD framing.\n *\n * @param input the JSON-LD input to frame.\n * @param frame the JSON-LD frame to use.\n * @param [options] the framing options.\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [embed] default @embed flag: '@last', '@always', '@never', '@link'\n *            (default: '@last').\n *          [explicit] default @explicit flag (default: false).\n *          [requireAll] default @requireAll flag (default: true).\n *          [omitDefault] default @omitDefault flag (default: false).\n *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n * @param [callback(err, framed)] called once the operation completes.\n *\n * @return a Promise that resolves to the framed output.\n */\njsonld.frame = util.callbackify(async function(input, frame, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not frame, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    embed: '@last',\n    explicit: false,\n    requireAll: true,\n    omitDefault: false,\n    pruneBlankNodeIdentifiers: true,\n    bnodesToClear: []\n  });\n\n  // if frame is a string, attempt to dereference remote document\n  if(_isString(frame)) {\n    // load remote doc\n    const remoteDoc = await jsonld.get(frame, options);\n    frame = remoteDoc.document;\n\n    if(remoteDoc.contextUrl) {\n      // inject link header @context into frame\n      let ctx = frame['@context'];\n      if(!ctx) {\n        ctx = remoteDoc.contextUrl;\n      } else if(_isArray(ctx)) {\n        ctx.push(remoteDoc.contextUrl);\n      } else {\n        ctx = [ctx, remoteDoc.contextUrl];\n      }\n      frame['@context'] = ctx;\n    }\n  }\n\n  const frameContext = frame ? frame['@context'] || {} : {};\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // expand frame\n  const opts = util.clone(options);\n  opts.isFrame = true;\n  opts.keepFreeFloatingNodes = true;\n  const expandedFrame = await jsonld.expand(frame, opts);\n\n  // if the unexpanded frame includes a key expanding to @graph, frame the\n  // default graph, otherwise, the merged graph\n  // FIXME should look for aliases of @graph\n  opts.merged = !('@graph' in frame);\n  // do framing\n  const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);\n\n  // compact result (force @graph option to true, skip expansion,\n  // check for linked embeds)\n  opts.graph = true;\n  opts.skipExpansion = true;\n  opts.link = {};\n  opts.framing = true;\n  const compacted = await jsonld.compact(framed, frameContext, opts);\n\n  return compacted;\n});\n\n/**\n * **Experimental**\n *\n * Links a JSON-LD document's nodes in memory.\n *\n * @param input the JSON-LD document to link.\n * @param [ctx] the JSON-LD context to apply.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n * @param [callback(err, linked)] called once the operation completes.\n *\n * @return a Promise that resolves to the linked output.\n */\njsonld.link = util.callbackify(async function(input, ctx, options) {\n  // API matches running frame with a wildcard frame and embed: '@link'\n  // get arguments\n  const frame = {};\n  if(ctx) {\n    frame['@context'] = ctx;\n  }\n  frame['@embed'] = '@link';\n  return jsonld.frame(input, frame, options);\n});\n\n/**\n * Performs RDF dataset normalization on the given input. The input is JSON-LD\n * unless the 'inputFormat' option is used. The output is an RDF dataset\n * unless the 'format' option is used.\n *\n * @param input the input to normalize as JSON-LD or as a format specified by\n *          the 'inputFormat' option.\n * @param [options] the options to use:\n *          [algorithm] the normalization algorithm to use, `URDNA2015` or\n *            `URGNA2012` (default: `URDNA2015`).\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [inputFormat] the format if input is not JSON-LD:\n *            'application/n-quads' for N-Quads.\n *          [format] the format if output is a string:\n *            'application/n-quads' for N-Quads.\n *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n *          [useNative] true to use a native canonize algorithm\n * @param [callback(err, normalized)] called once the operation completes.\n *\n * @return a Promise that resolves to the normalized output.\n */\njsonld.normalize = jsonld.canonize = util.callbackify(async function(\n  input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not canonize, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    algorithm: 'URDNA2015',\n    skipExpansion: false\n  });\n  if('inputFormat' in options) {\n    if(options.inputFormat !== 'application/n-quads' &&\n      options.inputFormat !== 'application/nquads') {\n      throw new JsonLdError(\n        'Unknown canonicalization input format.',\n        'jsonld.CanonizeError');\n    }\n    // TODO: `await` for async parsers\n    const parsedInput = NQuads.parse(input);\n\n    // do canonicalization\n    return canonize.canonize(parsedInput, options);\n  }\n\n  // convert to RDF dataset then do normalization\n  const opts = util.clone(options);\n  delete opts.format;\n  opts.produceGeneralizedRdf = false;\n  const dataset = await jsonld.toRDF(input, opts);\n\n  // do canonicalization\n  return canonize.canonize(dataset, options);\n});\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset a serialized string of RDF in a format specified by the\n *          format option or an RDF dataset to convert.\n * @param [options] the options to use:\n *          [format] the format if dataset param must first be parsed:\n *            'application/n-quads' for N-Quads (default).\n *          [rdfParser] a custom RDF-parser to use to parse the dataset.\n *          [useRdfType] true to use rdf:type, false to use @type\n *            (default: false).\n *          [useNativeTypes] true to convert XSD types into native types\n *            (boolean, integer, double), false not to (default: false).\n * @param [callback(err, output)] called once the operation completes.\n *\n * @return a Promise that resolves to the JSON-LD document.\n */\njsonld.fromRDF = util.callbackify(async function(dataset, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert from RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    format: _isString(dataset) ? 'application/n-quads' : undefined\n  });\n\n  const {format} = options;\n  let {rdfParser} = options;\n\n  // handle special format\n  if(format) {\n    // check supported formats\n    rdfParser = rdfParser || _rdfParsers[format];\n    if(!rdfParser) {\n      throw new JsonLdError(\n        'Unknown input format.',\n        'jsonld.UnknownFormat', {format});\n    }\n  } else {\n    // no-op parser, assume dataset already parsed\n    rdfParser = () => dataset;\n  }\n\n  // TODO: call `normalizeAsyncFn` on parser fn\n\n  // rdfParser can be callback, promise-based, or synchronous\n  let parsedDataset;\n  if(rdfParser.length > 1) {\n    // convert callback-based rdf parser to promise-based\n    parsedDataset = new Promise((resolve, reject) => {\n      rdfParser(dataset, (err, dataset) => {\n        if(err) {\n          reject(err);\n        } else {\n          resolve(dataset);\n        }\n      });\n    });\n  } else {\n    parsedDataset = Promise.resolve(rdfParser(dataset));\n  }\n\n  parsedDataset = await parsedDataset;\n\n  // back-compat with old parsers that produced legacy dataset format\n  if(!Array.isArray(parsedDataset)) {\n    parsedDataset = NQuads.legacyDatasetToQuads(parsedDataset);\n  }\n\n  return _fromRDF(parsedDataset, options);\n});\n\n/**\n * Outputs the RDF dataset found in the given JSON-LD object.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [format] the format to use to output a string:\n *            'application/n-quads' for N-Quads.\n *          [produceGeneralizedRdf] true to output generalized RDF, false\n *            to produce only standard RDF (default: false).\n *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n * @param [callback(err, dataset)] called once the operation completes.\n *\n * @return a Promise that resolves to the RDF dataset.\n */\njsonld.toRDF = util.callbackify(async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert to RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    skipExpansion: false\n  });\n\n  // TODO: support toRDF custom map?\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    // expand input\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // output RDF dataset\n  const dataset = _toRDF(expanded, options);\n  if(options.format) {\n    if(options.format === 'application/n-quads' ||\n      options.format === 'application/nquads') {\n      return await NQuads.serialize(dataset);\n    }\n    throw new JsonLdError(\n      'Unknown output format.',\n      'jsonld.UnknownFormat', {format: options.format});\n  }\n\n  return dataset;\n});\n\n/**\n * **Experimental**\n *\n * Recursively flattens the nodes in the given JSON-LD input into a merged\n * map of node ID => node. All graphs will be merged into the default graph.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n * @param [callback(err, nodeMap)] called once the operation completes.\n *\n * @return a Promise that resolves to the merged node map.\n */\njsonld.createNodeMap = util.callbackify(async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not create node map, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : ''\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  return _createMergedNodeMap(expanded, options);\n});\n\n/**\n * **Experimental**\n *\n * Merges two or more JSON-LD documents into a single flattened document.\n *\n * @param docs the JSON-LD documents to merge together.\n * @param ctx the context to use to compact the merged result, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [mergeNodes] true to merge properties for nodes with the same ID,\n *            false to ignore new properties for nodes with the same ID once\n *            the ID has been defined; note that this may not prevent merging\n *            new properties where a node is in the `object` position\n *            (default: true).\n *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n * @param [callback(err, merged)] called once the operation completes.\n *\n * @return a Promise that resolves to the merged output.\n */\njsonld.merge = util.callbackify(async function(docs, ctx, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not merge, too few arguments.');\n  }\n  if(!_isArray(docs)) {\n    throw new TypeError('Could not merge, \"docs\" must be an array.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {});\n\n  // expand all documents\n  const expanded = await Promise.all(docs.map(doc => {\n    const opts = Object.assign({}, options);\n    return jsonld.expand(doc, opts);\n  }));\n\n  let mergeNodes = true;\n  if('mergeNodes' in options) {\n    mergeNodes = options.mergeNodes;\n  }\n\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n\n  for(let i = 0; i < expanded.length; ++i) {\n    // uniquely relabel blank nodes\n    const doc = util.relabelBlankNodes(expanded[i], {\n      issuer: new IdentifierIssuer('_:b' + i + '-')\n    });\n\n    // add nodes to the shared node map graphs if merging nodes, to a\n    // separate graph set if not\n    const _graphs = (mergeNodes || i === 0) ? graphs : {'@default': {}};\n    _createNodeMap(doc, _graphs, '@default', issuer);\n\n    if(_graphs !== graphs) {\n      // merge document graphs but don't merge existing nodes\n      for(const graphName in _graphs) {\n        const _nodeMap = _graphs[graphName];\n        if(!(graphName in graphs)) {\n          graphs[graphName] = _nodeMap;\n          continue;\n        }\n        const nodeMap = graphs[graphName];\n        for(const key in _nodeMap) {\n          if(!(key in nodeMap)) {\n            nodeMap[key] = _nodeMap[key];\n          }\n        }\n      }\n    }\n  }\n\n  // add all non-default graphs to default graph\n  const defaultGraph = _mergeNodeMaps(graphs);\n\n  // produce flattened output\n  const flattened = [];\n  const keys = Object.keys(defaultGraph).sort();\n  for(let ki = 0; ki < keys.length; ++ki) {\n    const node = defaultGraph[keys[ki]];\n    // only add full subjects to top-level\n    if(!_isSubjectReference(node)) {\n      flattened.push(node);\n    }\n  }\n\n  if(ctx === null) {\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n});\n\n/**\n * The default document loader for external documents. If the environment\n * is node.js, a callback-continuation-style document loader is used; otherwise,\n * a promises-style document loader is used.\n *\n * @param url the URL to load.\n * @param callback(err, remoteDoc) called once the operation completes,\n *          if using a non-promises API.\n *\n * @return a promise, if using a promises API.\n */\nObject.defineProperty(jsonld, 'documentLoader', {\n  get: () => jsonld._documentLoader,\n  set: v => jsonld._documentLoader = util.normalizeDocumentLoader(v)\n});\n// default document loader not implemented\njsonld.documentLoader = async url => {\n  throw new JsonLdError(\n    'Could not retrieve a JSON-LD document from the URL. URL ' +\n    'dereferencing not implemented.', 'jsonld.LoadDocumentError',\n    {code: 'loading document failed', url});\n};\n\n/**\n * Deprecated default document loader. Do not use or override.\n */\njsonld.loadDocument = util.callbackify(async function() {\n  return jsonld.documentLoader.apply(null, arguments);\n});\n\n/**\n * Gets a remote JSON-LD document using the default document loader or\n * one given in the passed options.\n *\n * @param url the URL to fetch.\n * @param [options] the options to use:\n *          [documentLoader] the document loader to use.\n * @param [callback(err, remoteDoc)] called once the operation completes.\n *\n * @return a Promise that resolves to the retrieved remote document.\n */\njsonld.get = util.callbackify(async function(url, options) {\n  let load;\n  if(typeof options.documentLoader === 'function') {\n    load = util.normalizeDocumentLoader(options.documentLoader);\n  } else {\n    load = jsonld.documentLoader;\n  }\n\n  const remoteDoc = await load(url);\n\n  // TODO: can this be moved into `normalizeDocumentLoader`?\n  try {\n    if(!remoteDoc.document) {\n      throw new JsonLdError(\n        'No remote document found at the given URL.',\n        'jsonld.NullRemoteDocument');\n    }\n    if(_isString(remoteDoc.document)) {\n      remoteDoc.document = JSON.parse(remoteDoc.document);\n    }\n  } catch(e) {\n    throw new JsonLdError(\n      'Could not retrieve a JSON-LD document from the URL.',\n      'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        cause: e,\n        remoteDoc\n      });\n  }\n\n  return remoteDoc;\n});\n\n/**\n * Processes a local context, resolving any URLs as necessary, and returns a\n * new active context in its callback.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param [options] the options to use:\n *          [documentLoader(url, callback(err, remoteDoc))] the document loader.\n * @param [callback(err, activeCtx)] called once the operation completes.\n *\n * @return a Promise that resolves to the new active context.\n */\njsonld.processContext = util.callbackify(async function(\n  activeCtx, localCtx, options) {\n  // set default options\n  options = _setDefaults(options, {\n    base: ''\n  });\n\n  // return initial context early for null context\n  if(localCtx === null) {\n    return _getInitialContext(options);\n  }\n\n  // get URLs in localCtx\n  localCtx = util.clone(localCtx);\n  if(!(_isObject(localCtx) && '@context' in localCtx)) {\n    localCtx = {'@context': localCtx};\n  }\n  const ctx = await _getAllContexts(localCtx, options);\n\n  return _processContext({activeCtx, localCtx: ctx, options});\n});\n\n// backwards compatibility\njsonld.getContextValue = require('./context').getContextValue;\n\n/**\n * Document loaders.\n */\njsonld.documentLoaders = {};\njsonld.documentLoaders.node = require('./documentLoaders/node');\njsonld.documentLoaders.xhr = require('./documentLoaders/xhr');\n\n/**\n * Assigns the default document loader for external document URLs to a built-in\n * default. Supported types currently include: 'xhr' and 'node'.\n *\n * @param type the type to set.\n * @param [params] the parameters required to use the document loader.\n */\njsonld.useDocumentLoader = function(type) {\n  if(!(type in jsonld.documentLoaders)) {\n    throw new JsonLdError(\n      'Unknown document loader type: \"' + type + '\"',\n      'jsonld.UnknownDocumentLoader',\n      {type});\n  }\n\n  // set document loader\n  jsonld.documentLoader = jsonld.documentLoaders[type].apply(\n    jsonld, Array.prototype.slice.call(arguments, 1));\n};\n\n/**\n * Registers an RDF dataset parser by content-type, for use with\n * jsonld.fromRDF. An RDF dataset parser will always be given two parameters,\n * a string of input and a callback. An RDF dataset parser can be synchronous\n * or asynchronous.\n *\n * If the parser function returns undefined or null then it will be assumed to\n * be asynchronous w/a continuation-passing style and the callback parameter\n * given to the parser MUST be invoked.\n *\n * If it returns a Promise, then it will be assumed to be asynchronous, but the\n * callback parameter MUST NOT be invoked. It should instead be ignored.\n *\n * If it returns an RDF dataset, it will be assumed to be synchronous and the\n * callback parameter MUST NOT be invoked. It should instead be ignored.\n *\n * @param contentType the content-type for the parser.\n * @param parser(input, callback(err, dataset)) the parser function (takes a\n *          string as a parameter and either returns null/undefined and uses\n *          the given callback, returns a Promise, or returns an RDF dataset).\n */\njsonld.registerRDFParser = function(contentType, parser) {\n  _rdfParsers[contentType] = parser;\n};\n\n/**\n * Unregisters an RDF dataset parser by content-type.\n *\n * @param contentType the content-type for the parser.\n */\njsonld.unregisterRDFParser = function(contentType) {\n  delete _rdfParsers[contentType];\n};\n\n// register the N-Quads RDF parser\njsonld.registerRDFParser('application/n-quads', NQuads.parse);\njsonld.registerRDFParser('application/nquads', NQuads.parse);\n\n// register the RDFa API RDF parser\njsonld.registerRDFParser('rdfa-api', Rdfa.parse);\n\n/* URL API */\njsonld.url = require('./url');\n\n/* Utility API */\njsonld.util = util;\n// backwards compatibility\nObject.assign(jsonld, util);\n\n// reexpose API as jsonld.promises for backwards compatability\njsonld.promises = jsonld;\n\n// backwards compatibility\njsonld.RequestQueue = require('./RequestQueue');\n\n/* WebIDL API */\njsonld.JsonLdProcessor = require('./JsonLdProcessor')(jsonld);\n\n// setup browser global JsonLdProcessor\nif(_browser && typeof global.JsonLdProcessor === 'undefined') {\n  Object.defineProperty(global, 'JsonLdProcessor', {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: jsonld.JsonLdProcessor\n  });\n}\n\n// set platform-specific defaults/APIs\nif(_nodejs) {\n  // use node document loader by default\n  jsonld.useDocumentLoader('node');\n} else if(typeof XMLHttpRequest !== 'undefined') {\n  // use xhr document loader by default\n  jsonld.useDocumentLoader('xhr');\n}\n\nfunction _setDefaults(options, {\n  documentLoader = jsonld.documentLoader,\n  ...defaults\n}) {\n  return Object.assign({}, {documentLoader}, defaults, options);\n}\n\n// end of jsonld API `wrapper` factory\nreturn jsonld;\n};\n\n// external APIs:\n\n// used to generate a new jsonld API instance\nconst factory = function() {\n  return wrapper(function() {\n    return factory();\n  });\n};\n\n// wrap the main jsonld API instance\nwrapper(factory);\n// export API\nmodule.exports = factory;\n"]},"metadata":{},"sourceType":"script"}