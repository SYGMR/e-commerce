{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Guillaume\\\\Code\\\\e-commerce\\\\admin\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _require = require('../util'),\n    parseLinkHeader = _require.parseLinkHeader,\n    buildHeaders = _require.buildHeaders;\n\nvar _require2 = require('../constants'),\n    LINK_HEADER_REL = _require2.LINK_HEADER_REL;\n\nvar JsonLdError = require('../JsonLdError');\n\nvar RequestQueue = require('../RequestQueue');\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          strictSSL: true to require SSL certificates to be valid,\n *            false not to (default: true).\n *          maxRedirects: the maximum number of redirects to permit, none by\n *            default.\n *          request: the object which will make the request, default is\n *            provided by `https://www.npmjs.com/package/request`.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *\n * @return the node document loader.\n */\n\n\nmodule.exports = function () {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    strictSSL: true,\n    maxRedirects: -1,\n    headers: {}\n  },\n      secure = _ref.secure,\n      _ref$strictSSL = _ref.strictSSL,\n      strictSSL = _ref$strictSSL === void 0 ? true : _ref$strictSSL,\n      _ref$maxRedirects = _ref.maxRedirects,\n      maxRedirects = _ref$maxRedirects === void 0 ? -1 : _ref$maxRedirects,\n      request = _ref.request,\n      _ref$headers = _ref.headers,\n      headers = _ref$headers === void 0 ? {} : _ref$headers;\n\n  headers = buildHeaders(headers); // TODO: use `r2`\n\n  request = request || require('request');\n\n  var http = require('http'); // TODO: disable cache until HTTP caching implemented\n  //const cache = new DocumentCache();\n\n\n  var queue = new RequestQueue();\n  return queue.wrapLoader(function (url) {\n    return loadDocument(url, []);\n  });\n\n  function loadDocument(url, redirects) {\n    var doc, result, _result, res, body, statusText, linkHeader;\n\n    return _regeneratorRuntime.async(function loadDocument$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0)) {\n              _context.next = 2;\n              break;\n            }\n\n            throw new JsonLdError('URL could not be dereferenced; only \"http\" and \"https\" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {\n              code: 'loading document failed',\n              url: url\n            });\n\n          case 2:\n            if (!(secure && url.indexOf('https') !== 0)) {\n              _context.next = 4;\n              break;\n            }\n\n            throw new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\\'s scheme is not \"https\".', 'jsonld.InvalidUrl', {\n              code: 'loading document failed',\n              url: url\n            });\n\n          case 4:\n            // TODO: disable cache until HTTP caching implemented\n            doc = null; //cache.get(url);\n\n            if (!(doc !== null)) {\n              _context.next = 7;\n              break;\n            }\n\n            return _context.abrupt(\"return\", doc);\n\n          case 7:\n            _context.prev = 7;\n            _context.next = 10;\n            return _regeneratorRuntime.awrap(_request(request, {\n              url: url,\n              headers: headers,\n              strictSSL: strictSSL,\n              followRedirect: false\n            }));\n\n          case 10:\n            result = _context.sent;\n            _context.next = 16;\n            break;\n\n          case 13:\n            _context.prev = 13;\n            _context.t0 = _context[\"catch\"](7);\n            throw new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {\n              code: 'loading document failed',\n              url: url,\n              cause: _context.t0\n            });\n\n          case 16:\n            _result = result, res = _result.res, body = _result.body;\n            doc = {\n              contextUrl: null,\n              documentUrl: url,\n              document: body || null\n            }; // handle error\n\n            statusText = http.STATUS_CODES[res.statusCode];\n\n            if (!(res.statusCode >= 400)) {\n              _context.next = 21;\n              break;\n            }\n\n            throw new JsonLdError('URL could not be dereferenced: ' + statusText, 'jsonld.InvalidUrl', {\n              code: 'loading document failed',\n              url: url,\n              httpStatusCode: res.statusCode\n            });\n\n          case 21:\n            if (!(res.headers.link && res.headers['content-type'] !== 'application/ld+json')) {\n              _context.next = 26;\n              break;\n            }\n\n            // only 1 related link header permitted\n            linkHeader = parseLinkHeader(res.headers.link)[LINK_HEADER_REL];\n\n            if (!Array.isArray(linkHeader)) {\n              _context.next = 25;\n              break;\n            }\n\n            throw new JsonLdError('URL could not be dereferenced, it has more than one associated ' + 'HTTP Link Header.', 'jsonld.InvalidUrl', {\n              code: 'multiple context link headers',\n              url: url\n            });\n\n          case 25:\n            if (linkHeader) {\n              doc.contextUrl = linkHeader.target;\n            }\n\n          case 26:\n            if (!(res.statusCode >= 300 && res.statusCode < 400 && res.headers.location)) {\n              _context.next = 33;\n              break;\n            }\n\n            if (!(redirects.length === maxRedirects)) {\n              _context.next = 29;\n              break;\n            }\n\n            throw new JsonLdError('URL could not be dereferenced; there were too many redirects.', 'jsonld.TooManyRedirects', {\n              code: 'loading document failed',\n              url: url,\n              httpStatusCode: res.statusCode,\n              redirects: redirects\n            });\n\n          case 29:\n            if (!(redirects.indexOf(url) !== -1)) {\n              _context.next = 31;\n              break;\n            }\n\n            throw new JsonLdError('URL could not be dereferenced; infinite redirection was detected.', 'jsonld.InfiniteRedirectDetected', {\n              code: 'recursive context inclusion',\n              url: url,\n              httpStatusCode: res.statusCode,\n              redirects: redirects\n            });\n\n          case 31:\n            redirects.push(url);\n            return _context.abrupt(\"return\", loadDocument(res.headers.location, redirects));\n\n          case 33:\n            // cache for each redirected URL\n            redirects.push(url); // TODO: disable cache until HTTP caching implemented\n\n            /*\n            for(let i = 0; i < redirects.length; ++i) {\n              cache.set(\n                redirects[i],\n                {contextUrl: null, documentUrl: redirects[i], document: body});\n            }\n            */\n\n            return _context.abrupt(\"return\", doc);\n\n          case 35:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[7, 13]]);\n  }\n};\n\nfunction _request(request, options) {\n  return new Promise(function (resolve, reject) {\n    request(options, function (err, res, body) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({\n          res: res,\n          body: body\n        });\n      }\n    });\n  });\n}","map":{"version":3,"sources":["C:/Users/Guillaume/Code/e-commerce/admin/node_modules/jsonld/lib/documentLoaders/node.js"],"names":["require","parseLinkHeader","buildHeaders","LINK_HEADER_REL","JsonLdError","RequestQueue","module","exports","strictSSL","maxRedirects","headers","secure","request","http","queue","wrapLoader","url","loadDocument","redirects","indexOf","code","doc","_request","followRedirect","result","cause","res","body","contextUrl","documentUrl","document","statusText","STATUS_CODES","statusCode","httpStatusCode","link","linkHeader","Array","isArray","target","location","length","push","options","Promise","resolve","reject","err"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {parseLinkHeader, buildHeaders} = require('../util');\nconst {LINK_HEADER_REL} = require('../constants');\nconst JsonLdError = require('../JsonLdError');\nconst RequestQueue = require('../RequestQueue');\n\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          strictSSL: true to require SSL certificates to be valid,\n *            false not to (default: true).\n *          maxRedirects: the maximum number of redirects to permit, none by\n *            default.\n *          request: the object which will make the request, default is\n *            provided by `https://www.npmjs.com/package/request`.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *\n * @return the node document loader.\n */\nmodule.exports = ({\n  secure,\n  strictSSL = true,\n  maxRedirects = -1,\n  request,\n  headers = {}\n} = {strictSSL: true, maxRedirects: -1, headers: {}}) => {\n  headers = buildHeaders(headers);\n  // TODO: use `r2`\n  request = request || require('request');\n  const http = require('http');\n  // TODO: disable cache until HTTP caching implemented\n  //const cache = new DocumentCache();\n\n  const queue = new RequestQueue();\n  return queue.wrapLoader(function(url) {\n    return loadDocument(url, []);\n  });\n\n  async function loadDocument(url, redirects) {\n    if(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; only \"http\" and \"https\" URLs are ' +\n        'supported.',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    if(secure && url.indexOf('https') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; secure mode is enabled and ' +\n        'the URL\\'s scheme is not \"https\".',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    // TODO: disable cache until HTTP caching implemented\n    let doc = null;//cache.get(url);\n    if(doc !== null) {\n      return doc;\n    }\n\n    let result;\n    try {\n      result = await _request(request, {\n        url,\n        headers,\n        strictSSL,\n        followRedirect: false\n      });\n    } catch(e) {\n      throw new JsonLdError(\n        'URL could not be dereferenced, an error occurred.',\n        'jsonld.LoadDocumentError',\n        {code: 'loading document failed', url, cause: e});\n    }\n\n    const {res, body} = result;\n\n    doc = {contextUrl: null, documentUrl: url, document: body || null};\n\n    // handle error\n    const statusText = http.STATUS_CODES[res.statusCode];\n    if(res.statusCode >= 400) {\n      throw new JsonLdError(\n        'URL could not be dereferenced: ' + statusText,\n        'jsonld.InvalidUrl', {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: res.statusCode\n        });\n    }\n\n    // handle Link Header\n    if(res.headers.link &&\n      res.headers['content-type'] !== 'application/ld+json') {\n      // only 1 related link header permitted\n      const linkHeader = parseLinkHeader(res.headers.link)[LINK_HEADER_REL];\n      if(Array.isArray(linkHeader)) {\n        throw new JsonLdError(\n          'URL could not be dereferenced, it has more than one associated ' +\n          'HTTP Link Header.',\n          'jsonld.InvalidUrl',\n          {code: 'multiple context link headers', url});\n      }\n      if(linkHeader) {\n        doc.contextUrl = linkHeader.target;\n      }\n    }\n\n    // handle redirect\n    if(res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      if(redirects.length === maxRedirects) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; there were too many redirects.',\n          'jsonld.TooManyRedirects', {\n            code: 'loading document failed',\n            url,\n            httpStatusCode: res.statusCode,\n            redirects\n          });\n      }\n      if(redirects.indexOf(url) !== -1) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; infinite redirection was detected.',\n          'jsonld.InfiniteRedirectDetected', {\n            code: 'recursive context inclusion',\n            url,\n            httpStatusCode: res.statusCode,\n            redirects\n          });\n      }\n      redirects.push(url);\n      return loadDocument(res.headers.location, redirects);\n    }\n\n    // cache for each redirected URL\n    redirects.push(url);\n    // TODO: disable cache until HTTP caching implemented\n    /*\n    for(let i = 0; i < redirects.length; ++i) {\n      cache.set(\n        redirects[i],\n        {contextUrl: null, documentUrl: redirects[i], document: body});\n    }\n    */\n\n    return doc;\n  }\n};\n\nfunction _request(request, options) {\n  return new Promise((resolve, reject) => {\n    request(options, (err, res, body) => {\n      if(err) {\n        reject(err);\n      } else {\n        resolve({res, body});\n      }\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"script"}