{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _toArray = require(\"C:\\\\Users\\\\Guillaume\\\\Code\\\\e-commerce\\\\admin\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toArray\");\n\nvar _defineProperty = require(\"C:\\\\Users\\\\Guillaume\\\\Code\\\\e-commerce\\\\admin\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar JsonLdError = require('./JsonLdError');\n\nvar _require = require('./types'),\n    _isArray = _require.isArray,\n    _isObject = _require.isObject,\n    _isString = _require.isString,\n    _isUndefined = _require.isUndefined;\n\nvar _require2 = require('./graphTypes'),\n    _isList = _require2.isList,\n    _isValue = _require2.isValue,\n    _isGraph = _require2.isGraph,\n    _isSimpleGraph = _require2.isSimpleGraph,\n    _isSubjectReference = _require2.isSubjectReference;\n\nvar _require3 = require('./context'),\n    _expandIri = _require3.expandIri,\n    _getContextValue = _require3.getContextValue,\n    _isKeyword = _require3.isKeyword,\n    _processContext = _require3.process;\n\nvar _require4 = require('./url'),\n    _removeBase = _require4.removeBase;\n\nvar _require5 = require('./util'),\n    _addValue = _require5.addValue,\n    _asArray = _require5.asArray,\n    _compareShortestLeast = _require5.compareShortestLeast;\n\nvar api = {};\nmodule.exports = api;\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return the compacted value.\n */\n\napi.compact = function (_ref) {\n  var activeCtx = _ref.activeCtx,\n      _ref$activeProperty = _ref.activeProperty,\n      activeProperty = _ref$activeProperty === void 0 ? null : _ref$activeProperty,\n      element = _ref.element,\n      _ref$options = _ref.options,\n      options = _ref$options === void 0 ? {} : _ref$options,\n      _ref$compactionMap = _ref.compactionMap,\n      compactionMap = _ref$compactionMap === void 0 ? function () {\n    return undefined;\n  } : _ref$compactionMap;\n\n  // recursively compact array\n  if (_isArray(element)) {\n    var rval = [];\n\n    for (var i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      var compacted = api.compact({\n        activeCtx: activeCtx,\n        activeProperty: activeProperty,\n        element: element[i],\n        options: options,\n        compactionMap: compactionMap\n      });\n\n      if (compacted === null) {\n        // TODO: use `await` to support async\n        compacted = compactionMap({\n          unmappedValue: element[i],\n          activeCtx: activeCtx,\n          activeProperty: activeProperty,\n          parent: element,\n          index: i,\n          options: options\n        });\n\n        if (compacted === undefined) {\n          continue;\n        }\n      }\n\n      rval.push(compacted);\n    }\n\n    if (options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      var container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n      if (container.length === 0) {\n        rval = rval[0];\n      }\n    }\n\n    return rval;\n  } // use any scoped context on activeProperty\n\n\n  var ctx = _getContextValue(activeCtx, activeProperty, '@context');\n\n  if (!_isUndefined(ctx)) {\n    // Note: spec's `from term` var is named `isPropertyTermScopedContext`\n    activeCtx = _processContext({\n      activeCtx: activeCtx,\n      localCtx: ctx,\n      isPropertyTermScopedContext: true,\n      options: options\n    });\n  } // recursively compact object\n\n\n  if (_isObject(element)) {\n    if (options.link && '@id' in element && options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      var linked = options.link[element['@id']];\n\n      for (var _i = 0; _i < linked.length; ++_i) {\n        if (linked[_i].expanded === element) {\n          return linked[_i].compacted;\n        }\n      }\n    } // do value compaction on @values and subject references\n\n\n    if (_isValue(element) || _isSubjectReference(element)) {\n      var _rval2 = api.compactValue({\n        activeCtx: activeCtx,\n        activeProperty: activeProperty,\n        value: element,\n        options: options\n      });\n\n      if (options.link && _isSubjectReference(element)) {\n        // store linked element\n        if (!options.link.hasOwnProperty(element['@id'])) {\n          options.link[element['@id']] = [];\n        }\n\n        options.link[element['@id']].push({\n          expanded: element,\n          compacted: _rval2\n        });\n      }\n\n      return _rval2;\n    } // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n\n\n    if (_isList(element)) {\n      var _container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n      if (_container.includes('@list')) {\n        return api.compact({\n          activeCtx: activeCtx,\n          activeProperty: activeProperty,\n          element: element['@list'],\n          options: options,\n          compactionMap: compactionMap\n        });\n      }\n    } // FIXME: avoid misuse of active property as an expanded property?\n\n\n    var insideReverse = activeProperty === '@reverse';\n    var _rval = {}; // revert type scoped context\n\n    activeCtx = activeCtx.revertTypeScopedContext();\n\n    if (options.link && '@id' in element) {\n      // store linked element\n      if (!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n\n      options.link[element['@id']].push({\n        expanded: element,\n        compacted: _rval\n      });\n    } // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n\n\n    var types = element['@type'] || [];\n\n    if (types.length > 1) {\n      types = Array.from(types).sort();\n    } // find all type-scoped contexts based on current context, prior to\n    // updating it\n\n\n    var typeContext = activeCtx;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = types[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var type = _step.value;\n        var compactedType = api.compactIri({\n          activeCtx: typeContext,\n          iri: type,\n          relativeTo: {\n            vocab: true\n          }\n        }); // Use any type-scoped context defined on this value\n\n        var _ctx = _getContextValue(typeContext, compactedType, '@context');\n\n        if (!_isUndefined(_ctx)) {\n          activeCtx = _processContext({\n            activeCtx: activeCtx,\n            localCtx: _ctx,\n            options: options,\n            isTypeScopedContext: true\n          });\n        }\n      } // process element keys in order\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var keys = Object.keys(element).sort();\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var expandedProperty = _step2.value;\n        var expandedValue = element[expandedProperty]; // compact @id and @type(s)\n\n        if (expandedProperty === '@id' || expandedProperty === '@type') {\n          var _ret = function () {\n            // if using a type-scoped context, resolve type values against previous\n            // context\n            var isType = expandedProperty === '@type';\n            var valueContext = isType ? activeCtx.previousContext || activeCtx : activeCtx;\n\n            var compactedValue = _asArray(expandedValue).map(function (expandedIri) {\n              return api.compactIri({\n                activeCtx: valueContext,\n                iri: expandedIri,\n                relativeTo: {\n                  vocab: isType\n                }\n              });\n            });\n\n            if (compactedValue.length === 1) {\n              compactedValue = compactedValue[0];\n            } // use keyword alias and add value\n\n\n            var alias = api.compactIri({\n              activeCtx: activeCtx,\n              iri: expandedProperty,\n              relativeTo: {\n                vocab: true\n              }\n            });\n            var isArray = _isArray(compactedValue) && expandedValue.length === 0;\n\n            _addValue(_rval, alias, compactedValue, {\n              propertyIsArray: isArray\n            });\n\n            return \"continue\";\n          }();\n\n          if (_ret === \"continue\") continue;\n        } // handle @reverse\n\n\n        if (expandedProperty === '@reverse') {\n          // recursively compact expanded value\n          var compactedValue = api.compact({\n            activeCtx: activeCtx,\n            activeProperty: '@reverse',\n            element: expandedValue,\n            options: options,\n            compactionMap: compactionMap\n          }); // handle double-reversed properties\n\n          for (var compactedProperty in compactedValue) {\n            if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {\n              var value = compactedValue[compactedProperty];\n\n              var _container2 = _getContextValue(activeCtx, compactedProperty, '@container') || [];\n\n              var useArray = _container2.includes('@set') || !options.compactArrays;\n\n              _addValue(_rval, compactedProperty, value, {\n                propertyIsArray: useArray\n              });\n\n              delete compactedValue[compactedProperty];\n            }\n          }\n\n          if (Object.keys(compactedValue).length > 0) {\n            // use keyword alias and add value\n            var alias = api.compactIri({\n              activeCtx: activeCtx,\n              iri: expandedProperty,\n              relativeTo: {\n                vocab: true\n              }\n            });\n\n            _addValue(_rval, alias, compactedValue);\n          }\n\n          continue;\n        }\n\n        if (expandedProperty === '@preserve') {\n          // compact using activeProperty\n          var _compactedValue = api.compact({\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            element: expandedValue,\n            options: options,\n            compactionMap: compactionMap\n          });\n\n          if (!(_isArray(_compactedValue) && _compactedValue.length === 0)) {\n            _addValue(_rval, expandedProperty, _compactedValue);\n          }\n\n          continue;\n        } // handle @index property\n\n\n        if (expandedProperty === '@index') {\n          // drop @index if inside an @index container\n          var _container3 = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n          if (_container3.includes('@index')) {\n            continue;\n          } // use keyword alias and add value\n\n\n          var _alias = api.compactIri({\n            activeCtx: activeCtx,\n            iri: expandedProperty,\n            relativeTo: {\n              vocab: true\n            }\n          });\n\n          _addValue(_rval, _alias, expandedValue);\n\n          continue;\n        } // skip array processing for keywords that aren't @graph or @list\n\n\n        if (expandedProperty !== '@graph' && expandedProperty !== '@list' && _isKeyword(expandedProperty)) {\n          // use keyword alias and add value as is\n          var _alias2 = api.compactIri({\n            activeCtx: activeCtx,\n            iri: expandedProperty,\n            relativeTo: {\n              vocab: true\n            }\n          });\n\n          _addValue(_rval, _alias2, expandedValue);\n\n          continue;\n        } // Note: expanded value must be an array due to expansion algorithm.\n\n\n        if (!_isArray(expandedValue)) {\n          throw new JsonLdError('JSON-LD expansion error; expanded value must be an array.', 'jsonld.SyntaxError');\n        } // preserve empty arrays\n\n\n        if (expandedValue.length === 0) {\n          var itemActiveProperty = api.compactIri({\n            activeCtx: activeCtx,\n            iri: expandedProperty,\n            value: expandedValue,\n            relativeTo: {\n              vocab: true\n            },\n            reverse: insideReverse\n          });\n          var nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n          var nestResult = _rval;\n\n          if (nestProperty) {\n            _checkNestProperty(activeCtx, nestProperty, options);\n\n            if (!_isObject(_rval[nestProperty])) {\n              _rval[nestProperty] = {};\n            }\n\n            nestResult = _rval[nestProperty];\n          }\n\n          _addValue(nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n        } // recusively process array values\n\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = expandedValue[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var expandedItem = _step3.value;\n\n            // compact property and get container type\n            var _itemActiveProperty = api.compactIri({\n              activeCtx: activeCtx,\n              iri: expandedProperty,\n              value: expandedItem,\n              relativeTo: {\n                vocab: true\n              },\n              reverse: insideReverse\n            }); // if itemActiveProperty is a @nest property, add values to nestResult,\n            // otherwise rval\n\n\n            var _nestProperty = activeCtx.mappings.has(_itemActiveProperty) ? activeCtx.mappings.get(_itemActiveProperty)['@nest'] : null;\n\n            var _nestResult = _rval;\n\n            if (_nestProperty) {\n              _checkNestProperty(activeCtx, _nestProperty, options);\n\n              if (!_isObject(_rval[_nestProperty])) {\n                _rval[_nestProperty] = {};\n              }\n\n              _nestResult = _rval[_nestProperty];\n            }\n\n            var _container4 = _getContextValue(activeCtx, _itemActiveProperty, '@container') || []; // get simple @graph or @list value if appropriate\n\n\n            var isGraph = _isGraph(expandedItem);\n\n            var isList = _isList(expandedItem);\n\n            var inner = void 0;\n\n            if (isList) {\n              inner = expandedItem['@list'];\n            } else if (isGraph) {\n              inner = expandedItem['@graph'];\n            } // recursively compact expanded item\n\n\n            var compactedItem = api.compact({\n              activeCtx: activeCtx,\n              activeProperty: _itemActiveProperty,\n              element: isList || isGraph ? inner : expandedItem,\n              options: options,\n              compactionMap: compactionMap\n            }); // handle @list\n\n            if (isList) {\n              // ensure @list value is an array\n              if (!_isArray(compactedItem)) {\n                compactedItem = [compactedItem];\n              }\n\n              if (!_container4.includes('@list')) {\n                // wrap using @list alias\n                compactedItem = _defineProperty({}, api.compactIri({\n                  activeCtx: activeCtx,\n                  iri: '@list',\n                  relativeTo: {\n                    vocab: true\n                  }\n                }), compactedItem); // include @index from expanded @list, if any\n\n                if ('@index' in expandedItem) {\n                  compactedItem[api.compactIri({\n                    activeCtx: activeCtx,\n                    iri: '@index',\n                    relativeTo: {\n                      vocab: true\n                    }\n                  })] = expandedItem['@index'];\n                }\n              } else {\n                _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                  valueIsArray: true,\n                  allowDuplicate: true\n                });\n\n                continue;\n              }\n            } // Graph object compaction cases\n\n\n            if (isGraph) {\n              if (_container4.includes('@graph') && (_container4.includes('@id') || _container4.includes('@index') && _isSimpleGraph(expandedItem))) {\n                // get or create the map object\n                var mapObject = void 0;\n\n                if (_nestResult.hasOwnProperty(_itemActiveProperty)) {\n                  mapObject = _nestResult[_itemActiveProperty];\n                } else {\n                  _nestResult[_itemActiveProperty] = mapObject = {};\n                } // index on @id or @index or alias of @none\n\n\n                var key = (_container4.includes('@id') ? expandedItem['@id'] : expandedItem['@index']) || api.compactIri({\n                  activeCtx: activeCtx,\n                  iri: '@none',\n                  vocab: true\n                }); // add compactedItem to map, using value of `@id` or a new blank\n                // node identifier\n\n                _addValue(mapObject, key, compactedItem, {\n                  propertyIsArray: !options.compactArrays || _container4.includes('@set')\n                });\n              } else if (_container4.includes('@graph') && _isSimpleGraph(expandedItem)) {\n                // container includes @graph but not @id or @index and value is a\n                // simple graph object add compact value\n                _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                  propertyIsArray: !options.compactArrays || _container4.includes('@set')\n                });\n              } else {\n                // wrap using @graph alias, remove array if only one item and\n                // compactArrays not set\n                if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {\n                  compactedItem = compactedItem[0];\n                }\n\n                compactedItem = _defineProperty({}, api.compactIri({\n                  activeCtx: activeCtx,\n                  iri: '@graph',\n                  relativeTo: {\n                    vocab: true\n                  }\n                }), compactedItem); // include @id from expanded graph, if any\n\n                if ('@id' in expandedItem) {\n                  compactedItem[api.compactIri({\n                    activeCtx: activeCtx,\n                    iri: '@id',\n                    relativeTo: {\n                      vocab: true\n                    }\n                  })] = expandedItem['@id'];\n                } // include @index from expanded graph, if any\n\n\n                if ('@index' in expandedItem) {\n                  compactedItem[api.compactIri({\n                    activeCtx: activeCtx,\n                    iri: '@index',\n                    relativeTo: {\n                      vocab: true\n                    }\n                  })] = expandedItem['@index'];\n                }\n\n                _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                  propertyIsArray: !options.compactArrays || _container4.includes('@set')\n                });\n              }\n            } else if (_container4.includes('@language') || _container4.includes('@index') || _container4.includes('@id') || _container4.includes('@type')) {\n              // handle language and index maps\n              // get or create the map object\n              var _mapObject = void 0;\n\n              if (_nestResult.hasOwnProperty(_itemActiveProperty)) {\n                _mapObject = _nestResult[_itemActiveProperty];\n              } else {\n                _nestResult[_itemActiveProperty] = _mapObject = {};\n              }\n\n              var _key = void 0;\n\n              if (_container4.includes('@language')) {\n                // if container is a language map, simplify compacted value to\n                // a simple string\n                if (_isValue(compactedItem)) {\n                  compactedItem = compactedItem['@value'];\n                }\n\n                _key = expandedItem['@language'];\n              } else if (_container4.includes('@index')) {\n                _key = expandedItem['@index'];\n              } else if (_container4.includes('@id')) {\n                var idKey = api.compactIri({\n                  activeCtx: activeCtx,\n                  iri: '@id',\n                  vocab: true\n                });\n                _key = compactedItem[idKey];\n                delete compactedItem[idKey];\n              } else if (_container4.includes('@type')) {\n                var typeKey = api.compactIri({\n                  activeCtx: activeCtx,\n                  iri: '@type',\n                  vocab: true\n                });\n\n                var _types = void 0;\n\n                var _asArray2 = _asArray(compactedItem[typeKey] || []);\n\n                var _asArray3 = _toArray(_asArray2);\n\n                _key = _asArray3[0];\n                _types = _asArray3.slice(1);\n\n                switch (_types.length) {\n                  case 0:\n                    delete compactedItem[typeKey];\n                    break;\n\n                  case 1:\n                    compactedItem[typeKey] = _types[0];\n                    break;\n\n                  default:\n                    compactedItem[typeKey] = _types;\n                    break;\n                }\n              } // if compacting this value which has no key, index on @none\n\n\n              if (!_key) {\n                _key = api.compactIri({\n                  activeCtx: activeCtx,\n                  iri: '@none',\n                  vocab: true\n                });\n              } // add compact value to map object using key from expanded value\n              // based on the container type\n\n\n              _addValue(_mapObject, _key, compactedItem, {\n                propertyIsArray: _container4.includes('@set')\n              });\n            } else {\n              // use an array if: compactArrays flag is false,\n              // @container is @set or @list , value is an empty\n              // array, or key is @graph\n              var isArray = !options.compactArrays || _container4.includes('@set') || _container4.includes('@list') || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === '@list' || expandedProperty === '@graph'; // add compact value\n\n              _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                propertyIsArray: isArray\n              });\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return _rval;\n  } // only primitives remain which are already compact\n\n\n  return element;\n};\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\n\n\napi.compactIri = function (_ref2) {\n  var activeCtx = _ref2.activeCtx,\n      iri = _ref2.iri,\n      _ref2$value = _ref2.value,\n      value = _ref2$value === void 0 ? null : _ref2$value,\n      _ref2$relativeTo = _ref2.relativeTo,\n      relativeTo = _ref2$relativeTo === void 0 ? {\n    vocab: false\n  } : _ref2$relativeTo,\n      _ref2$reverse = _ref2.reverse,\n      reverse = _ref2$reverse === void 0 ? false : _ref2$reverse;\n\n  // can't compact null\n  if (iri === null) {\n    return iri;\n  } // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n\n\n  if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  var inverseCtx = activeCtx.getInverse(); // if term is a keyword, it may be compacted to a simple alias\n\n  if (_isKeyword(iri) && iri in inverseCtx && '@none' in inverseCtx[iri] && '@type' in inverseCtx[iri]['@none'] && '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  } // use inverse context to pick a term if iri is relative to vocab\n\n\n  if (relativeTo.vocab && iri in inverseCtx) {\n    var defaultLanguage = activeCtx['@language'] || '@none'; // prefer @index if available in value\n\n    var containers = [];\n\n    if (_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    } // if value is a preserve object, use its value\n\n\n    if (_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    } // prefer most specific container including @graph, prefering @set\n    // variations\n\n\n    if (_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if ('@index' in value) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      } // favor idmap if the graph is has an @id\n\n\n      if ('@id' in value) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n\n      containers.push('@graph', '@graph@set', '@set'); // allow indexmap if the graph is not indexed\n\n      if (!('@index' in value)) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      } // allow idmap if the graph does not have an @id\n\n\n      if (!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if (_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    } // defaults for term selection based on type/language\n\n\n    var typeOrLanguage = '@language';\n    var typeOrLanguageValue = '@null';\n\n    if (reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if (_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if (!('@index' in value)) {\n        containers.push('@list');\n      }\n\n      var list = value['@list'];\n\n      if (list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        var commonLanguage = list.length === 0 ? defaultLanguage : null;\n        var commonType = null;\n\n        for (var i = 0; i < list.length; ++i) {\n          var item = list[i];\n          var itemLanguage = '@none';\n          var itemType = '@none';\n\n          if (_isValue(item)) {\n            if ('@language' in item) {\n              itemLanguage = item['@language'];\n            } else if ('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n\n          if (commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if (itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n\n          if (commonType === null) {\n            commonType = itemType;\n          } else if (itemType !== commonType) {\n            commonType = '@none';\n          } // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n\n\n          if (commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n\n        if (commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if (_isValue(value)) {\n        if ('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n        } else if ('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n\n      containers.push('@set');\n    } // do term selection\n\n\n    containers.push('@none'); // an index map can be used to index values using @none, so add as a low\n    // priority\n\n    if (_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    } // values without type or language can use @language map\n\n\n    if (_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    var term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n\n    if (term !== null) {\n      return term;\n    }\n  } // no term match, use @vocab if available\n\n\n  if (relativeTo.vocab) {\n    if ('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      var vocab = activeCtx['@vocab'];\n\n      if (iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        var suffix = iri.substr(vocab.length);\n\n        if (!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  } // no term or @vocab match, check for possible CURIEs\n\n\n  var choice = null; // TODO: make FastCurieMap a class with a method to do this lookup\n\n  var partialMatches = [];\n  var iriMap = activeCtx.fastCurieMap; // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n\n  var maxPartialLength = iri.length - 1;\n\n  for (var _i2 = 0; _i2 < maxPartialLength && iri[_i2] in iriMap; ++_i2) {\n    iriMap = iriMap[iri[_i2]];\n\n    if ('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  } // check partial matches in reverse order to prefer longest ones first\n\n\n  for (var _i3 = partialMatches.length - 1; _i3 >= 0; --_i3) {\n    var entry = partialMatches[_i3];\n    var terms = entry.terms;\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = terms[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _term = _step4.value;\n        // a CURIE is usable if:\n        // 1. it has no mapping, OR\n        // 2. value is null, which means we're not compacting an @value, AND\n        //   the mapping matches the IRI\n        var curie = _term + ':' + iri.substr(entry.iri.length);\n        var isUsableCurie = activeCtx.mappings.get(_term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)['@id'] === iri); // select curie if it is shorter or the same length but lexicographically\n        // less than the current choice\n\n        if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {\n          choice = curie;\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  } // return chosen curie\n\n\n  if (choice !== null) {\n    return choice;\n  } // compact IRI relative to base\n\n\n  if (!relativeTo.vocab) {\n    return _removeBase(activeCtx['@base'], iri);\n  } // return IRI as is\n\n\n  return iri;\n};\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\n\n\napi.compactValue = function (_ref3) {\n  var activeCtx = _ref3.activeCtx,\n      activeProperty = _ref3.activeProperty,\n      value = _ref3.value,\n      options = _ref3.options;\n\n  // value is a @value\n  if (_isValue(value)) {\n    // get context rules\n    var _type = _getContextValue(activeCtx, activeProperty, '@type');\n\n    var language = _getContextValue(activeCtx, activeProperty, '@language');\n\n    var container = _getContextValue(activeCtx, activeProperty, '@container') || []; // whether or not the value has an @index that must be preserved\n\n    var preserveIndex = '@index' in value && !container.includes('@index'); // if there's no @index to preserve ...\n\n    if (!preserveIndex) {\n      // matching @type or @language specified in context, compact value\n      if (value['@type'] === _type || value['@language'] === language) {\n        return value['@value'];\n      }\n    } // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n\n\n    var keyCount = Object.keys(value).length;\n    var isValueOnlyKey = keyCount === 1 || keyCount === 2 && '@index' in value && !preserveIndex;\n    var hasDefaultLanguage = '@language' in activeCtx;\n\n    var isValueString = _isString(value['@value']);\n\n    var hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)['@language'] === null;\n\n    if (isValueOnlyKey && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    var rval = {}; // preserve @index\n\n    if (preserveIndex) {\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@index',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@index'];\n    }\n\n    if ('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@type',\n        relativeTo: {\n          vocab: true\n        }\n      })] = api.compactIri({\n        activeCtx: activeCtx,\n        iri: value['@type'],\n        relativeTo: {\n          vocab: true\n        }\n      });\n    } else if ('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@language',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@language'];\n    } // alias @value\n\n\n    rval[api.compactIri({\n      activeCtx: activeCtx,\n      iri: '@value',\n      relativeTo: {\n        vocab: true\n      }\n    })] = value['@value'];\n    return rval;\n  } // value is a subject reference\n\n\n  var expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n\n  var type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  var compacted = api.compactIri({\n    activeCtx: activeCtx,\n    iri: value['@id'],\n    relativeTo: {\n      vocab: type === '@vocab'\n    }\n  }); // compact to scalar\n\n  if (type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return _defineProperty({}, api.compactIri({\n    activeCtx: activeCtx,\n    iri: '@id',\n    relativeTo: {\n      vocab: true\n    }\n  }), compacted);\n};\n/**\n * Removes the @preserve keywords as the last step of the compaction\n * algorithm when it is running on framed output.\n *\n * @param ctx the active context used to compact the input.\n * @param input the framed, compacted output.\n * @param options the compaction options used.\n *\n * @return the resulting output.\n */\n\n\napi.removePreserve = function (ctx, input, options) {\n  // recurse through arrays\n  if (_isArray(input)) {\n    var output = [];\n\n    for (var i = 0; i < input.length; ++i) {\n      var result = api.removePreserve(ctx, input[i], options); // drop nulls from arrays\n\n      if (result !== null) {\n        output.push(result);\n      }\n    }\n\n    input = output;\n  } else if (_isObject(input)) {\n    // remove @preserve\n    if ('@preserve' in input) {\n      if (input['@preserve'] === '@null') {\n        return null;\n      }\n\n      return input['@preserve'];\n    } // skip @values\n\n\n    if (_isValue(input)) {\n      return input;\n    } // recurse through @lists\n\n\n    if (_isList(input)) {\n      input['@list'] = api.removePreserve(ctx, input['@list'], options);\n      return input;\n    } // handle in-memory linked nodes\n\n\n    var idAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@id',\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    if (input.hasOwnProperty(idAlias)) {\n      var id = input[idAlias];\n\n      if (options.link.hasOwnProperty(id)) {\n        var idx = options.link[id].indexOf(input);\n\n        if (idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        } // prevent circular visitation\n\n\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    } // recurse through properties\n\n\n    var graphAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@graph',\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    for (var prop in input) {\n      // potentially remove the id, if it is an unreference bnode\n      if (prop === idAlias && options.bnodesToClear.includes(input[prop])) {\n        delete input[idAlias];\n        continue;\n      }\n\n      var _result = api.removePreserve(ctx, input[prop], options);\n\n      var container = _getContextValue(ctx, prop, '@container') || [];\n\n      if (options.compactArrays && _isArray(_result) && _result.length === 1 && container.length === 0 && prop !== graphAlias) {\n        _result = _result[0];\n      }\n\n      input[prop] = _result;\n    }\n  }\n\n  return input;\n};\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\n\n\nfunction _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if (typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  } // preferences for the value of @type or @language\n\n\n  var prefs = []; // determine prefs for @id based on whether or not value compacts to a term\n\n  if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') && _isSubjectReference(value)) {\n    // prefer @reverse first\n    if (typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    } // try to compact value to a term\n\n\n    var term = api.compactIri({\n      activeCtx: activeCtx,\n      iri: value['@id'],\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n  }\n\n  prefs.push('@none');\n  var containerMap = activeCtx.inverse[iri];\n\n  for (var ci = 0; ci < containers.length; ++ci) {\n    // if container not available in the map, continue\n    var container = containers[ci];\n\n    if (!(container in containerMap)) {\n      continue;\n    }\n\n    var typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n\n    for (var pi = 0; pi < prefs.length; ++pi) {\n      // if type/language option not available in the map, continue\n      var pref = prefs[pi];\n\n      if (!(pref in typeOrLanguageValueMap)) {\n        continue;\n      } // select term\n\n\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\n\n\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if (_expandIri(activeCtx, nestProperty, {\n    vocab: true\n  }, options) !== '@nest') {\n    throw new JsonLdError('JSON-LD compact error; nested property must have an @nest value ' + 'resolving to @nest.', 'jsonld.SyntaxError', {\n      code: 'invalid @nest value'\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/Guillaume/Code/e-commerce/admin/node_modules/jsonld/lib/compact.js"],"names":["JsonLdError","require","_isArray","isArray","_isObject","isObject","_isString","isString","_isUndefined","isUndefined","_isList","isList","_isValue","isValue","_isGraph","isGraph","_isSimpleGraph","isSimpleGraph","_isSubjectReference","isSubjectReference","_expandIri","expandIri","_getContextValue","getContextValue","_isKeyword","isKeyword","_processContext","process","_removeBase","removeBase","_addValue","addValue","_asArray","asArray","_compareShortestLeast","compareShortestLeast","api","module","exports","compact","activeCtx","activeProperty","element","options","compactionMap","undefined","rval","i","length","compacted","unmappedValue","parent","index","push","compactArrays","container","ctx","localCtx","isPropertyTermScopedContext","link","hasOwnProperty","linked","expanded","compactValue","value","includes","insideReverse","revertTypeScopedContext","types","Array","from","sort","typeContext","type","compactedType","compactIri","iri","relativeTo","vocab","isTypeScopedContext","keys","Object","expandedProperty","expandedValue","isType","valueContext","previousContext","compactedValue","map","expandedIri","alias","propertyIsArray","compactedProperty","mappings","has","get","reverse","useArray","itemActiveProperty","nestProperty","nestResult","_checkNestProperty","expandedItem","inner","compactedItem","valueIsArray","allowDuplicate","mapObject","key","idKey","typeKey","isPropertyTermScoped","inverseCtx","getInverse","defaultLanguage","containers","typeOrLanguage","typeOrLanguageValue","list","commonLanguage","commonType","item","itemLanguage","itemType","term","_selectTerm","indexOf","suffix","substr","choice","partialMatches","iriMap","fastCurieMap","maxPartialLength","entry","terms","curie","isUsableCurie","_prefix","language","preserveIndex","keyCount","isValueOnlyKey","hasDefaultLanguage","isValueString","hasNullMapping","removePreserve","input","output","result","idAlias","id","idx","graphAlias","prop","bnodesToClear","prefs","apply","containerMap","inverse","ci","typeOrLanguageValueMap","pi","pref","code"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext\n} = require('./context');\n\nconst {\n  removeBase: _removeBase\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return the compacted value.\n */\napi.compact = ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  compactionMap = () => undefined\n}) => {\n  // recursively compact array\n  if(_isArray(element)) {\n    let rval = [];\n    for(let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n      if(compacted === null) {\n        // TODO: use `await` to support async\n        compacted = compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n        if(compacted === undefined) {\n          continue;\n        }\n      }\n      rval.push(compacted);\n    }\n    if(options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if(!_isUndefined(ctx)) {\n    // Note: spec's `from term` var is named `isPropertyTermScopedContext`\n    activeCtx = _processContext({\n      activeCtx,\n      localCtx: ctx,\n      isPropertyTermScopedContext: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if(_isObject(element)) {\n    if(options.link && '@id' in element &&\n      options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for(let i = 0; i < linked.length; ++i) {\n        if(linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if(_isValue(element) || _isSubjectReference(element)) {\n      const rval =\n        api.compactValue({activeCtx, activeProperty, value: element, options});\n      if(options.link && _isSubjectReference(element)) {\n        // store linked element\n        if(!(options.link.hasOwnProperty(element['@id']))) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({expanded: element, compacted: rval});\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if(_isList(element)) {\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = (activeProperty === '@reverse');\n\n    const rval = {};\n\n    // revert type scoped context\n    activeCtx = activeCtx.revertTypeScopedContext();\n\n    if(options.link && '@id' in element) {\n      // store linked element\n      if(!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({expanded: element, compacted: rval});\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if(types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for(const type of types) {\n      const compactedType = api.compactIri(\n        {activeCtx: typeContext, iri: type, relativeTo: {vocab: true}});\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(typeContext, compactedType, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          isTypeScopedContext: true\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for(const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id and @type(s)\n      if(expandedProperty === '@id' || expandedProperty === '@type') {\n        // if using a type-scoped context, resolve type values against previous\n        // context\n        const isType = expandedProperty === '@type';\n        const valueContext = isType ?\n          (activeCtx.previousContext || activeCtx) : activeCtx;\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx: valueContext,\n            iri: expandedIri,\n            relativeTo: {vocab: isType}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: expandedProperty, relativeTo: {vocab: true}});\n        const isArray = _isArray(compactedValue) && expandedValue.length === 0;\n        _addValue(rval, alias, compactedValue, {propertyIsArray: isArray});\n        continue;\n      }\n\n      // handle @reverse\n      if(expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        // handle double-reversed properties\n        for(const compactedProperty in compactedValue) {\n          if(activeCtx.mappings.has(compactedProperty) &&\n            activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(\n              activeCtx, compactedProperty, '@container') || [];\n            const useArray = (\n              container.includes('@set') || !options.compactArrays);\n            _addValue(\n              rval, compactedProperty, value, {propertyIsArray: useArray});\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if(Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {vocab: true}\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if(expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap});\n\n        if(!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if(expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(\n          activeCtx, activeProperty, '@container') || [];\n        if(container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't @graph or @list\n      if(expandedProperty !== '@graph' && expandedProperty !== '@list' &&\n        _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if(!_isArray(expandedValue)) {\n        throw new JsonLdError(\n          'JSON-LD expansion error; expanded value must be an array.',\n          'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if(expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(\n          nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n      }\n\n      // recusively process array values\n      for(const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(\n          activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if(isList) {\n          inner = expandedItem['@list'];\n        } else if(isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: (isList || isGraph) ? inner : expandedItem,\n          options,\n          compactionMap\n        });\n\n        // handle @list\n        if(isList) {\n          // ensure @list value is an array\n          if(!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if(!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if(isGraph) {\n          if(container.includes('@graph') && (container.includes('@id') ||\n            container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if(nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ?\n              expandedItem['@id'] : expandedItem['@index']) ||\n              api.compactIri({activeCtx, iri: '@none', vocab: true});\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(\n              mapObject, key, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else if(container.includes('@graph') &&\n            _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if(_isArray(compactedItem) && compactedItem.length === 1 &&\n              options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          }\n        } else if(container.includes('@language') ||\n          container.includes('@index') || container.includes('@id') ||\n          container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if(nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n          if(container.includes('@language')) {\n          // if container is a language map, simplify compacted value to\n          // a simple string\n            if(_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if(container.includes('@index')) {\n            key = expandedItem['@index'];\n          } else if(container.includes('@id')) {\n            const idKey = api.compactIri({activeCtx, iri: '@id', vocab: true});\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if(container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              vocab: true\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch(types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if(!key) {\n            key = api.compactIri({activeCtx, iri: '@none', vocab: true});\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(\n            mapObject, key, compactedItem, {\n              propertyIsArray: container.includes('@set')\n            });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = (!options.compactArrays ||\n            container.includes('@set') || container.includes('@list') ||\n            (_isArray(compactedItem) && compactedItem.length === 0) ||\n            expandedProperty === '@list' || expandedProperty === '@graph');\n\n          // add compact value\n          _addValue(\n            nestResult, itemActiveProperty, compactedItem,\n            {propertyIsArray: isArray});\n        }\n      }\n    }\n\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {vocab: false},\n  reverse = false\n}) => {\n  // can't compact null\n  if(iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if(activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if(_isKeyword(iri) &&\n    iri in inverseCtx &&\n    '@none' in inverseCtx[iri] &&\n    '@type' in inverseCtx[iri]['@none'] &&\n    '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if(relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if(_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if(_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if(_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if('@index' in value) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if('@id' in value) {\n        containers.push(\n          '@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if(!('@index' in value)) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if(!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if(_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if(reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if(_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if(!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if(list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = (list.length === 0) ? defaultLanguage : null;\n        let commonType = null;\n        for(let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if(_isValue(item)) {\n            if('@language' in item) {\n              itemLanguage = item['@language'];\n            } else if('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if(commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if(itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if(commonType === null) {\n            commonType = itemType;\n          } else if(itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if(commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if(commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if(_isValue(value)) {\n        if('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n        } else if('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if(_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if(_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(\n      activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if(term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if(relativeTo.vocab) {\n    if('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if(iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if(!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for(let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for(let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for(const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = (activeCtx.mappings.get(term)._prefix &&\n        (!activeCtx.mappings.has(curie) ||\n        (value === null && activeCtx.mappings.get(curie)['@id'] === iri)));\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if(isUsableCurie && (choice === null ||\n        _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if(choice !== null) {\n    return choice;\n  }\n\n  // compact IRI relative to base\n  if(!relativeTo.vocab) {\n    return _removeBase(activeCtx['@base'], iri);\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = ({activeCtx, activeProperty, value, options}) => {\n  // value is a @value\n  if(_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const container =\n      _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if(!preserveIndex) {\n      // matching @type or @language specified in context, compact value\n      if(value['@type'] === type || value['@language'] === language) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = (keyCount === 1 ||\n      (keyCount === 2 && '@index' in value && !preserveIndex));\n    const hasDefaultLanguage = ('@language' in activeCtx);\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = (activeCtx.mappings.has(activeProperty) &&\n      activeCtx.mappings.get(activeProperty)['@language'] === null);\n    if(isValueOnlyKey &&\n      (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {};\n\n    // preserve @index\n    if(preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {vocab: true}\n      })] = value['@index'];\n    }\n\n    if('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {vocab: true}\n      })] = api.compactIri(\n        {activeCtx, iri: value['@type'], relativeTo: {vocab: true}});\n    } else if('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {vocab: true}\n      })] = value['@language'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {vocab: true}\n    })] = value['@value'];\n\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true},\n    options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri(\n    {activeCtx, iri: value['@id'], relativeTo: {vocab: type === '@vocab'}});\n\n  // compact to scalar\n  if(type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    })]: compacted\n  };\n};\n\n/**\n * Removes the @preserve keywords as the last step of the compaction\n * algorithm when it is running on framed output.\n *\n * @param ctx the active context used to compact the input.\n * @param input the framed, compacted output.\n * @param options the compaction options used.\n *\n * @return the resulting output.\n */\napi.removePreserve = (ctx, input, options) => {\n  // recurse through arrays\n  if(_isArray(input)) {\n    const output = [];\n    for(let i = 0; i < input.length; ++i) {\n      const result = api.removePreserve(ctx, input[i], options);\n      // drop nulls from arrays\n      if(result !== null) {\n        output.push(result);\n      }\n    }\n    input = output;\n  } else if(_isObject(input)) {\n    // remove @preserve\n    if('@preserve' in input) {\n      if(input['@preserve'] === '@null') {\n        return null;\n      }\n      return input['@preserve'];\n    }\n\n    // skip @values\n    if(_isValue(input)) {\n      return input;\n    }\n\n    // recurse through @lists\n    if(_isList(input)) {\n      input['@list'] = api.removePreserve(ctx, input['@list'], options);\n      return input;\n    }\n\n    // handle in-memory linked nodes\n    const idAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    });\n    if(input.hasOwnProperty(idAlias)) {\n      const id = input[idAlias];\n      if(options.link.hasOwnProperty(id)) {\n        const idx = options.link[id].indexOf(input);\n        if(idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        }\n        // prevent circular visitation\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    }\n\n    // recurse through properties\n    const graphAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@graph',\n      relativeTo: {vocab: true}\n    });\n    for(const prop in input) {\n      // potentially remove the id, if it is an unreference bnode\n      if(prop === idAlias && options.bnodesToClear.includes(input[prop])) {\n        delete input[idAlias];\n        continue;\n      }\n\n      let result = api.removePreserve(ctx, input[prop], options);\n      const container = _getContextValue(ctx, prop, '@container') || [];\n      if(options.compactArrays && _isArray(result) && result.length === 1 &&\n        container.length === 0 && prop !== graphAlias) {\n        result = result[0];\n      }\n      input[prop] = result;\n    }\n  }\n  return input;\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(\n  activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if(typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') &&\n    _isSubjectReference(value)) {\n    // prefer @reverse first\n    if(typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri(\n      {activeCtx, iri: value['@id'], relativeTo: {vocab: true}});\n    if(activeCtx.mappings.has(term) &&\n      activeCtx.mappings.get(term) &&\n      activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n  }\n  prefs.push('@none');\n\n  const containerMap = activeCtx.inverse[iri];\n  for(let ci = 0; ci < containers.length; ++ci) {\n    // if container not available in the map, continue\n    const container = containers[ci];\n    if(!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for(let pi = 0; pi < prefs.length; ++pi) {\n      // if type/language option not available in the map, continue\n      const pref = prefs[pi];\n      if(!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if(_expandIri(activeCtx, nestProperty, {vocab: true}, options) !== '@nest') {\n    throw new JsonLdError(\n      'JSON-LD compact error; nested property must have an @nest value ' +\n      'resolving to @nest.',\n      'jsonld.SyntaxError', {code: 'invalid @nest value'});\n  }\n}\n"]},"metadata":{},"sourceType":"script"}